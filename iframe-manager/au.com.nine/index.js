// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"fnLED":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "bebc91dccb5f5641";
module.bundle.HMR_BUNDLE_ID = "d107bd3313aea3c6";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws;
    try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        if (e.message) console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"4DpIT":[function(require,module,exports) {
// analytics libraries
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {Object} getAssetObject
 * @property {Array.streamObject} streams list of streams to attempt to play
 */ /**
 * @typedef {Object} streamObject
 * @property {string} url manifest/stream url
 * @property {object} drmConfig see AAMP.setDrmConfig() https://code.rdkcentral.com/r/plugins/gitiles/rdk/components/generic/aamp/+/refs/heads/stable2/AAMP-UVE-API.md#setdrmconfig_config
 * @property {Array.requestHeaderObject} requestHeaders see AAMP.addCustomHTTPHeader() https://code.rdkcentral.com/r/plugins/gitiles/rdk/components/generic/aamp/+/refs/heads/stable2/AAMP-UVE-API.md#addcustomhttpheader_headername_headervalue_islicenserequest
 */ /**
 * @callback requestHeaderObject
 * @param {string} key header name
 * @param {string} value header value
 * @param {boolean} isLicenseRequest is for license requests only
 */ parcelHelpers.export(exports, "default", ()=>NineProvider);
var _defineProperty = require("@swc/helpers/_/_define_property");
var _objectSpread = require("@swc/helpers/_/_object_spread");
var _adobeAnalyticsLibraries = require("./lib/adobe-analytics-libraries");
var _messengerLink = require("./helpers/MessengerLink");
var _messengers = require("./helpers/Messengers");
var _nineStore = require("./helpers/nine-store");
var _utils = require("./helpers/utils");
var _providerUtils = require("../provider-utils");
var _nineApi = require("./nine-services/nine-api");
var _nineAuth = require("./nine-services/nine-auth");
var _adobeAnalytics = require("./analytics/AdobeAnalytics");
var _adobeAnalyticsDefault = parcelHelpers.interopDefault(_adobeAnalytics);
var _adobeAudienceManager = require("./analytics/AdobeAudienceManager");
var _adobeAudienceManagerDefault = parcelHelpers.interopDefault(_adobeAudienceManager);
var _oztamBridge = require("./analytics/OztamBridge");
var _oztamBridgeDefault = parcelHelpers.interopDefault(_oztamBridge);
var _yospaceAds = require("./analytics/YospaceAds");
var _yospaceAdsDefault = parcelHelpers.interopDefault(_yospaceAds);
var _npaw = require("./analytics/Npaw");
var _npawDefault = parcelHelpers.interopDefault(_npaw);
var _nineProgramTracker = require("./nine-services/nine-program-tracker");
class NineProvider {
    /**
     * @typedef {import('../../app/get-asset').GetAssetRequest} GetAssetRequest
     * @typedef {import('../../app/get-asset').GetAssetResponse} GetAssetResponse
     */ /**
     * @param {GetAssetRequest} args requested asset and device information
     * @returns {GetAssetResponse} streams for the requested asset
     */ async getAsset({ authToken, glassAssetLocator, glassContentOptions, deviceInfo }) {
        var _this_config;
        let gracenoteId = getFileName(glassAssetLocator.pathname);
        const provider = glassAssetLocator.searchParams.get("provider");
        const providerId = glassAssetLocator.searchParams.get("providerid");
        const { glassConfigure: { brand: devicePlatform, version: deviceOSVersion }, uuid: deviceId } = deviceInfo;
        const { connectionType: networkConnectionType } = glassContentOptions;
        let nineNowAuthData;
        try {
            nineNowAuthData = JSON.parse(atob(authToken));
        } catch (e) {
            throw new (0, _providerUtils.MLEError)("Could not parse 9now auth data", (0, _providerUtils.ErrorTypes).GENERIC);
        }
        console.info("[acc] Nine received startup data", {
            nineNowAuthData,
            glassAssetLocator,
            glassAssetLocatorParsed: {
                gracenoteId,
                provider,
                providerId
            },
            glassContentOptions,
            deviceInfo,
            nineNowAuthData
        });
        console.info(`[acc] Accedo version ${(0, _nineStore.Store).appVersion}, parent app version ${deviceInfo.appVersion}, player version ${deviceInfo.playerVersion}`);
        let channelSlug, regionFromParent;
        try {
            const channelInfo = JSON.parse(providerId);
            if (!channelInfo.slug || !channelInfo.region) throw new Error();
            channelSlug = channelInfo.slug;
            regionFromParent = channelInfo.region;
        } catch (err) {
            throw new (0, _providerUtils.MLEError)("Could not parse 9now providerid slug or region", (0, _providerUtils.ErrorTypes).CHANNEL_MAP);
        }
        if (!nineNowAuthData.nuid || !nineNowAuthData.refresh_token) throw new (0, _providerUtils.MLEError)("No auth data provided, exiting ", (0, _providerUtils.ErrorTypes).AUTH);
        (0, _nineStore.Store).channelSlug = channelSlug;
        (0, _nineStore.Store).nuid = nineNowAuthData.nuid;
        (0, _nineStore.Store).deviceId = deviceId;
        (0, _nineStore.Store).aampVersion = deviceInfo.playerVersion;
        (0, _nineStore.Store).devicePlatform = devicePlatform;
        if (networkConnectionType.toLowerCase() === "ethernet") (0, _nineStore.Store).deviceNetworkConnection = (0, _utils.NetworkConnectionType).LAN;
        else if (networkConnectionType.toLowerCase() === "wifi") (0, _nineStore.Store).deviceNetworkConnection = (0, _utils.NetworkConnectionType).WIFI;
        // All of the below have to succeed. Expect them to throw their own MLE errors on error
        await (0, _nineApi.getAndStoreConfig)();
        // refreshAuth depends on clientId from config
        await (0, _nineAuth.refreshAuth)(nineNowAuthData.refresh_token, nineNowAuthData.nuid);
        // region request depends on access token from refreshAuth
        const apiRegion = await (0, _nineApi.getApiRegion)((0, _nineStore.Store).accessToken);
        (0, _nineStore.Store).region = apiRegion || regionFromParent || "nsw";
        let { sourceUrl } = await (0, _nineApi.get9NowPlaybackData)(channelSlug, (0, _nineStore.Store).region);
        try {
            // When the Yospace SDK creates a new playback URL, it'll add a session
            // ID parameter for playback analytics.
            const yospaceUrl = await (0, _yospaceAdsDefault.default).createSession(sourceUrl);
            sourceUrl = yospaceUrl;
        } catch (e) {
        // If session creation fails (eg. due to timeout), then use original
        // playback URL.
        }
        // store for npaw
        (0, _nineStore.Store).currentStreamUrl = sourceUrl;
        console.log("[acc] passing back video source", sourceUrl);
        return {
            aampInitConfigOverrides: (0, _objectSpread._)({}, (_this_config = this.config) === null || _this_config === void 0 ? void 0 : _this_config.aampInitConfigRemoteOverrides),
            streams: [
                {
                    url: sourceUrl
                }
            ]
        };
    }
    monitoringSetup(videoElement) {
        console.log("[acc] call monitoringSetup");
        if (!this.messengerLink) this.messengerLink = new (0, _messengerLink.MessengerLink)((0, _messengers.Messengers));
        this.videoElement = videoElement;
        this.messengerLink.unlinkVideoElementListeners(this.videoElement);
        this.messengerLink.linkVideoElementListeners(this.videoElement);
        // expect modules to destroy themselves when appTeardown$ fires
        (0, _oztamBridgeDefault.default).init();
        (0, _adobeAnalyticsDefault.default).init();
        (0, _adobeAudienceManagerDefault.default).init();
        (0, _yospaceAdsDefault.default).init();
        (0, _npawDefault.default).init();
    }
    monitoringTeardown() {
        console.log("[acc] call monitoringTeardown");
        if (this.messengerLink && this.videoElement) this.messengerLink.unlinkVideoElementListeners(this.videoElement);
        (0, _messengers.Messengers).appTeardown$.send();
        Object.keys((0, _messengers.Messengers)).forEach((key)=>(0, _messengers.Messengers)[key].reset());
    }
    constructor(config){
        (0, _defineProperty._)(this, "config", void 0);
        (0, _defineProperty._)(this, "messengerLink", void 0);
        this.config = config;
    }
}
function getFileName(url) {
    if (url) return url.substring(url.lastIndexOf("/") + 1, url.lastIndexOf("."));
    return "";
}

},{"@swc/helpers/_/_define_property":"9kWBJ","@swc/helpers/_/_object_spread":"lupAG","./lib/adobe-analytics-libraries":"b82Zf","./helpers/MessengerLink":"9fy0t","./helpers/Messengers":"48YTm","./helpers/nine-store":"d7nPH","./helpers/utils":"lhCx6","../provider-utils":"jTFkH","./nine-services/nine-api":"90vPW","./nine-services/nine-auth":"2EaaP","./analytics/AdobeAnalytics":"kDaqD","./analytics/AdobeAudienceManager":"he4KR","./analytics/OztamBridge":"dDF9x","./analytics/YospaceAds":"doV6l","./analytics/Npaw":"albJk","./nine-services/nine-program-tracker":"cxKPT","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"9kWBJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_define_property", ()=>_define_property);
parcelHelpers.export(exports, "_", ()=>_define_property);
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"840Gs":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"lupAG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_object_spread", ()=>_object_spread);
parcelHelpers.export(exports, "_", ()=>_object_spread);
var _definePropertyJs = require("./_define_property.js");
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
        ownKeys.forEach(function(key) {
            (0, _definePropertyJs._define_property)(target, key, source[key]);
        });
    }
    return target;
}

},{"./_define_property.js":"9kWBJ","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"b82Zf":[function(require,module,exports) {
// COPIED BOTH LIBRARIES FROM FAC NINE, WHICH COPIED FROM 9NOW APP
// MERGE INTO ONE FILE
// ADOBE ANALYTICS (omniture)
function AppMeasurement() {
    var a = this;
    a.version = "1.5.2";
    a.debugTracking = true;
    var k = window;
    k.s_c_in || (k.s_c_il = [], k.s_c_in = 0);
    a._il = k.s_c_il;
    a._in = k.s_c_in;
    a._il[a._in] = a;
    k.s_c_in++;
    a._c = "s_c";
    var q = k.AppMeasurement.zb;
    q || (q = null);
    var r = k, n, t;
    try {
        for(n = r.parent, t = r.location; n && n.location && t && "" + n.location != "" + t && r.location && "" + n.location != "" + r.location && n.location.host == t.host;)r = n, n = r.parent;
    } catch (u) {}
    a.ob = function(a) {
        try {
            console.log(a);
        } catch (b) {}
    };
    a.za = function(a) {
        return "" + parseInt(a) == "" + a;
    };
    a.replace = function(a, b, d) {
        return !a || 0 > a.indexOf(b) ? a : a.split(b).join(d);
    };
    a.escape = function(c) {
        var b, d;
        if (!c) return c;
        c = encodeURIComponent(c);
        for(b = 0; 7 > b; b++)d = "+~!*()'".substring(b, b + 1), 0 <= c.indexOf(d) && (c = a.replace(c, d, "%" + d.charCodeAt(0).toString(16).toUpperCase()));
        return c;
    };
    a.unescape = function(c) {
        if (!c) return c;
        c = 0 <= c.indexOf("+") ? a.replace(c, "+", " ") : c;
        try {
            return decodeURIComponent(c);
        } catch (b) {}
        return unescape(c);
    };
    a.gb = function() {
        var c = k.location.hostname, b = a.fpCookieDomainPeriods, d;
        b || (b = a.cookieDomainPeriods);
        if (c && !a.cookieDomain && !/^[0-9.]+$/.test(c) && (b = b ? parseInt(b) : 2, b = 2 < b ? b : 2, d = c.lastIndexOf("."), 0 <= d)) {
            for(; 0 <= d && 1 < b;)d = c.lastIndexOf(".", d - 1), b--;
            a.cookieDomain = 0 < d ? c.substring(d) : c;
        }
        return a.cookieDomain;
    };
    a.c_r = a.cookieRead = function(c) {
        c = a.escape(c);
        var b = " " + a.d.cookie, d = b.indexOf(" " + c + "="), f = 0 > d ? d : b.indexOf(";", d);
        c = 0 > d ? "" : a.unescape(b.substring(d + 2 + c.length, 0 > f ? b.length : f));
        return "[[B]]" != c ? c : "";
    };
    a.c_w = a.cookieWrite = function(c, b, d) {
        var f = a.gb(), e = a.cookieLifetime, g;
        b = "" + b;
        e = e ? ("" + e).toUpperCase() : "";
        d && "SESSION" != e && "NONE" != e && ((g = "" != b ? parseInt(e ? e : 0) : -60) ? (d = new Date, d.setTime(d.getTime() + 1E3 * g)) : 1 == d && (d = new Date, g = d.getYear(), d.setYear(g + 5 + (1900 > g ? 1900 : 0))));
        return c && "NONE" != e ? (a.d.cookie = c + "=" + a.escape("" != b ? b : "[[B]]") + "; path=/;" + (d && "SESSION" != e ? " expires=" + d.toGMTString() + ";" : "") + (f ? " domain=" + f + ";" : ""), a.cookieRead(c) == b) : 0;
    };
    a.G = [];
    a.ba = function(c, b, d) {
        if (a.ta) return 0;
        a.maxDelay || (a.maxDelay = 250);
        var f = 0, e = (new Date).getTime() + a.maxDelay, g = a.d.visibilityState, m = [
            "webkitvisibilitychange",
            "visibilitychange"
        ];
        g || (g = a.d.webkitVisibilityState);
        if (g && "prerender" == g) {
            if (!a.ca) for(a.ca = 1, d = 0; d < m.length; d++)a.d.addEventListener(m[d], function() {
                var c = a.d.visibilityState;
                c || (c = a.d.webkitVisibilityState);
                "visible" == c && (a.ca = 0, a.delayReady());
            });
            f = 1;
            e = 0;
        } else d || a.l("_d") && (f = 1);
        f && (a.G.push({
            m: c,
            a: b,
            t: e
        }), a.ca || setTimeout(a.delayReady, a.maxDelay));
        return f;
    };
    a.delayReady = function() {
        var c = (new Date).getTime(), b = 0, d;
        for(a.l("_d") ? b = 1 : a.na(); 0 < a.G.length;){
            d = a.G.shift();
            if (b && !d.t && d.t > c) {
                a.G.unshift(d);
                setTimeout(a.delayReady, parseInt(a.maxDelay / 2));
                break;
            }
            a.ta = 1;
            a[d.m].apply(a, d.a);
            a.ta = 0;
        }
    };
    a.setAccount = a.sa = function(c) {
        var b, d;
        if (!a.ba("setAccount", arguments)) {
            if (a.account = c, a.allAccounts) for(b = a.allAccounts.concat(c.split(",")), a.allAccounts = [], b.sort(), d = 0; d < b.length; d++)0 != d && b[d - 1] == b[d] || a.allAccounts.push(b[d]);
            else a.allAccounts = c.split(",");
        }
    };
    a.foreachVar = function(c, b) {
        var d, f, e, g, m = "";
        e = f = "";
        if (a.lightProfileID) d = a.K, (m = a.lightTrackVars) && (m = "," + m + "," + a.ga.join(",") + ",");
        else {
            d = a.c;
            if (a.pe || a.linkType) m = a.linkTrackVars, f = a.linkTrackEvents, a.pe && (e = a.pe.substring(0, 1).toUpperCase() + a.pe.substring(1), a[e] && (m = a[e].yb, f = a[e].xb));
            m && (m = "," + m + "," + a.A.join(",") + ",");
            f && m && (m += ",events,");
        }
        b && (b = "," + b + ",");
        for(f = 0; f < d.length; f++)e = d[f], (g = a[e]) && (!m || 0 <= m.indexOf("," + e + ",")) && (!b || 0 <= b.indexOf("," + e + ",")) && c(e, g);
    };
    a.B = function(c, b, d, f, e) {
        var g = "", m, p, k, w, n = 0;
        "contextData" == c && (c = "c");
        if (b) {
            for(m in b)if (!(Object.prototype[m] || e && m.substring(0, e.length) != e) && b[m] && (!d || 0 <= d.indexOf("," + (f ? f + "." : "") + m + ","))) {
                k = !1;
                if (n) for(p = 0; p < n.length; p++)m.substring(0, n[p].length) == n[p] && (k = !0);
                if (!k && ("" == g && (g += "&" + c + "."), p = b[m], e && (m = m.substring(e.length)), 0 < m.length)) {
                    if (k = m.indexOf("."), 0 < k) p = m.substring(0, k), k = (e ? e : "") + p + ".", n || (n = []), n.push(k), g += a.B(p, b, d, f, k);
                    else if ("boolean" == typeof p && (p = p ? "true" : "false"), p) {
                        if ("retrieveLightData" == f && 0 > e.indexOf(".contextData.")) switch(k = m.substring(0, 4), w = m.substring(4), m){
                            case "transactionID":
                                m = "xact";
                                break;
                            case "channel":
                                m = "ch";
                                break;
                            case "campaign":
                                m = "v0";
                                break;
                            default:
                                a.za(w) && ("prop" == k ? m = "c" + w : "eVar" == k ? m = "v" + w : "list" == k ? m = "l" + w : "hier" == k && (m = "h" + w, p = p.substring(0, 255)));
                        }
                        g += "&" + a.escape(m) + "=" + a.escape(p);
                    }
                }
            }
            "" != g && (g += "&." + c);
        }
        return g;
    };
    a.ib = function() {
        var c = "", b, d, f, e, g, m, p, k, n = "", r = "", s = e = "";
        if (a.lightProfileID) b = a.K, (n = a.lightTrackVars) && (n = "," + n + "," + a.ga.join(",") + ",");
        else {
            b = a.c;
            if (a.pe || a.linkType) n = a.linkTrackVars, r = a.linkTrackEvents, a.pe && (e = a.pe.substring(0, 1).toUpperCase() + a.pe.substring(1), a[e] && (n = a[e].yb, r = a[e].xb));
            n && (n = "," + n + "," + a.A.join(",") + ",");
            r && (r = "," + r + ",", n && (n += ",events,"));
            a.events2 && (s += ("" != s ? "," : "") + a.events2);
        }
        if (a.visitor && 1.5 <= parseFloat(a.visitor.version) && a.visitor.getCustomerIDs) {
            e = q;
            if (g = a.visitor.getCustomerIDs()) for(d in g)Object.prototype[d] || (f = g[d], e || (e = {}), f.id && (e[d + ".id"] = f.id), f.authState && (e[d + ".as"] = f.authState));
            e && (c += a.B("cid", e));
        }
        a.AudienceManagement && a.AudienceManagement.isReady() && (c += a.B("d", a.AudienceManagement.getEventCallConfigParams()));
        for(d = 0; d < b.length; d++){
            e = b[d];
            g = a[e];
            f = e.substring(0, 4);
            m = e.substring(4);
            !g && "events" == e && s && (g = s, s = "");
            if (g && (!n || 0 <= n.indexOf("," + e + ","))) {
                switch(e){
                    case "supplementalDataID":
                        e = "sdid";
                        break;
                    case "timestamp":
                        e = "ts";
                        break;
                    case "dynamicVariablePrefix":
                        e = "D";
                        break;
                    case "visitorID":
                        e = "vid";
                        break;
                    case "marketingCloudVisitorID":
                        e = "mid";
                        break;
                    case "analyticsVisitorID":
                        e = "aid";
                        break;
                    case "audienceManagerLocationHint":
                        e = "aamlh";
                        break;
                    case "audienceManagerBlob":
                        e = "aamb";
                        break;
                    case "authState":
                        e = "as";
                        break;
                    case "pageURL":
                        e = "g";
                        255 < g.length && (a.pageURLRest = g.substring(255), g = g.substring(0, 255));
                        break;
                    case "pageURLRest":
                        e = "-g";
                        break;
                    case "referrer":
                        e = "r";
                        break;
                    case "vmk":
                    case "visitorMigrationKey":
                        e = "vmt";
                        break;
                    case "visitorMigrationServer":
                        e = "vmf";
                        a.ssl && a.visitorMigrationServerSecure && (g = "");
                        break;
                    case "visitorMigrationServerSecure":
                        e = "vmf";
                        !a.ssl && a.visitorMigrationServer && (g = "");
                        break;
                    case "charSet":
                        e = "ce";
                        break;
                    case "visitorNamespace":
                        e = "ns";
                        break;
                    case "cookieDomainPeriods":
                        e = "cdp";
                        break;
                    case "cookieLifetime":
                        e = "cl";
                        break;
                    case "variableProvider":
                        e = "vvp";
                        break;
                    case "currencyCode":
                        e = "cc";
                        break;
                    case "channel":
                        e = "ch";
                        break;
                    case "transactionID":
                        e = "xact";
                        break;
                    case "campaign":
                        e = "v0";
                        break;
                    case "latitude":
                        e = "lat";
                        break;
                    case "longitude":
                        e = "lon";
                        break;
                    case "resolution":
                        e = "s";
                        break;
                    case "colorDepth":
                        e = "c";
                        break;
                    case "javascriptVersion":
                        e = "j";
                        break;
                    case "javaEnabled":
                        e = "v";
                        break;
                    case "cookiesEnabled":
                        e = "k";
                        break;
                    case "browserWidth":
                        e = "bw";
                        break;
                    case "browserHeight":
                        e = "bh";
                        break;
                    case "connectionType":
                        e = "ct";
                        break;
                    case "homepage":
                        e = "hp";
                        break;
                    case "events":
                        s && (g += ("" != g ? "," : "") + s);
                        if (r) for(m = g.split(","), g = "", f = 0; f < m.length; f++)p = m[f], k = p.indexOf("="), 0 <= k && (p = p.substring(0, k)), k = p.indexOf(":"), 0 <= k && (p = p.substring(0, k)), 0 <= r.indexOf("," + p + ",") && (g += (g ? "," : "") + m[f]);
                        break;
                    case "events2":
                        g = "";
                        break;
                    case "contextData":
                        c += a.B("c", a[e], n, e);
                        g = "";
                        break;
                    case "lightProfileID":
                        e = "mtp";
                        break;
                    case "lightStoreForSeconds":
                        e = "mtss";
                        a.lightProfileID || (g = "");
                        break;
                    case "lightIncrementBy":
                        e = "mti";
                        a.lightProfileID || (g = "");
                        break;
                    case "retrieveLightProfiles":
                        e = "mtsr";
                        break;
                    case "deleteLightProfiles":
                        e = "mtsd";
                        break;
                    case "retrieveLightData":
                        a.retrieveLightProfiles && (c += a.B("mts", a[e], n, e));
                        g = "";
                        break;
                    default:
                        a.za(m) && ("prop" == f ? e = "c" + m : "eVar" == f ? e = "v" + m : "list" == f ? e = "l" + m : "hier" == f && (e = "h" + m, g = g.substring(0, 255)));
                }
                g && (c += "&" + e + "=" + ("pev" != e.substring(0, 3) ? a.escape(g) : g));
            }
            "pev3" == e && a.e && (c += a.e);
        }
        return c;
    };
    a.u = function(a) {
        var b = a.tagName;
        if ("undefined" != "" + a.Cb || "undefined" != "" + a.sb && "HTML" != ("" + a.sb).toUpperCase()) return "";
        b = b && b.toUpperCase ? b.toUpperCase() : "";
        "SHAPE" == b && (b = "");
        b && (("INPUT" == b || "BUTTON" == b) && a.type && a.type.toUpperCase ? b = a.type.toUpperCase() : !b && a.href && (b = "A"));
        return b;
    };
    a.va = function(a) {
        var b = a.href ? a.href : "", d, f, e;
        d = b.indexOf(":");
        f = b.indexOf("?");
        e = b.indexOf("/");
        b && (0 > d || 0 <= f && d > f || 0 <= e && d > e) && (f = a.protocol && 1 < a.protocol.length ? a.protocol : l.protocol ? l.protocol : "", d = l.pathname.lastIndexOf("/"), b = (f ? f + "//" : "") + (a.host ? a.host : l.host ? l.host : "") + ("/" != h.substring(0, 1) ? l.pathname.substring(0, 0 > d ? 0 : d) + "/" : "") + b);
        return b;
    };
    a.H = function(c) {
        var b = a.u(c), d, f, e = "", g = 0;
        return b && (d = c.protocol, f = c.onclick, !c.href || "A" != b && "AREA" != b || f && d && !(0 > d.toLowerCase().indexOf("javascript")) ? f ? (e = a.replace(a.replace(a.replace(a.replace("" + f, "\r", ""), "\n", ""), "	", ""), " ", ""), g = 2) : "INPUT" == b || "SUBMIT" == b ? (c.value ? e = c.value : c.innerText ? e = c.innerText : c.textContent && (e = c.textContent), g = 3) : c.src && "IMAGE" == b && (e = c.src) : e = a.va(c), e) ? {
            id: e.substring(0, 100),
            type: g
        } : 0;
    };
    a.Ab = function(c) {
        for(var b = a.u(c), d = a.H(c); c && !d && "BODY" != b;)if (c = c.parentElement ? c.parentElement : c.parentNode) b = a.u(c), d = a.H(c);
        d && "BODY" != b || (c = 0);
        c && (b = c.onclick ? "" + c.onclick : "", 0 <= b.indexOf(".tl(") || 0 <= b.indexOf(".trackLink(")) && (c = 0);
        return c;
    };
    a.rb = function() {
        var c, b, d = a.linkObject, f = a.linkType, e = a.linkURL, g, m;
        a.ha = 1;
        d || (a.ha = 0, d = a.clickObject);
        if (d) {
            c = a.u(d);
            for(b = a.H(d); d && !b && "BODY" != c;)if (d = d.parentElement ? d.parentElement : d.parentNode) c = a.u(d), b = a.H(d);
            b && "BODY" != c || (d = 0);
            if (d) {
                var p = d.onclick ? "" + d.onclick : "";
                if (0 <= p.indexOf(".tl(") || 0 <= p.indexOf(".trackLink(")) d = 0;
            }
        } else a.ha = 1;
        !e && d && (e = a.va(d));
        e && !a.linkLeaveQueryString && (g = e.indexOf("?"), 0 <= g && (e = e.substring(0, g)));
        if (!f && e) {
            var n = 0, r = 0, q;
            if (a.trackDownloadLinks && a.linkDownloadFileTypes) for(p = e.toLowerCase(), g = p.indexOf("?"), m = p.indexOf("#"), 0 <= g ? 0 <= m && m < g && (g = m) : g = m, 0 <= g && (p = p.substring(0, g)), g = a.linkDownloadFileTypes.toLowerCase().split(","), m = 0; m < g.length; m++)(q = g[m]) && p.substring(p.length - (q.length + 1)) == "." + q && (f = "d");
            if (a.trackExternalLinks && !f && (p = e.toLowerCase(), a.ya(p) && (a.linkInternalFilters || (a.linkInternalFilters = k.location.hostname), g = 0, a.linkExternalFilters ? (g = a.linkExternalFilters.toLowerCase().split(","), n = 1) : a.linkInternalFilters && (g = a.linkInternalFilters.toLowerCase().split(",")), g))) {
                for(m = 0; m < g.length; m++)q = g[m], 0 <= p.indexOf(q) && (r = 1);
                r ? n && (f = "e") : n || (f = "e");
            }
        }
        a.linkObject = d;
        a.linkURL = e;
        a.linkType = f;
        if (a.trackClickMap || a.trackInlineStats) a.e = "", d && (f = a.pageName, e = 1, d = d.sourceIndex, f || (f = a.pageURL, e = 0), k.s_objectID && (b.id = k.s_objectID, d = b.type = 1), f && b && b.id && c && (a.e = "&pid=" + a.escape(f.substring(0, 255)) + (e ? "&pidt=" + e : "") + "&oid=" + a.escape(b.id.substring(0, 100)) + (b.type ? "&oidt=" + b.type : "") + "&ot=" + c + (d ? "&oi=" + d : "")));
    };
    a.jb = function() {
        var c = a.ha, b = a.linkType, d = a.linkURL, f = a.linkName;
        b && (d || f) && (b = b.toLowerCase(), "d" != b && "e" != b && (b = "o"), a.pe = "lnk_" + b, a.pev1 = d ? a.escape(d) : "", a.pev2 = f ? a.escape(f) : "", c = 1);
        a.abort && (c = 0);
        if (a.trackClickMap || a.trackInlineStats) {
            var b = {}, d = 0, e = a.cookieRead("s_sq"), g = e ? e.split("&") : 0, m, p, k, e = 0;
            if (g) for(m = 0; m < g.length; m++)p = g[m].split("="), f = a.unescape(p[0]).split(","), p = a.unescape(p[1]), b[p] = f;
            f = a.account.split(",");
            if (c || a.e) {
                c && !a.e && (e = 1);
                for(p in b)if (!Object.prototype[p]) for(m = 0; m < f.length; m++)for(e && (k = b[p].join(","), k == a.account && (a.e += ("&" != p.charAt(0) ? "&" : "") + p, b[p] = [], d = 1)), g = 0; g < b[p].length; g++)k = b[p][g], k == f[m] && (e && (a.e += "&u=" + a.escape(k) + ("&" != p.charAt(0) ? "&" : "") + p + "&u=0"), b[p].splice(g, 1), d = 1);
                c || (d = 1);
                if (d) {
                    e = "";
                    m = 2;
                    !c && a.e && (e = a.escape(f.join(",")) + "=" + a.escape(a.e), m = 1);
                    for(p in b)!Object.prototype[p] && 0 < m && 0 < b[p].length && (e += (e ? "&" : "") + a.escape(b[p].join(",")) + "=" + a.escape(p), m--);
                    a.cookieWrite("s_sq", e);
                }
            }
        }
        return c;
    };
    a.kb = function() {
        if (!a.wb) {
            var c = new Date, b = r.location, d, f, e = f = d = "", g = "", m = "", k = "1.2", n = a.cookieWrite("s_cc", "true", 0) ? "Y" : "N", q = "", s = "";
            if (c.setUTCDate && (k = "1.3", 0..toPrecision && (k = "1.5", c = [], c.forEach))) {
                k = "1.6";
                f = 0;
                d = {};
                try {
                    f = new Iterator(d), f.next && (k = "1.7", c.reduce && (k = "1.8", k.trim && (k = "1.8.1", Date.parse && (k = "1.8.2", Object.create && (k = "1.8.5")))));
                } catch (t) {}
            }
            d = screen.width + "x" + screen.height;
            e = navigator.javaEnabled() ? "Y" : "N";
            f = screen.pixelDepth ? screen.pixelDepth : screen.colorDepth;
            g = a.w.innerWidth ? a.w.innerWidth : a.d.documentElement.offsetWidth;
            m = a.w.innerHeight ? a.w.innerHeight : a.d.documentElement.offsetHeight;
            try {
                a.b.addBehavior("#default#homePage"), q = a.b.Bb(b) ? "Y" : "N";
            } catch (u) {}
            try {
                a.b.addBehavior("#default#clientCaps"), s = a.b.connectionType;
            } catch (x) {}
            a.resolution = d;
            a.colorDepth = f;
            a.javascriptVersion = k;
            a.javaEnabled = e;
            a.cookiesEnabled = n;
            a.browserWidth = g;
            a.browserHeight = m;
            a.connectionType = s;
            a.homepage = q;
            a.wb = 1;
        }
    };
    a.L = {};
    a.loadModule = function(c, b) {
        var d = a.L[c];
        if (!d) {
            d = k["AppMeasurement_Module_" + c] ? new k["AppMeasurement_Module_" + c](a) : {};
            a.L[c] = a[c] = d;
            d.Oa = function() {
                return d.Sa;
            };
            d.Ta = function(b) {
                if (d.Sa = b) a[c + "_onLoad"] = b, a.ba(c + "_onLoad", [
                    a,
                    d
                ], 1) || b(a, d);
            };
            try {
                Object.defineProperty ? Object.defineProperty(d, "onLoad", {
                    get: d.Oa,
                    set: d.Ta
                }) : d._olc = 1;
            } catch (f) {
                d._olc = 1;
            }
        }
        b && (a[c + "_onLoad"] = b, a.ba(c + "_onLoad", [
            a,
            d
        ], 1) || b(a, d));
    };
    a.l = function(c) {
        var b, d;
        for(b in a.L)if (!Object.prototype[b] && (d = a.L[b]) && (d._olc && d.onLoad && (d._olc = 0, d.onLoad(a, d)), d[c] && d[c]())) return 1;
        return 0;
    };
    a.mb = function() {
        var c = Math.floor(1E13 * Math.random()), b = a.visitorSampling, d = a.visitorSamplingGroup, d = "s_vsn_" + (a.visitorNamespace ? a.visitorNamespace : a.account) + (d ? "_" + d : ""), f = a.cookieRead(d);
        if (b) {
            f && (f = parseInt(f));
            if (!f) {
                if (!a.cookieWrite(d, c)) return 0;
                f = c;
            }
            if (f % 1E4 > v) return 0;
        }
        return 1;
    };
    a.M = function(c, b) {
        var d, f, e, g, m, k;
        for(d = 0; 2 > d; d++)for(f = 0 < d ? a.oa : a.c, e = 0; e < f.length; e++)if (g = f[e], (m = c[g]) || c["!" + g]) {
            if (!b && ("contextData" == g || "retrieveLightData" == g) && a[g]) for(k in a[g])m[k] || (m[k] = a[g][k]);
            a[g] = m;
        }
    };
    a.Ha = function(c, b) {
        var d, f, e, g;
        for(d = 0; 2 > d; d++)for(f = 0 < d ? a.oa : a.c, e = 0; e < f.length; e++)g = f[e], c[g] = a[g], b || c[g] || (c["!" + g] = 1);
    };
    a.eb = function(a) {
        var b, d, f, e, g, m = 0, k, n = "", q = "";
        if (a && 255 < a.length && (b = "" + a, d = b.indexOf("?"), 0 < d && (k = b.substring(d + 1), b = b.substring(0, d), e = b.toLowerCase(), f = 0, "http://" == e.substring(0, 7) ? f += 7 : "https://" == e.substring(0, 8) && (f += 8), d = e.indexOf("/", f), 0 < d && (e = e.substring(f, d), g = b.substring(d), b = b.substring(0, d), 0 <= e.indexOf("google") ? m = ",q,ie,start,search_key,word,kw,cd," : 0 <= e.indexOf("yahoo.co") && (m = ",p,ei,"), m && k)))) {
            if ((a = k.split("&")) && 1 < a.length) {
                for(f = 0; f < a.length; f++)e = a[f], d = e.indexOf("="), 0 < d && 0 <= m.indexOf("," + e.substring(0, d) + ",") ? n += (n ? "&" : "") + e : q += (q ? "&" : "") + e;
                n && q ? k = n + "&" + q : q = "";
            }
            d = 253 - (k.length - q.length) - b.length;
            a = b + (0 < d ? g.substring(0, d) : "") + "?" + k;
        }
        return a;
    };
    a.Na = function(c) {
        var b = a.d.visibilityState, d = [
            "webkitvisibilitychange",
            "visibilitychange"
        ];
        b || (b = a.d.webkitVisibilityState);
        if (b && "prerender" == b) {
            if (c) for(b = 0; b < d.length; b++)a.d.addEventListener(d[b], function() {
                var b = a.d.visibilityState;
                b || (b = a.d.webkitVisibilityState);
                "visible" == b && c();
            });
            return !1;
        }
        return !0;
    };
    a.Y = !1;
    a.D = !1;
    a.Ua = function() {
        a.D = !0;
        a.i();
    };
    a.W = !1;
    a.Q = !1;
    a.Ra = function(c) {
        a.marketingCloudVisitorID = c;
        a.Q = !0;
        a.i();
    };
    a.T = !1;
    a.N = !1;
    a.Ja = function(c) {
        a.analyticsVisitorID = c;
        a.N = !0;
        a.i();
    };
    a.V = !1;
    a.P = !1;
    a.La = function(c) {
        a.audienceManagerLocationHint = c;
        a.P = !0;
        a.i();
    };
    a.U = !1;
    a.O = !1;
    a.Ka = function(c) {
        a.audienceManagerBlob = c;
        a.O = !0;
        a.i();
    };
    a.Ma = function(c) {
        a.maxDelay || (a.maxDelay = 250);
        return a.l("_d") ? (c && setTimeout(function() {
            c();
        }, a.maxDelay), !1) : !0;
    };
    a.X = !1;
    a.C = !1;
    a.na = function() {
        a.C = !0;
        a.i();
    };
    a.isReadyToTrack = function() {
        var c = !0, b = a.visitor;
        a.Y || a.D || (a.Na(a.Ua) ? a.D = !0 : a.Y = !0);
        if (a.Y && !a.D) return !1;
        b && b.isAllowed() && (a.W || a.marketingCloudVisitorID || !b.getMarketingCloudVisitorID || (a.W = !0, a.marketingCloudVisitorID = b.getMarketingCloudVisitorID([
            a,
            a.Ra
        ]), a.marketingCloudVisitorID && (a.Q = !0)), a.T || a.analyticsVisitorID || !b.getAnalyticsVisitorID || (a.T = !0, a.analyticsVisitorID = b.getAnalyticsVisitorID([
            a,
            a.Ja
        ]), a.analyticsVisitorID && (a.N = !0)), a.V || a.audienceManagerLocationHint || !b.getAudienceManagerLocationHint || (a.V = !0, a.audienceManagerLocationHint = b.getAudienceManagerLocationHint([
            a,
            a.La
        ]), a.audienceManagerLocationHint && (a.P = !0)), a.U || a.audienceManagerBlob || !b.getAudienceManagerBlob || (a.U = !0, a.audienceManagerBlob = b.getAudienceManagerBlob([
            a,
            a.Ka
        ]), a.audienceManagerBlob && (a.O = !0)), a.W && !a.Q && !a.marketingCloudVisitorID || a.T && !a.N && !a.analyticsVisitorID || a.V && !a.P && !a.audienceManagerLocationHint || a.U && !a.O && !a.audienceManagerBlob) && (c = !1);
        a.X || a.C || (a.Ma(a.na) ? a.C = !0 : a.X = !0);
        a.X && !a.C && (c = !1);
        return c;
    };
    a.k = q;
    a.o = 0;
    a.callbackWhenReadyToTrack = function(c, b, d) {
        var f;
        f = {};
        f.Ya = c;
        f.Xa = b;
        f.Va = d;
        a.k == q && (a.k = []);
        a.k.push(f);
        0 == a.o && (a.o = setInterval(a.i, 100));
    };
    a.i = function() {
        var c;
        if (a.isReadyToTrack() && (a.o && (clearInterval(a.o), a.o = 0), a.k != q)) for(; 0 < a.k.length;)c = a.k.shift(), c.Xa.apply(c.Ya, c.Va);
    };
    a.Pa = function(c) {
        var b, d, f = q, e = q;
        if (!a.isReadyToTrack()) {
            b = [];
            if (c != q) for(d in f = {}, c)f[d] = c[d];
            e = {};
            a.Ha(e, !0);
            b.push(f);
            b.push(e);
            a.callbackWhenReadyToTrack(a, a.track, b);
            return !0;
        }
        return !1;
    };
    a.hb = function() {
        var c = a.cookieRead("s_fid"), b = "", d = "", f;
        f = 8;
        var e = 4;
        if (!c || 0 > c.indexOf("-")) {
            for(c = 0; 16 > c; c++)f = Math.floor(Math.random() * f), b += "0123456789ABCDEF".substring(f, f + 1), f = Math.floor(Math.random() * e), d += "0123456789ABCDEF".substring(f, f + 1), f = e = 16;
            c = b + "-" + d;
        }
        a.cookieWrite("s_fid", c, 1) || (c = 0);
        return c;
    };
    a.t = a.track = function(c, b) {
        var d, f = new Date, e = "s" + Math.floor(f.getTime() / 108E5) % 10 + Math.floor(1E13 * Math.random()), g = f.getYear(), g = "t=" + a.escape(f.getDate() + "/" + f.getMonth() + "/" + (1900 > g ? g + 1900 : g) + " " + f.getHours() + ":" + f.getMinutes() + ":" + f.getSeconds() + " " + f.getDay() + " " + f.getTimezoneOffset());
        a.visitor && (a.visitor.fb && (a.authState = a.visitor.fb()), !a.supplementalDataID && a.visitor.getSupplementalDataID && (a.supplementalDataID = a.visitor.getSupplementalDataID("AppMeasurement:" + a._in, a.expectSupplementalData ? !1 : !0)));
        a.l("_s");
        a.Pa(c) || (b && a.M(b), c && (d = {}, a.Ha(d, 0), a.M(c)), a.mb() && (a.analyticsVisitorID || a.marketingCloudVisitorID || (a.fid = a.hb()), a.rb(), a.usePlugins && a.doPlugins && a.doPlugins(a), a.account && (a.abort || (a.trackOffline && !a.timestamp && (a.timestamp = Math.floor(f.getTime() / 1E3)), f = k.location, a.pageURL || (a.pageURL = f.href ? f.href : f), a.referrer || a.Ia || (a.referrer = r.document.referrer), a.Ia = 1, a.referrer = a.eb(a.referrer), a.l("_g")), a.jb() && !a.abort && (a.kb(), g += a.ib(), a.qb(e, g), a.l("_t"), a.referrer = ""))), c && a.M(d, 1));
        a.abort = a.supplementalDataID = a.timestamp = a.pageURLRest = a.linkObject = a.clickObject = a.linkURL = a.linkName = a.linkType = k.s_objectID = a.pe = a.pev1 = a.pev2 = a.pev3 = a.e = a.lightProfileID = 0;
    };
    a.tl = a.trackLink = function(c, b, d, f, e) {
        a.linkObject = c;
        a.linkType = b;
        a.linkName = d;
        e && (a.j = c, a.q = e);
        return a.track(f);
    };
    a.trackLight = function(c, b, d, f) {
        a.lightProfileID = c;
        a.lightStoreForSeconds = b;
        a.lightIncrementBy = d;
        return a.track(f);
    };
    a.clearVars = function() {
        var c, b;
        for(c = 0; c < a.c.length; c++)if (b = a.c[c], "prop" == b.substring(0, 4) || "eVar" == b.substring(0, 4) || "hier" == b.substring(0, 4) || "list" == b.substring(0, 4) || "channel" == b || "events" == b || "eventList" == b || "products" == b || "productList" == b || "purchaseID" == b || "transactionID" == b || "state" == b || "zip" == b || "campaign" == b) a[b] = void 0;
    };
    a.tagContainerMarker = "";
    a.qb = function(c, b) {
        var d, f = a.trackingServer;
        d = "";
        var e = a.dc, g = "sc.", k = a.visitorNamespace;
        f ? a.trackingServerSecure && a.ssl && (f = a.trackingServerSecure) : (k || (k = a.account, f = k.indexOf(","), 0 <= f && (k = k.substring(0, f)), k = k.replace(/[^A-Za-z0-9]/g, "")), d || (d = "2o7.net"), e = e ? ("" + e).toLowerCase() : "d1", "2o7.net" == d && ("d1" == e ? e = "112" : "d2" == e && (e = "122"), g = ""), f = k + "." + e + "." + g + d);
        d = a.ssl ? "https://" : "http://";
        e = a.AudienceManagement && a.AudienceManagement.isReady();
        d += f + "/b/ss/" + a.account + "/" + (a.mobile ? "5." : "") + (e ? "10" : "1") + "/JS-" + a.version + (a.vb ? "T" : "") + (a.tagContainerMarker ? "-" + a.tagContainerMarker : "") + "/" + c + "?AQB=1&ndh=1&pf=1&" + (e ? "callback=s_c_il[" + a._in + "].AudienceManagement.passData&" : "") + b + "&AQE=1";
        a.bb(d);
        a.da();
    };
    a.bb = function(c) {
        a.g || a.lb();
        a.g.push(c);
        a.fa = a.r();
        a.Fa();
    };
    a.lb = function() {
        a.g = a.nb();
        a.g || (a.g = []);
    };
    a.nb = function() {
        var c, b;
        if (a.ka()) {
            try {
                (b = k.localStorage.getItem(a.ia())) && (c = k.JSON.parse(b));
            } catch (d) {}
            return c;
        }
    };
    a.ka = function() {
        var c = !0;
        a.trackOffline && a.offlineFilename && k.localStorage && k.JSON || (c = !1);
        return c;
    };
    a.wa = function() {
        var c = 0;
        a.g && (c = a.g.length);
        a.v && c++;
        return c;
    };
    a.da = function() {
        if (!a.v) {
            if (a.xa = q, a.ja) a.fa > a.J && a.Da(a.g), a.ma(500);
            else {
                var c = a.Wa();
                if (0 < c) a.ma(c);
                else if (c = a.ua()) a.v = 1, a.pb(c), a.tb(c);
            }
        }
    };
    a.ma = function(c) {
        a.xa || (c || (c = 0), a.xa = setTimeout(a.da, c));
    };
    a.Wa = function() {
        var c;
        if (!a.trackOffline || 0 >= a.offlineThrottleDelay) return 0;
        c = a.r() - a.Ca;
        return a.offlineThrottleDelay < c ? 0 : a.offlineThrottleDelay - c;
    };
    a.ua = function() {
        if (0 < a.g.length) return a.g.shift();
    };
    a.pb = function(c) {
        if (a.debugTracking) {
            var b = "AppMeasurement Debug: " + c;
            c = c.split("&");
            var d;
            for(d = 0; d < c.length; d++)b += "\n	" + a.unescape(c[d]);
            a.ob(b);
        }
    };
    a.Qa = function() {
        return a.marketingCloudVisitorID || a.analyticsVisitorID;
    };
    a.S = !1;
    var s;
    try {
        s = JSON.parse('{"x":"y"}');
    } catch (x) {
        s = null;
    }
    s && "y" == s.x ? (a.S = !0, a.R = function(a) {
        return JSON.parse(a);
    }) : k.$ && k.$.parseJSON ? (a.R = function(a) {
        return k.$.parseJSON(a);
    }, a.S = !0) : a.R = function() {
        return null;
    };
    a.tb = function(c) {
        var b, d, f;
        a.Qa() && 2047 < c.length && ("undefined" != typeof XMLHttpRequest && (b = new XMLHttpRequest, "withCredentials" in b ? d = 1 : b = 0), b || "undefined" == typeof XDomainRequest || (b = new XDomainRequest, d = 2), b && a.AudienceManagement && a.AudienceManagement.isReady() && (a.S ? b.pa = !0 : b = 0));
        !b && a.Ga && (c = c.substring(0, 2047));
        !b && a.d.createElement && a.AudienceManagement && a.AudienceManagement.isReady() && (b = a.d.createElement("SCRIPT")) && "async" in b && ((f = (f = a.d.getElementsByTagName("HEAD")) && f[0] ? f[0] : a.d.body) ? (b.type = "text/javascript", b.setAttribute("async", "async"), d = 3) : b = 0);
        b || (b = new Image, b.alt = "");
        b.ra = function() {
            try {
                a.la && (clearTimeout(a.la), a.la = 0), b.timeout && (clearTimeout(b.timeout), b.timeout = 0);
            } catch (c) {}
        };
        b.onload = b.ub = function() {
            b.ra();
            a.ab();
            a.Z();
            a.v = 0;
            a.da();
            if (b.pa) {
                b.pa = !1;
                try {
                    var c = a.R(b.responseText);
                    AudienceManagement.passData(c);
                } catch (d) {}
            }
        };
        b.onabort = b.onerror = b.cb = function() {
            b.ra();
            (a.trackOffline || a.ja) && a.v && a.g.unshift(a.$a);
            a.v = 0;
            a.fa > a.J && a.Da(a.g);
            a.Z();
            a.ma(500);
        };
        b.onreadystatechange = function() {
            4 == b.readyState && (200 == b.status ? b.ub() : b.cb());
        };
        a.Ca = a.r();
        if (1 == d || 2 == d) {
            var e = c.indexOf("?");
            f = c.substring(0, e);
            e = c.substring(e + 1);
            e = e.replace(/&callback=[a-zA-Z0-9_.\[\]]+/, "");
            1 == d ? (b.open("POST", f, !0), b.send(e)) : 2 == d && (b.open("POST", f), b.send(e));
        } else if (b.src = c, 3 == d) {
            if (a.Aa) try {
                f.removeChild(a.Aa);
            } catch (g) {}
            f.firstChild ? f.insertBefore(b, f.firstChild) : f.appendChild(b);
            a.Aa = a.Za;
        }
        b.abort && (a.la = setTimeout(b.abort, 5E3));
        a.$a = c;
        a.Za = k["s_i_" + a.replace(a.account, ",", "_")] = b;
        if (a.useForcedLinkTracking && a.F || a.q) a.forcedLinkTrackingTimeout || (a.forcedLinkTrackingTimeout = 250), a.aa = setTimeout(a.Z, a.forcedLinkTrackingTimeout);
    };
    a.ab = function() {
        if (a.ka() && !(a.Ba > a.J)) try {
            k.localStorage.removeItem(a.ia()), a.Ba = a.r();
        } catch (c) {}
    };
    a.Da = function(c) {
        if (a.ka()) {
            a.Fa();
            try {
                k.localStorage.setItem(a.ia(), k.JSON.stringify(c)), a.J = a.r();
            } catch (b) {}
        }
    };
    a.Fa = function() {
        if (a.trackOffline) {
            if (!a.offlineLimit || 0 >= a.offlineLimit) a.offlineLimit = 10;
            for(; a.g.length > a.offlineLimit;)a.ua();
        }
    };
    a.forceOffline = function() {
        a.ja = !0;
    };
    a.forceOnline = function() {
        a.ja = !1;
    };
    a.ia = function() {
        return a.offlineFilename + "-" + a.visitorNamespace + a.account;
    };
    a.r = function() {
        return (new Date).getTime();
    };
    a.ya = function(a) {
        a = a.toLowerCase();
        return 0 != a.indexOf("#") && 0 != a.indexOf("about:") && 0 != a.indexOf("opera:") && 0 != a.indexOf("javascript:") ? !0 : !1;
    };
    a.setTagContainer = function(c) {
        var b, d, f;
        a.vb = c;
        for(b = 0; b < a._il.length; b++)if ((d = a._il[b]) && "s_l" == d._c && d.tagContainerName == c) {
            a.M(d);
            if (d.lmq) for(b = 0; b < d.lmq.length; b++)f = d.lmq[b], a.loadModule(f.n);
            if (d.ml) {
                for(f in d.ml)if (a[f]) for(b in c = a[f], f = d.ml[f], f)!Object.prototype[b] && ("function" != typeof f[b] || 0 > ("" + f[b]).indexOf("s_c_il")) && (c[b] = f[b]);
            }
            if (d.mmq) for(b = 0; b < d.mmq.length; b++)f = d.mmq[b], a[f.m] && (c = a[f.m], c[f.f] && "function" == typeof c[f.f] && (f.a ? c[f.f].apply(c, f.a) : c[f.f].apply(c)));
            if (d.tq) for(b = 0; b < d.tq.length; b++)a.track(d.tq[b]);
            d.s = a;
            break;
        }
    };
    a.Util = {
        urlEncode: a.escape,
        urlDecode: a.unescape,
        cookieRead: a.cookieRead,
        cookieWrite: a.cookieWrite,
        getQueryParam: function(c, b, d) {
            var f;
            b || (b = a.pageURL ? a.pageURL : k.location);
            d || (d = "&");
            return c && b && (b = "" + b, f = b.indexOf("?"), 0 <= f && (b = d + b.substring(f + 1) + d, f = b.indexOf(d + c + "="), 0 <= f && (b = b.substring(f + d.length + c.length + 1), f = b.indexOf(d), 0 <= f && (b = b.substring(0, f)), 0 < b.length))) ? a.unescape(b) : "";
        }
    };
    a.A = "supplementalDataID timestamp dynamicVariablePrefix visitorID marketingCloudVisitorID analyticsVisitorID audienceManagerLocationHint authState fid vmk visitorMigrationKey visitorMigrationServer visitorMigrationServerSecure charSet visitorNamespace cookieDomainPeriods fpCookieDomainPeriods cookieLifetime pageName pageURL referrer contextData currencyCode lightProfileID lightStoreForSeconds lightIncrementBy retrieveLightProfiles deleteLightProfiles retrieveLightData pe pev1 pev2 pev3 pageURLRest".split(" ");
    a.c = a.A.concat("purchaseID variableProvider channel server pageType transactionID campaign state zip events events2 products audienceManagerBlob tnt".split(" "));
    a.ga = "timestamp charSet visitorNamespace cookieDomainPeriods cookieLifetime contextData lightProfileID lightStoreForSeconds lightIncrementBy".split(" ");
    a.K = a.ga.slice(0);
    a.oa = "account allAccounts debugTracking visitor trackOffline offlineLimit offlineThrottleDelay offlineFilename usePlugins doPlugins configURL visitorSampling visitorSamplingGroup linkObject clickObject linkURL linkName linkType trackDownloadLinks trackExternalLinks trackClickMap trackInlineStats linkLeaveQueryString linkTrackVars linkTrackEvents linkDownloadFileTypes linkExternalFilters linkInternalFilters useForcedLinkTracking forcedLinkTrackingTimeout trackingServer trackingServerSecure ssl abort mobile dc lightTrackVars maxDelay expectSupplementalData AudienceManagement".split(" ");
    for(n = 0; 250 >= n; n++)76 > n && (a.c.push("prop" + n), a.K.push("prop" + n)), a.c.push("eVar" + n), a.K.push("eVar" + n), 6 > n && a.c.push("hier" + n), 4 > n && a.c.push("list" + n);
    n = "latitude longitude resolution colorDepth javascriptVersion javaEnabled cookiesEnabled browserWidth browserHeight connectionType homepage".split(" ");
    a.c = a.c.concat(n);
    a.A = a.A.concat(n);
    a.ssl = 0 <= k.location.protocol.toLowerCase().indexOf("https");
    a.charSet = "UTF-8";
    a.contextData = {};
    a.offlineThrottleDelay = 0;
    a.offlineFilename = "AppMeasurement.offline";
    a.Ca = 0;
    a.fa = 0;
    a.J = 0;
    a.Ba = 0;
    a.linkDownloadFileTypes = "exe,zip,wav,mp3,mov,mpg,avi,wmv,pdf,doc,docx,xls,xlsx,ppt,pptx";
    a.w = k;
    a.d = k.document;
    try {
        if (a.Ga = !1, navigator) {
            var y = navigator.userAgent;
            if ("Microsoft Internet Explorer" == navigator.appName || 0 <= y.indexOf("MSIE ") || 0 <= y.indexOf("Trident/") && 0 <= y.indexOf("Windows NT 6")) a.Ga = !0;
        }
    } catch (z) {}
    a.Z = function() {
        a.aa && (k.clearTimeout(a.aa), a.aa = q);
        a.j && a.F && a.j.dispatchEvent(a.F);
        a.q && ("function" == typeof a.q ? a.q() : a.j && a.j.href && (a.d.location = a.j.href));
        a.j = a.F = a.q = 0;
    };
    a.Ea = function() {
        a.b = a.d.body;
        a.b ? (a.p = function(c) {
            var b, d, f, e, g;
            if (!(a.d && a.d.getElementById("cppXYctnr") || c && c["s_fe_" + a._in])) {
                if (a.qa) {
                    if (a.useForcedLinkTracking) a.b.removeEventListener("click", a.p, !1);
                    else {
                        a.b.removeEventListener("click", a.p, !0);
                        a.qa = a.useForcedLinkTracking = 0;
                        return;
                    }
                } else a.useForcedLinkTracking = 0;
                a.clickObject = c.srcElement ? c.srcElement : c.target;
                try {
                    if (!a.clickObject || a.I && a.I == a.clickObject || !(a.clickObject.tagName || a.clickObject.parentElement || a.clickObject.parentNode)) a.clickObject = 0;
                    else {
                        var m = a.I = a.clickObject;
                        a.ea && (clearTimeout(a.ea), a.ea = 0);
                        a.ea = setTimeout(function() {
                            a.I == m && (a.I = 0);
                        }, 1E4);
                        f = a.wa();
                        a.track();
                        if (f < a.wa() && a.useForcedLinkTracking && c.target) {
                            for(e = c.target; e && e != a.b && "A" != e.tagName.toUpperCase() && "AREA" != e.tagName.toUpperCase();)e = e.parentNode;
                            if (e && (g = e.href, a.ya(g) || (g = 0), d = e.target, c.target.dispatchEvent && g && (!d || "_self" == d || "_top" == d || "_parent" == d || k.name && d == k.name))) {
                                try {
                                    b = a.d.createEvent("MouseEvents");
                                } catch (n) {
                                    b = new k.MouseEvent;
                                }
                                if (b) {
                                    try {
                                        b.initMouseEvent("click", c.bubbles, c.cancelable, c.view, c.detail, c.screenX, c.screenY, c.clientX, c.clientY, c.ctrlKey, c.altKey, c.shiftKey, c.metaKey, c.button, c.relatedTarget);
                                    } catch (q) {
                                        b = 0;
                                    }
                                    b && (b["s_fe_" + a._in] = b.s_fe = 1, c.stopPropagation(), c.stopImmediatePropagation && c.stopImmediatePropagation(), c.preventDefault(), a.j = c.target, a.F = b);
                                }
                            }
                        }
                    }
                } catch (r) {
                    a.clickObject = 0;
                }
            }
        }, a.b && a.b.attachEvent ? a.b.attachEvent("onclick", a.p) : a.b && a.b.addEventListener && (navigator && (0 <= navigator.userAgent.indexOf("WebKit") && a.d.createEvent || 0 <= navigator.userAgent.indexOf("Firefox/2") && k.MouseEvent) && (a.qa = 1, a.useForcedLinkTracking = 1, a.b.addEventListener("click", a.p, !0)), a.b.addEventListener("click", a.p, !1))) : setTimeout(a.Ea, 30);
    };
    a.Ea();
}
function s_gi(a) {
    var k, q = window.s_c_il, r, n, t = a.split(","), u, s, x = 0;
    if (q) for(r = 0; !x && r < q.length;){
        k = q[r];
        if ("s_c" == k._c && (k.account || k.oun)) {
            if (k.account && k.account == a) x = 1;
            else for(n = k.account ? k.account : k.oun, n = k.allAccounts ? k.allAccounts : n.split(","), u = 0; u < t.length; u++)for(s = 0; s < n.length; s++)t[u] == n[s] && (x = 1);
        }
        r++;
    }
    x || (k = new AppMeasurement);
    k.setAccount ? k.setAccount(a) : k.sa && k.sa(a);
    return k;
}
AppMeasurement.getInstance = s_gi;
window.s_objectID || (window.s_objectID = 0);
function s_pgicq() {
    var a = window, k = a.s_giq, q, r, n;
    if (k) for(q = 0; q < k.length; q++)r = k[q], n = s_gi(r.oun), n.setAccount(r.un), n.setTagContainer(r.tagContainerName);
    a.s_giq = 0;
}
s_pgicq();
window.s_gi = s_gi;
window.AppMeasurement = AppMeasurement;
// ADOBE AUDIENCE MANAGER
"function" !== typeof window.DIL && (window.DIL = function(a, d) {
    var e = [], b, h1;
    a !== Object(a) && (a = {});
    var f, k, q, n, r, m, y, F, s, B, M, C, D, G, A;
    f = a.partner;
    k = a.containerNSID;
    q = !!a.disableDestinationPublishingIframe;
    n = a.iframeAkamaiHTTPS;
    r = a.mappings;
    m = a.uuidCookie;
    y = !0 === a.enableErrorReporting;
    F = a.visitorService;
    s = a.declaredId;
    B = !0 === a.removeFinishedScriptsAndCallbacks;
    M = !0 === a.delayAllUntilWindowLoad;
    C = !0 === a.disableIDSyncs;
    D = "undefined" === typeof a.secureDataCollection || !0 === a.secureDataCollection;
    G = !0 === a.useCORSOnly;
    A = "boolean" === typeof a.isCoopSafe ? a.isCoopSafe : null;
    var N, O, J, H, P, Q, R, S;
    N = !0 === a.disableScriptAttachment;
    O = !0 === a.disableDefaultRequest;
    J = a.afterResultForDefaultRequest;
    H = a.dpIframeSrc;
    P = !0 === a.testCORS;
    Q = !0 === a.useJSONPOnly;
    R = a.visitorConstructor;
    S = !0 === a.disableCORS;
    y && DIL.errorModule.activate();
    var U = !0 === window._dil_unit_tests;
    (b = d) && e.push(b + "");
    if (!f || "string" !== typeof f) return b = "DIL partner is invalid or not specified in initConfig", DIL.errorModule.handleError({
        name: "error",
        message: b,
        filename: "dil.js"
    }), Error(b);
    b = "DIL containerNSID is invalid or not specified in initConfig, setting to default of 0";
    if (k || "number" === typeof k) k = parseInt(k, 10), !isNaN(k) && 0 <= k && (b = "");
    b && (k = 0, e.push(b), b = "");
    h1 = DIL.getDil(f, k);
    if (h1 instanceof DIL && h1.api.getPartner() === f && h1.api.getContainerNSID() === k) return h1;
    if (this instanceof DIL) DIL.registerDil(this, f, k);
    else return new DIL(a, "DIL was not instantiated with the 'new' operator, returning a valid instance with partner = " + f + " and containerNSID = " + k);
    var w = {
        IS_HTTPS: D || "https:" === document.location.protocol,
        POST_MESSAGE_ENABLED: !!window.postMessage,
        MILLIS_PER_DAY: 864E5,
        DIL_COOKIE_NAME: "AAMC_" + encodeURIComponent(f) + "_" + k,
        FIRST_PARTY_SYNCS: "AMSYNCS",
        FIRST_PARTY_SYNCS_ON_PAGE: "AMSYNCSOP",
        HAS_JSON_STRINGIFY: window.JSON === Object(window.JSON) && "function" === typeof window.JSON.stringify,
        REGION: "REGION",
        SIX_MONTHS_IN_MINUTES: 259200
    }, K = {
        stuffed: {}
    }, v1 = {}, p = {
        firingQueue: [],
        fired: [],
        firing: !1,
        sent: [],
        errored: [],
        reservedKeys: {
            sids: !0,
            pdata: !0,
            logdata: !0,
            callback: !0,
            postCallbackFn: !0,
            useImageRequest: !0
        },
        callbackPrefix: "demdexRequestCallback",
        firstRequestHasFired: !1,
        useJSONP: !0,
        abortRequests: !1,
        num_of_jsonp_responses: 0,
        num_of_jsonp_errors: 0,
        num_of_cors_responses: 0,
        num_of_cors_errors: 0,
        corsErrorSources: [],
        num_of_img_responses: 0,
        num_of_img_errors: 0,
        toRemove: [],
        removed: [],
        readyToRemove: !1,
        platformParams: {
            d_nsid: k + "",
            d_rtbd: "json",
            d_jsonv: DIL.jsonVersion + "",
            d_dst: "1"
        },
        nonModStatsParams: {
            d_rtbd: !0,
            d_dst: !0,
            d_cts: !0,
            d_rs: !0
        },
        modStatsParams: null,
        adms: {
            TIME_TO_CATCH_ALL_REQUESTS_RELEASE: 2E3,
            calledBack: !1,
            mid: null,
            noVisitorAPI: !1,
            VisitorAPI: null,
            instance: null,
            releaseType: "no VisitorAPI",
            isOptedOut: !0,
            isOptedOutCallbackCalled: !1,
            admsProcessingStarted: !1,
            process: function(c) {
                try {
                    if (!this.admsProcessingStarted) {
                        this.admsProcessingStarted = !0;
                        var l1 = this, u, g, a, b;
                        if ("function" === typeof c && "function" === typeof c.getInstance) {
                            if (F === Object(F) && (u = F.namespace) && "string" === typeof u) g = c.getInstance(u, {
                                idSyncContainerID: k
                            });
                            else {
                                this.releaseType = "no namespace";
                                this.releaseRequests();
                                return;
                            }
                            if (g === Object(g) && g instanceof c && "function" === typeof g.isAllowed && "function" === typeof g.getMarketingCloudVisitorID && "function" === typeof g.getCustomerIDs && "function" === typeof g.isOptedOut) {
                                this.VisitorAPI = c;
                                if (!g.isAllowed()) {
                                    this.releaseType = "VisitorAPI not allowed";
                                    this.releaseRequests();
                                    return;
                                }
                                this.instance = g;
                                a = function(c) {
                                    "VisitorAPI" !== l1.releaseType && (l1.mid = c, l1.releaseType = "VisitorAPI", l1.releaseRequests());
                                };
                                b = g.getMarketingCloudVisitorID(a);
                                if ("string" === typeof b && b.length) {
                                    a(b);
                                    return;
                                }
                                setTimeout(function() {
                                    "VisitorAPI" !== l1.releaseType && (l1.releaseType = "timeout", l1.releaseRequests());
                                }, this.getLoadTimeout());
                                return;
                            }
                            this.releaseType = "invalid instance";
                        } else this.noVisitorAPI = !0;
                        this.releaseRequests();
                    }
                } catch (e) {
                    this.releaseRequests();
                }
            },
            releaseRequests: function() {
                this.calledBack = !0;
                p.registerRequest();
            },
            getMarketingCloudVisitorID: function() {
                return this.instance ? this.instance.getMarketingCloudVisitorID() : null;
            },
            getMIDQueryString: function() {
                var c = x.isPopulatedString, l1 = this.getMarketingCloudVisitorID();
                c(this.mid) && this.mid === l1 || (this.mid = l1);
                return c(this.mid) ? "d_mid=" + this.mid + "&" : "";
            },
            getCustomerIDs: function() {
                return this.instance ? this.instance.getCustomerIDs() : null;
            },
            getCustomerIDsQueryString: function(c) {
                if (c === Object(c)) {
                    var l1 = "", u = [], g = [], a, b;
                    for(a in c)c.hasOwnProperty(a) && (g[0] = a, b = c[a], b === Object(b) && (g[1] = b.id || "", g[2] = b.authState || 0, u.push(g), g = []));
                    if (g = u.length) for(c = 0; c < g; c++)l1 += "&d_cid_ic=" + t.encodeAndBuildRequest(u[c], "%01");
                    return l1;
                }
                return "";
            },
            getIsOptedOut: function() {
                this.instance ? this.instance.isOptedOut([
                    this,
                    this.isOptedOutCallback
                ], this.VisitorAPI.OptOut.GLOBAL, !0) : (this.isOptedOut = !1, this.isOptedOutCallbackCalled = !0);
            },
            isOptedOutCallback: function(c) {
                this.isOptedOut = c;
                this.isOptedOutCallbackCalled = !0;
                p.registerRequest();
            },
            getLoadTimeout: function() {
                var c = this.instance;
                if (c) {
                    if ("function" === typeof c.getLoadTimeout) return c.getLoadTimeout();
                    if ("undefined" !== typeof c.loadTimeout) return c.loadTimeout;
                }
                return this.TIME_TO_CATCH_ALL_REQUESTS_RELEASE;
            }
        },
        declaredId: {
            declaredId: {
                init: null,
                request: null
            },
            declaredIdCombos: {},
            setDeclaredId: function(c, l1) {
                var u = x.isPopulatedString, g = encodeURIComponent;
                if (c === Object(c) && u(l1)) {
                    var a = c.dpid, b = c.dpuuid, e = null;
                    if (u(a) && u(b)) {
                        e = g(a) + "$" + g(b);
                        if (!0 === this.declaredIdCombos[e]) return "setDeclaredId: combo exists for type '" + l1 + "'";
                        this.declaredIdCombos[e] = !0;
                        this.declaredId[l1] = {
                            dpid: a,
                            dpuuid: b
                        };
                        return "setDeclaredId: succeeded for type '" + l1 + "'";
                    }
                }
                return "setDeclaredId: failed for type '" + l1 + "'";
            },
            getDeclaredIdQueryString: function() {
                var c = this.declaredId.request, l1 = this.declaredId.init, a = encodeURIComponent, g = "";
                null !== c ? g = "&d_dpid=" + a(c.dpid) + "&d_dpuuid=" + a(c.dpuuid) : null !== l1 && (g = "&d_dpid=" + a(l1.dpid) + "&d_dpuuid=" + a(l1.dpuuid));
                return g;
            }
        },
        registerRequest: function(c) {
            var l1 = this.firingQueue;
            c === Object(c) && l1.push(c);
            this.firing || !l1.length || M && !DIL.windowLoaded || (this.adms.isOptedOutCallbackCalled || this.adms.getIsOptedOut(), this.adms.calledBack && !this.adms.isOptedOut && this.adms.isOptedOutCallbackCalled && (this.adms.isOptedOutCallbackCalled = !1, c = l1.shift(), c.src = c.src.replace(/demdex.net\/event\?d_nsid=/, "demdex.net/event?" + this.adms.getMIDQueryString() + "d_nsid="), x.isPopulatedString(c.corsPostData) && (c.corsPostData = c.corsPostData.replace(/^d_nsid=/, this.adms.getMIDQueryString() + "d_nsid=")), E.fireRequest(c), this.firstRequestHasFired || "script" !== c.tag && "cors" !== c.tag || (this.firstRequestHasFired = !0)));
        },
        processVisitorAPI: function() {
            this.adms.process(R || window.Visitor);
        },
        requestRemoval: function(c) {
            if (!B) return "removeFinishedScriptsAndCallbacks is not boolean true";
            var l1 = this.toRemove, a, g;
            c === Object(c) && (a = c.script, g = c.callbackName, (a === Object(a) && "SCRIPT" === a.nodeName || "no script created" === a) && "string" === typeof g && g.length && l1.push(c));
            if (this.readyToRemove && l1.length) {
                g = l1.shift();
                a = g.script;
                g = g.callbackName;
                "no script created" !== a ? (c = a.src, a.parentNode.removeChild(a)) : c = a;
                window[g] = null;
                try {
                    delete window[g];
                } catch (b) {}
                this.removed.push({
                    scriptSrc: c,
                    callbackName: g
                });
                DIL.variables.scriptsRemoved.push(c);
                DIL.variables.callbacksRemoved.push(g);
                return this.requestRemoval();
            }
            return "requestRemoval() processed";
        },
        getCoopQueryString: function() {
            var c = "";
            !0 === A ? c = "&d_coop_safe=1" : !1 === A && (c = "&d_coop_unsafe=1");
            return c;
        }
    };
    h1 = function() {
        var c = "http://fast.", l1 = "?d_nsid=" + k + "#" + encodeURIComponent(document.location.href);
        if ("string" === typeof H && H.length) return H + l1;
        w.IS_HTTPS && (c = !0 === n ? "https://fast." : "https://");
        return c + f + ".demdex.net/dest5.html" + l1;
    };
    var z = {
        THROTTLE_START: 3E4,
        MAX_SYNCS_LENGTH: 649,
        throttleTimerSet: !1,
        id: "destination_publishing_iframe_" + f + "_" + k,
        url: h1(),
        onPagePixels: [],
        iframeHost: null,
        getIframeHost: function(c) {
            if ("string" === typeof c) {
                var l1 = c.split("/");
                if (3 <= l1.length) return l1[0] + "//" + l1[2];
                e.push("getIframeHost: url is malformed: " + c);
                return c;
            }
        },
        iframe: null,
        iframeHasLoaded: !1,
        sendingMessages: !1,
        messages: [],
        messagesPosted: [],
        messagesReceived: [],
        messageSendingInterval: w.POST_MESSAGE_ENABLED ? null : 100,
        ibsDeleted: [],
        jsonForComparison: [],
        jsonDuplicates: [],
        jsonWaiting: [],
        jsonProcessed: [],
        canSetThirdPartyCookies: !0,
        receivedThirdPartyCookiesNotification: !1,
        newIframeCreated: null,
        iframeIdChanged: !1,
        originalIframeHasLoadedAlready: null,
        regionChanged: !1,
        timesRegionChanged: 0,
        attachIframe: function() {
            function c() {
                g = document.createElement("iframe");
                g.sandbox = "allow-scripts allow-same-origin";
                g.title = "Adobe ID Syncing iFrame";
                g.id = a.id;
                g.style.cssText = "display: none; width: 0; height: 0;";
                g.src = a.url;
                a.newIframeCreated = !0;
                l1();
                document.body.appendChild(g);
            }
            function l1() {
                t.addListener(g, "load", function() {
                    g.className = "aamIframeLoaded";
                    a.iframeHasLoaded = !0;
                    a.requestToProcess();
                });
            }
            var a = this, g = document.getElementById(this.id);
            g ? "IFRAME" !== g.nodeName ? (this.id += "_2", this.iframeIdChanged = !0, c()) : (this.newIframeCreated = !1, "aamIframeLoaded" !== g.className ? (this.originalIframeHasLoadedAlready = !1, l1()) : (this.iframeHasLoaded = this.originalIframeHasLoadedAlready = !0, this.iframe = g, this.requestToProcess())) : c();
            this.iframe = g;
        },
        requestToProcess: function(c, l1) {
            function a() {
                g.jsonForComparison.push(c);
                g.jsonWaiting.push([
                    c,
                    l1
                ]);
            }
            var g = this, b, e;
            b = p.adms.instance;
            c === Object(c) && b === Object(b) && b.idSyncContainerID === k && (z.ibsDeleted.push(c.ibs), delete c.ibs);
            if (c && !x.isEmptyObject(c)) {
                if (w.HAS_JSON_STRINGIFY) {
                    if (b = JSON.stringify(c.ibs || []), e = JSON.stringify(c.dests || []), this.jsonForComparison.length) {
                        var d = !1, f, h1, m;
                        f = 0;
                        for(h1 = this.jsonForComparison.length; f < h1; f++)if (m = this.jsonForComparison[f], b === JSON.stringify(m.ibs || []) && e === JSON.stringify(m.dests || [])) {
                            d = !0;
                            break;
                        }
                        d ? this.jsonDuplicates.push(c) : a();
                    } else a();
                } else a();
            }
            (this.receivedThirdPartyCookiesNotification || !w.POST_MESSAGE_ENABLED || this.iframeHasLoaded) && this.jsonWaiting.length && (b = this.jsonWaiting.shift(), !1 === this.newIframeCreated && delete b[0].ibs, this.process(b[0], b[1]), this.requestToProcess());
            this.iframeHasLoaded && this.messages.length && !this.sendingMessages && (this.throttleTimerSet || (this.throttleTimerSet = !0, setTimeout(function() {
                g.messageSendingInterval = w.POST_MESSAGE_ENABLED ? null : 150;
            }, this.THROTTLE_START)), this.sendingMessages = !0, this.sendMessages());
        },
        checkIfRegionChanged: function(c) {
            var l1 = t.getDilCookieField(w.REGION);
            null !== l1 && "undefined" !== typeof c.dcs_region && parseInt(l1, 10) !== c.dcs_region && (this.regionChanged = !0, this.timesRegionChanged++, t.setDilCookieField(w.FIRST_PARTY_SYNCS_ON_PAGE, ""), t.setDilCookieField(w.FIRST_PARTY_SYNCS, ""));
            "undefined" !== typeof c.dcs_region && t.setDilCookieField(w.REGION, c.dcs_region);
        },
        processSyncOnPage: function(c) {
            var l1, a, g;
            if ((l1 = c.ibs) && l1 instanceof Array && (a = l1.length)) for(c = 0; c < a; c++)g = l1[c], g.syncOnPage && this.checkFirstPartyCookie(g, "", "syncOnPage");
        },
        process: function(c, l1) {
            var a = encodeURIComponent, g, b, e, d, f, h1;
            l1 === Object(l1) && (h1 = t.encodeAndBuildRequest([
                "",
                l1.dpid || "",
                l1.dpuuid || ""
            ], ","));
            if ((g = c.dests) && g instanceof Array && (b = g.length)) for(e = 0; e < b; e++)d = g[e], f = [
                a("dests"),
                a(d.id || ""),
                a(d.y || ""),
                a(d.c || "")
            ], this.addMessage(f.join("|"));
            if ((g = c.ibs) && g instanceof Array && (b = g.length)) for(e = 0; e < b; e++)d = g[e], f = [
                a("ibs"),
                a(d.id || ""),
                a(d.tag || ""),
                t.encodeAndBuildRequest(d.url || [], ","),
                a(d.ttl || ""),
                "",
                h1,
                d.fireURLSync ? "true" : "false"
            ], d.syncOnPage || (this.canSetThirdPartyCookies ? this.addMessage(f.join("|")) : d.fireURLSync && this.checkFirstPartyCookie(d, f.join("|")));
            this.jsonProcessed.push(c);
        },
        checkFirstPartyCookie: function(c, l1, a) {
            var g = (a = "syncOnPage" === a ? !0 : !1) ? w.FIRST_PARTY_SYNCS_ON_PAGE : w.FIRST_PARTY_SYNCS, b = this.getOnPageSyncData(g), e = !1, d = !1, f = Math.ceil((new Date).getTime() / w.MILLIS_PER_DAY);
            b ? (b = b.split("*"), d = this.pruneSyncData(b, c.id, f), e = d.dataPresent, d = d.dataValid, e && d || this.fireSync(a, c, l1, b, g, f)) : (b = [], this.fireSync(a, c, l1, b, g, f));
        },
        getOnPageSyncData: function(c) {
            var a = p.adms.instance;
            return a && "function" === typeof a.idSyncGetOnPageSyncInfo ? a.idSyncGetOnPageSyncInfo() : t.getDilCookieField(c);
        },
        pruneSyncData: function(c, a, b) {
            var g = !1, d = !1, e, f, h1;
            if (c instanceof Array) for(f = 0; f < c.length; f++)e = c[f], h1 = parseInt(e.split("-")[1], 10), e.match("^" + a + "-") ? (g = !0, b < h1 ? d = !0 : (c.splice(f, 1), f--)) : b >= h1 && (c.splice(f, 1), f--);
            return {
                dataPresent: g,
                dataValid: d
            };
        },
        manageSyncsSize: function(c) {
            if (c.join("*").length > this.MAX_SYNCS_LENGTH) for(c.sort(function(c, a) {
                return parseInt(c.split("-")[1], 10) - parseInt(a.split("-")[1], 10);
            }); c.join("*").length > this.MAX_SYNCS_LENGTH;)c.shift();
        },
        fireSync: function(c, a, b, g, d, e) {
            function f(c, a, l1, g) {
                return function() {
                    h1.onPagePixels[c] = null;
                    var b = h1.getOnPageSyncData(l1), d = [];
                    if (b) {
                        var b = b.split("*"), e, u, f;
                        e = 0;
                        for(u = b.length; e < u; e++)f = b[e], f.match("^" + a.id + "-") || d.push(f);
                    }
                    h1.setSyncTrackingData(d, a, l1, g);
                };
            }
            var h1 = this;
            if (c) {
                if ("img" === a.tag) {
                    c = a.url;
                    b = w.IS_HTTPS ? "https:" : "http:";
                    var k, m, s;
                    g = 0;
                    for(k = c.length; g < k; g++){
                        m = c[g];
                        s = /^\/\//.test(m);
                        var p = new Image;
                        t.addListener(p, "load", f(this.onPagePixels.length, a, d, e));
                        p.src = (s ? b : "") + m;
                        this.onPagePixels.push(p);
                    }
                }
            } else this.addMessage(b), this.setSyncTrackingData(g, a, d, e);
        },
        addMessage: function(c) {
            var a = encodeURIComponent, a = y ? a("---destpub-debug---") : a("---destpub---");
            this.messages.push((w.POST_MESSAGE_ENABLED ? "" : a) + c);
        },
        setSyncTrackingData: function(c, a, b, g) {
            c.push(a.id + "-" + (g + Math.ceil(a.ttl / 60 / 24)));
            this.manageSyncsSize(c);
            t.setDilCookieField(b, c.join("*"));
        },
        sendMessages: function() {
            var c = this, a = "", b = encodeURIComponent;
            this.regionChanged && (a = b("---destpub-clear-dextp---"), this.regionChanged = !1);
            this.messages.length ? w.POST_MESSAGE_ENABLED ? (a = a + b("---destpub-combined---") + this.messages.join("%01"), this.postMessage(a), this.messages = [], this.sendingMessages = !1) : (a += this.messages.shift(), this.postMessage(a), setTimeout(function() {
                c.sendMessages();
            }, this.messageSendingInterval)) : this.sendingMessages = !1;
        },
        postMessage: function(c) {
            DIL.xd.postMessage(c, this.url, this.iframe.contentWindow);
            this.messagesPosted.push(c);
        },
        receiveMessage: function(c) {
            var a = /^---destpub-to-parent---/;
            "string" === typeof c && a.test(c) && (a = c.replace(a, "").split("|"), "canSetThirdPartyCookies" === a[0] && (this.canSetThirdPartyCookies = "true" === a[1] ? !0 : !1, this.receivedThirdPartyCookiesNotification = !0, this.requestToProcess()), this.messagesReceived.push(c));
        }
    }, L = {
        traits: function(c) {
            x.isValidPdata(c) && (v1.sids instanceof Array || (v1.sids = []), t.extendArray(v1.sids, c));
            return this;
        },
        pixels: function(c) {
            x.isValidPdata(c) && (v1.pdata instanceof Array || (v1.pdata = []), t.extendArray(v1.pdata, c));
            return this;
        },
        logs: function(c) {
            x.isValidLogdata(c) && (v1.logdata !== Object(v1.logdata) && (v1.logdata = {}), t.extendObject(v1.logdata, c));
            return this;
        },
        customQueryParams: function(c) {
            x.isEmptyObject(c) || t.extendObject(v1, c, p.reservedKeys);
            return this;
        },
        signals: function(c, a) {
            var b, g = c;
            if (!x.isEmptyObject(g)) {
                if (a && "string" === typeof a) for(b in g = {}, c)c.hasOwnProperty(b) && (g[a + b] = c[b]);
                t.extendObject(v1, g, p.reservedKeys);
            }
            return this;
        },
        declaredId: function(c) {
            p.declaredId.setDeclaredId(c, "request");
            return this;
        },
        result: function(c) {
            "function" === typeof c && (v1.callback = c);
            return this;
        },
        afterResult: function(c) {
            "function" === typeof c && (v1.postCallbackFn = c);
            return this;
        },
        useImageRequest: function() {
            v1.useImageRequest = !0;
            return this;
        },
        clearData: function() {
            v1 = {};
            return this;
        },
        submit: function() {
            E.submitRequest(v1);
            v1 = {};
            return this;
        },
        getPartner: function() {
            return f;
        },
        getContainerNSID: function() {
            return k;
        },
        getEventLog: function() {
            return e;
        },
        getState: function() {
            var c = {}, l1 = {};
            t.extendObject(c, p, {
                callbackPrefix: !0,
                useJSONP: !0,
                registerRequest: !0
            });
            t.extendObject(l1, z, {
                attachIframe: !0,
                requestToProcess: !0,
                process: !0,
                sendMessages: !0
            });
            return {
                initConfig: a,
                pendingRequest: v1,
                otherRequestInfo: c,
                destinationPublishingInfo: l1
            };
        },
        idSync: function(c) {
            if (C) return "Error: id syncs have been disabled";
            if (c !== Object(c) || "string" !== typeof c.dpid || !c.dpid.length) return "Error: config or config.dpid is empty";
            if ("string" !== typeof c.url || !c.url.length) return "Error: config.url is empty";
            var a = c.url, b = c.minutesToLive, g = encodeURIComponent, e = z, d, a = a.replace(/^https:/, "").replace(/^http:/, "");
            if ("undefined" === typeof b) b = 20160;
            else if (b = parseInt(b, 10), isNaN(b) || 0 >= b) return "Error: config.minutesToLive needs to be a positive number";
            d = t.encodeAndBuildRequest([
                "",
                c.dpid,
                c.dpuuid || ""
            ], ",");
            c = [
                "ibs",
                g(c.dpid),
                "img",
                g(a),
                b,
                "",
                d
            ];
            e.addMessage(c.join("|"));
            p.firstRequestHasFired && e.requestToProcess();
            return "Successfully queued";
        },
        aamIdSync: function(c) {
            if (C) return "Error: id syncs have been disabled";
            if (c !== Object(c) || "string" !== typeof c.dpuuid || !c.dpuuid.length) return "Error: config or config.dpuuid is empty";
            c.url = "//dpm.demdex.net/ibs:dpid=" + c.dpid + "&dpuuid=" + c.dpuuid;
            return this.idSync(c);
        },
        passData: function(c) {
            if (x.isEmptyObject(c)) return "Error: json is empty or not an object";
            z.ibsDeleted.push(c.ibs);
            delete c.ibs;
            E.defaultCallback(c);
            return c;
        },
        getPlatformParams: function() {
            return p.platformParams;
        },
        getEventCallConfigParams: function() {
            var c = p, a = c.modStatsParams, b = c.platformParams, g;
            if (!a) {
                a = {};
                for(g in b)b.hasOwnProperty(g) && !c.nonModStatsParams[g] && (a[g.replace(/^d_/, "")] = b[g]);
                !0 === A ? a.coop_safe = 1 : !1 === A && (a.coop_unsafe = 1);
                c.modStatsParams = a;
            }
            return a;
        },
        setAsCoopSafe: function() {
            A = !0;
            return this;
        },
        setAsCoopUnsafe: function() {
            A = !1;
            return this;
        }
    }, E = {
        corsMetadata: function() {
            var c = "none", a = !0;
            "undefined" !== typeof XMLHttpRequest && XMLHttpRequest === Object(XMLHttpRequest) && ("withCredentials" in new XMLHttpRequest ? c = "XMLHttpRequest" : new Function("/*@cc_on return /^10/.test(@_jscript_version) @*/")() ? c = "XMLHttpRequest" : "undefined" !== typeof XDomainRequest && XDomainRequest === Object(XDomainRequest) && (a = !1), 0 < Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") && (a = !1));
            return {
                corsType: c,
                corsCookiesEnabled: a
            };
        }(),
        getCORSInstance: function() {
            return "none" === this.corsMetadata.corsType ? null : new window[this.corsMetadata.corsType];
        },
        submitRequest: function(c) {
            p.registerRequest(E.createQueuedRequest(c));
            return !0;
        },
        createQueuedRequest: function(c) {
            var a = p, b, g = c.callback, e = "img", d;
            if (!x.isEmptyObject(r)) {
                var f, h1, m;
                for(f in r)r.hasOwnProperty(f) && (h1 = r[f], null != h1 && "" !== h1 && f in c && !(h1 in c || h1 in p.reservedKeys) && (m = c[f], null != m && "" !== m && (c[h1] = m)));
            }
            x.isValidPdata(c.sids) || (c.sids = []);
            x.isValidPdata(c.pdata) || (c.pdata = []);
            x.isValidLogdata(c.logdata) || (c.logdata = {});
            c.logdataArray = t.convertObjectToKeyValuePairs(c.logdata, "=", !0);
            c.logdataArray.push("_ts=" + (new Date).getTime());
            "function" !== typeof g && (g = this.defaultCallback);
            a.useJSONP = !0 !== c.useImageRequest;
            a.useJSONP && (e = "script", b = a.callbackPrefix + "_" + k + "_" + (new Date).getTime());
            a = this.makeRequestSrcData(c, b);
            Q && !G || !(d = this.getCORSInstance()) || (e = "cors");
            return {
                tag: e,
                src: a.src,
                corsSrc: a.corsSrc,
                internalCallbackName: b,
                callbackFn: g,
                postCallbackFn: c.postCallbackFn,
                useImageRequest: !!c.useImageRequest,
                requestData: c,
                corsInstance: d,
                corsPostData: a.corsPostData
            };
        },
        defaultCallback: function(c, a) {
            z.checkIfRegionChanged(c);
            z.processSyncOnPage(c);
            var b, g, e, d, f, h1, k, s, y;
            if ((b = c.stuff) && b instanceof Array && (g = b.length)) {
                for(e = 0; e < g; e++)if ((d = b[e]) && d === Object(d)) {
                    f = d.cn;
                    h1 = d.cv;
                    k = d.ttl;
                    if ("undefined" === typeof k || "" === k) k = Math.floor(t.getMaxCookieExpiresInMinutes() / 60 / 24);
                    s = d.dmn || "." + document.domain.replace(/^www\./, "");
                    y = d.type;
                    f && (h1 || "number" === typeof h1) && ("var" !== y && (k = parseInt(k, 10)) && !isNaN(k) && t.setCookie(f, h1, 1440 * k, "/", s, !1), K.stuffed[f] = h1);
                }
            }
            b = c.uuid;
            x.isPopulatedString(b) && !x.isEmptyObject(m) && (g = m.path, "string" === typeof g && g.length || (g = "/"), e = parseInt(m.days, 10), isNaN(e) && (e = 100), t.setCookie(m.name || "aam_did", b, 1440 * e, g, m.domain || "." + document.domain.replace(/^www\./, ""), !0 === m.secure));
            q || p.abortRequests || z.requestToProcess(c, a);
        },
        makeRequestSrcData: function(c, a) {
            c.sids = x.removeEmptyArrayValues(c.sids || []);
            c.pdata = x.removeEmptyArrayValues(c.pdata || []);
            var b = p, g = b.platformParams, e = t.encodeAndBuildRequest(c.sids, ","), d = t.encodeAndBuildRequest(c.pdata, ","), h1 = (c.logdataArray || []).join("&");
            delete c.logdataArray;
            var m = w.IS_HTTPS ? "https://" : "http://", s = b.declaredId.getDeclaredIdQueryString(), y = b.adms.instance ? b.adms.getCustomerIDsQueryString(b.adms.getCustomerIDs()) : "", n;
            n = [];
            var r, q, v1, B;
            for(r in c)if (!(r in b.reservedKeys) && c.hasOwnProperty(r)) {
                if (q = c[r], r = encodeURIComponent(r), q instanceof Array) for(v1 = 0, B = q.length; v1 < B; v1++)n.push(r + "=" + encodeURIComponent(q[v1]));
                else n.push(r + "=" + encodeURIComponent(q));
            }
            n = n.length ? "&" + n.join("&") : "";
            e = "d_nsid=" + g.d_nsid + b.getCoopQueryString() + s + y + (e.length ? "&d_sid=" + e : "") + (d.length ? "&d_px=" + d : "") + (h1.length ? "&d_ld=" + encodeURIComponent(h1) : "");
            g = "&d_rtbd=" + g.d_rtbd + "&d_jsonv=" + g.d_jsonv + "&d_dst=" + g.d_dst;
            m = m + f + ".demdex.net/event";
            d = b = m + "?" + e + (b.useJSONP ? g + "&d_cb=" + (a || "") : "") + n;
            2048 < b.length && (b = b.substring(0, 2048).substring(0, b.lastIndexOf("&")));
            return {
                corsSrc: m + "?" + (P ? "testcors=1&d_nsid=" + k + "&" : "") + "_ts=" + (new Date).getTime(),
                src: b,
                originalSrc: d,
                corsPostData: e + g + n,
                isDeclaredIdCall: "" !== s
            };
        },
        fireRequest: function(c) {
            if ("img" === c.tag) this.fireImage(c);
            else {
                var a = p.declaredId, a = a.declaredId.request || a.declaredId.init || {}, a = {
                    dpid: a.dpid || "",
                    dpuuid: a.dpuuid || ""
                };
                "script" === c.tag ? this.fireScript(c, a) : "cors" === c.tag && this.fireCORS(c, a);
            }
        },
        fireImage: function(c) {
            var a = p, d, g;
            a.abortRequests || (a.firing = !0, d = new Image(0, 0), a.sent.push(c), d.onload = function() {
                a.firing = !1;
                a.fired.push(c);
                a.num_of_img_responses++;
                a.registerRequest();
            }, g = function(g) {
                b = "imgAbortOrErrorHandler received the event of type " + g.type;
                e.push(b);
                a.abortRequests = !0;
                a.firing = !1;
                a.errored.push(c);
                a.num_of_img_errors++;
                a.registerRequest();
            }, d.addEventListener ? (d.addEventListener("error", g, !1), d.addEventListener("abort", g, !1)) : d.attachEvent && (d.attachEvent("onerror", g), d.attachEvent("onabort", g)), d.src = c.src);
        },
        fireScript: function(c, a) {
            var d = this, g = p, h1, k, m = c.src, s = c.postCallbackFn, n = "function" === typeof s, r = c.internalCallbackName;
            g.abortRequests || (g.firing = !0, window[r] = function(d) {
                try {
                    d !== Object(d) && (d = {});
                    C && (z.ibsDeleted.push(d.ibs), delete d.ibs);
                    var h1 = c.callbackFn;
                    g.firing = !1;
                    g.fired.push(c);
                    g.num_of_jsonp_responses++;
                    h1(d, a);
                    n && s(d, a);
                } catch (u) {
                    u.message = "DIL jsonp callback caught error with message " + u.message;
                    b = u.message;
                    e.push(b);
                    u.filename = u.filename || "dil.js";
                    u.partner = f;
                    DIL.errorModule.handleError(u);
                    try {
                        h1({
                            error: u.name + "|" + u.message
                        }, a), n && s({
                            error: u.name + "|" + u.message
                        }, a);
                    } catch (m) {}
                } finally{
                    g.requestRemoval({
                        script: k,
                        callbackName: r
                    }), g.registerRequest();
                }
            }, N || G ? (g.firing = !1, g.requestRemoval({
                script: "no script created",
                callbackName: r
            })) : (k = document.createElement("script"), k.addEventListener && k.addEventListener("error", function(a) {
                g.requestRemoval({
                    script: k,
                    callbackName: r
                });
                b = "jsonp script tag error listener received the event of type " + a.type + " with src " + m;
                d.handleScriptError(b, c);
            }, !1), k.type = "text/javascript", k.src = m, h1 = DIL.variables.scriptNodeList[0], h1.parentNode.insertBefore(k, h1)), g.sent.push(c), g.declaredId.declaredId.request = null);
        },
        fireCORS: function(c, a) {
            var d = this, g = p, h1 = this.corsMetadata.corsType, k = c.corsSrc, m = c.corsInstance, s = c.corsPostData, r = c.postCallbackFn, n = "function" === typeof r;
            if (!g.abortRequests && !S) {
                g.firing = !0;
                try {
                    m.open("post", k, !0), "XMLHttpRequest" === h1 && (m.withCredentials = !0, m.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), m.onreadystatechange = function() {
                        if (4 === this.readyState && 200 === this.status) a: {
                            var h1;
                            try {
                                if (h1 = JSON.parse(this.responseText), h1 !== Object(h1)) {
                                    d.handleCORSError(c, a, "Response is not JSON");
                                    break a;
                                }
                            } catch (k) {
                                d.handleCORSError(c, a, "Error parsing response as JSON");
                                break a;
                            }
                            C && (z.ibsDeleted.push(h1.ibs), delete h1.ibs);
                            try {
                                var m = c.callbackFn;
                                g.firing = !1;
                                g.fired.push(c);
                                g.num_of_cors_responses++;
                                m(h1, a);
                                n && r(h1, a);
                            } catch (s) {
                                s.message = "DIL handleCORSResponse caught error with message " + s.message;
                                b = s.message;
                                e.push(b);
                                s.filename = s.filename || "dil.js";
                                s.partner = f;
                                DIL.errorModule.handleError(s);
                                try {
                                    m({
                                        error: s.name + "|" + s.message
                                    }, a), n && r({
                                        error: s.name + "|" + s.message
                                    }, a);
                                } catch (y) {}
                            } finally{
                                g.registerRequest();
                            }
                        }
                    }), m.onerror = function() {
                        d.handleCORSError(c, a, "onerror");
                    }, m.ontimeout = function() {
                        d.handleCORSError(c, a, "ontimeout");
                    }, m.send(s);
                } catch (y) {
                    this.handleCORSError(c, a, "try-catch");
                }
                g.sent.push(c);
                g.declaredId.declaredId.request = null;
            }
        },
        handleCORSError: function(c, a, b) {
            p.num_of_cors_errors++;
            p.corsErrorSources.push(b);
            "ontimeout" === b || G || (c.tag = "script", this.fireScript(c, a));
        },
        handleScriptError: function(c, a) {
            p.num_of_jsonp_errors++;
            this.handleRequestError(c, a);
        },
        handleRequestError: function(c, a) {
            var b = p;
            e.push(c);
            b.abortRequests = !0;
            b.firing = !1;
            b.errored.push(a);
            b.registerRequest();
        }
    }, x = {
        isValidPdata: function(c) {
            return c instanceof Array && this.removeEmptyArrayValues(c).length ? !0 : !1;
        },
        isValidLogdata: function(c) {
            return !this.isEmptyObject(c);
        },
        isEmptyObject: function(c) {
            if (c !== Object(c)) return !0;
            for(var a in c)if (c.hasOwnProperty(a)) return !1;
            return !0;
        },
        removeEmptyArrayValues: function(c) {
            for(var a = 0, b = c.length, g, d = [], a = 0; a < b; a++)g = c[a], "undefined" !== typeof g && null !== g && "" !== g && d.push(g);
            return d;
        },
        isPopulatedString: function(c) {
            return "string" === typeof c && c.length;
        }
    }, t = {
        addListener: function() {
            if (document.addEventListener) return function(c, a, b) {
                c.addEventListener(a, function(c) {
                    "function" === typeof b && b(c);
                }, !1);
            };
            if (document.attachEvent) return function(c, a, b) {
                c.attachEvent("on" + a, function(c) {
                    "function" === typeof b && b(c);
                });
            };
        }(),
        convertObjectToKeyValuePairs: function(c, a, b) {
            var d = [], e, f;
            a || (a = "=");
            for(e in c)c.hasOwnProperty(e) && (f = c[e], "undefined" !== typeof f && null !== f && "" !== f && d.push(e + a + (b ? encodeURIComponent(f) : f)));
            return d;
        },
        encodeAndBuildRequest: function(a, b) {
            return this.map(a, function(a) {
                return encodeURIComponent(a);
            }).join(b);
        },
        map: function(a, b) {
            if (Array.prototype.map) return a.map(b);
            if (void 0 === a || null === a) throw new TypeError;
            var d = Object(a), g = d.length >>> 0;
            if ("function" !== typeof b) throw new TypeError;
            for(var e = Array(g), f = 0; f < g; f++)f in d && (e[f] = b.call(b, d[f], f, d));
            return e;
        },
        filter: function(a, b) {
            if (!Array.prototype.filter) {
                if (void 0 === a || null === a) throw new TypeError;
                var d = Object(a), g = d.length >>> 0;
                if ("function" !== typeof b) throw new TypeError;
                for(var e = [], f = 0; f < g; f++)if (f in d) {
                    var h1 = d[f];
                    b.call(b, h1, f, d) && e.push(h1);
                }
                return e;
            }
            return a.filter(b);
        },
        getCookie: function(a) {
            a += "=";
            var b = document.cookie.split(";"), d, g, e;
            d = 0;
            for(g = b.length; d < g; d++){
                for(e = b[d]; " " === e.charAt(0);)e = e.substring(1, e.length);
                if (0 === e.indexOf(a)) return decodeURIComponent(e.substring(a.length, e.length));
            }
            return null;
        },
        setCookie: function(a, b, d, e, f, h1) {
            var k = new Date;
            d && (d *= 6E4);
            document.cookie = a + "=" + encodeURIComponent(b) + (d ? ";expires=" + new Date(k.getTime() + d).toUTCString() : "") + (e ? ";path=" + e : "") + (f ? ";domain=" + f : "") + (h1 ? ";secure" : "");
        },
        extendArray: function(a, b) {
            return a instanceof Array && b instanceof Array ? (Array.prototype.push.apply(a, b), !0) : !1;
        },
        extendObject: function(a, b, d) {
            var e;
            if (a === Object(a) && b === Object(b)) {
                for(e in b)!b.hasOwnProperty(e) || !x.isEmptyObject(d) && e in d || (a[e] = b[e]);
                return !0;
            }
            return !1;
        },
        getMaxCookieExpiresInMinutes: function() {
            return w.SIX_MONTHS_IN_MINUTES;
        },
        getCookieField: function(a, b) {
            var d = this.getCookie(a), e = decodeURIComponent;
            if ("string" === typeof d) {
                var d = d.split("|"), f, h1;
                f = 0;
                for(h1 = d.length - 1; f < h1; f++)if (e(d[f]) === b) return e(d[f + 1]);
            }
            return null;
        },
        getDilCookieField: function(a) {
            return this.getCookieField(w.DIL_COOKIE_NAME, a);
        },
        setCookieField: function(a, b, d) {
            var e = this.getCookie(a), f = !1, h1 = encodeURIComponent;
            b = h1(b);
            d = h1(d);
            if ("string" === typeof e) {
                var e = e.split("|"), k, h1 = 0;
                for(k = e.length - 1; h1 < k; h1++)if (e[h1] === b) {
                    e[h1 + 1] = d;
                    f = !0;
                    break;
                }
                f || (h1 = e.length, e[h1] = b, e[h1 + 1] = d);
            } else e = [
                b,
                d
            ];
            this.setCookie(a, e.join("|"), this.getMaxCookieExpiresInMinutes(), "/", this.getDomain(), !1);
        },
        setDilCookieField: function(a, b) {
            return this.setCookieField(w.DIL_COOKIE_NAME, a, b);
        },
        getDomain: function(a) {
            !a && window.location && (a = window.location.hostname);
            if (a) {
                if (/^[0-9.]+$/.test(a)) a = "";
                else {
                    var b = a.split("."), d = b.length - 1, e = d - 1;
                    1 < d && 2 >= b[d].length && (2 === b[d - 1].length || 0 > ",DOMAIN_2_CHAR_EXCEPTIONS,".indexOf("," + b[d] + ",")) && e--;
                    if (0 < e) for(a = ""; d >= e;)a = b[d] + (a ? "." : "") + a, d--;
                }
            }
            return a;
        }
    };
    "error" === f && 0 === k && t.addListener(window, "load", function() {
        DIL.windowLoaded = !0;
    });
    var T = !1, I = function() {
        T || (T = !0, p.registerRequest(), V(), q || p.abortRequests || z.attachIframe(), p.readyToRemove = !0, p.requestRemoval());
    }, V = function() {
        q || setTimeout(function() {
            O || p.firstRequestHasFired || ("function" === typeof J ? L.afterResult(J).submit() : L.submit());
        }, DIL.constants.TIME_TO_DEFAULT_REQUEST);
    };
    D = document;
    "error" !== f && (DIL.windowLoaded ? I() : "complete" !== D.readyState && "loaded" !== D.readyState ? t.addListener(window, "load", function() {
        DIL.windowLoaded = !0;
        I();
    }) : (DIL.windowLoaded = !0, I()));
    if ("error" !== f) try {
        DIL.xd.receiveMessage(function(a) {
            z.receiveMessage(a.data);
        }, z.getIframeHost(z.url));
    } catch (W) {}
    p.declaredId.setDeclaredId(s, "init");
    p.processVisitorAPI();
    this.api = L;
    this.getStuffedVariable = function(a) {
        var b = K.stuffed[a];
        b || "number" === typeof b || (b = t.getCookie(a)) || "number" === typeof b || (b = "");
        return b;
    };
    this.validators = x;
    this.helpers = t;
    this.constants = w;
    this.log = e;
    U && (this.pendingRequest = v1, this.requestController = p, this.setDestinationPublishingUrl = h1, this.destinationPublishing = z, this.requestProcs = E, this.variables = K, this.callWindowLoadFunctions = I);
}, function() {
    var a = document, d;
    null == a.readyState && a.addEventListener && (a.readyState = "loading", a.addEventListener("DOMContentLoaded", d = function() {
        a.removeEventListener("DOMContentLoaded", d, !1);
        a.readyState = "complete";
    }, !1));
}(), DIL.extendStaticPropertiesAndMethods = function(a) {
    var d;
    if (a === Object(a)) for(d in a)a.hasOwnProperty(d) && (this[d] = a[d]);
}, DIL.extendStaticPropertiesAndMethods({
    version: "6.12",
    jsonVersion: 1,
    constants: {
        TIME_TO_DEFAULT_REQUEST: 50
    },
    variables: {
        scriptNodeList: document.getElementsByTagName("script"),
        scriptsRemoved: [],
        callbacksRemoved: []
    },
    windowLoaded: !1,
    dils: {},
    isAddedPostWindowLoad: function(a) {
        this.windowLoaded = "function" === typeof a ? !!a() : "boolean" === typeof a ? a : !0;
    },
    create: function(a) {
        try {
            return new DIL(a);
        } catch (d) {
            throw Error("Error in attempt to create DIL instance with DIL.create(): " + d.message);
        }
    },
    registerDil: function(a, d, e) {
        d = d + "$" + e;
        d in this.dils || (this.dils[d] = a);
    },
    getDil: function(a, d) {
        var e;
        "string" !== typeof a && (a = "");
        d || (d = 0);
        e = a + "$" + d;
        return e in this.dils ? this.dils[e] : Error("The DIL instance with partner = " + a + " and containerNSID = " + d + " was not found");
    },
    dexGetQSVars: function(a, d, e) {
        d = this.getDil(d, e);
        return d instanceof this ? d.getStuffedVariable(a) : "";
    },
    xd: {
        postMessage: function(a, d, e) {
            var b = 1;
            d && (window.postMessage ? e.postMessage(a, d.replace(/([^:]+:\/\/[^\/]+).*/, "$1")) : d && (e.location = d.replace(/#.*$/, "") + "#" + +new Date + b++ + "&" + a));
        },
        receiveMessage: function(a, d) {
            var e;
            try {
                if (window.postMessage) {
                    if (a && (e = function(b) {
                        if ("string" === typeof d && b.origin !== d || "[object Function]" === Object.prototype.toString.call(d) && !1 === d(b.origin)) return !1;
                        a(b);
                    }), window.addEventListener) window[a ? "addEventListener" : "removeEventListener"]("message", e, !1);
                    else window[a ? "attachEvent" : "detachEvent"]("onmessage", e);
                }
            } catch (b) {}
        }
    }
}), DIL.errorModule = function() {
    var a = DIL.create({
        partner: "error",
        containerNSID: 0,
        disableDestinationPublishingIframe: !0
    }), d = {
        harvestererror: 14138,
        destpuberror: 14139,
        dpmerror: 14140,
        generalerror: 14137,
        error: 14137,
        noerrortypedefined: 15021,
        evalerror: 15016,
        rangeerror: 15017,
        referenceerror: 15018,
        typeerror: 15019,
        urierror: 15020
    }, e = !1;
    return {
        activate: function() {
            e = !0;
        },
        handleError: function(b) {
            if (!e) return "DIL error module has not been activated";
            b !== Object(b) && (b = {});
            var h1 = b.name ? (b.name + "").toLowerCase() : "", f = [];
            b = {
                name: h1,
                filename: b.filename ? b.filename + "" : "",
                partner: b.partner ? b.partner + "" : "no_partner",
                site: b.site ? b.site + "" : document.location.href,
                message: b.message ? b.message + "" : ""
            };
            f.push(h1 in d ? d[h1] : d.noerrortypedefined);
            a.api.pixels(f).logs(b).useImageRequest().submit();
            return "DIL error report sent";
        },
        pixelMap: d
    };
}(), DIL.tools = {}, DIL.modules = {
    helpers: {
        handleModuleError: function(a, d, e) {
            var b = "";
            d = d || "Error caught in DIL module/submodule: ";
            a === Object(a) ? b = d + (a.message || "err has no message") : (b = d + "err is not a valid object", a = {});
            a.message = b;
            e instanceof DIL && (a.partner = e.api.getPartner());
            DIL.errorModule.handleError(a);
            return this.errorMessage = b;
        }
    }
});
DIL.tools.getSearchReferrer = function(a, d) {
    var e = DIL.getDil("error"), b = DIL.tools.decomposeURI(a || document.referrer), h1 = "", f = "", k = {
        queryParam: "q"
    };
    return (h1 = e.helpers.filter([
        d === Object(d) ? d : {},
        {
            hostPattern: /aol\./
        },
        {
            hostPattern: /ask\./
        },
        {
            hostPattern: /bing\./
        },
        {
            hostPattern: /google\./
        },
        {
            hostPattern: /yahoo\./,
            queryParam: "p"
        }
    ], function(a) {
        return !(!a.hasOwnProperty("hostPattern") || !b.hostname.match(a.hostPattern));
    }).shift()) ? {
        valid: !0,
        name: b.hostname,
        keywords: (e.helpers.extendObject(k, h1), f = k.queryPattern ? (h1 = ("" + b.search).match(k.queryPattern)) ? h1[1] : "" : b.uriParams[k.queryParam], decodeURIComponent(f || "").replace(/\+|%20/g, " "))
    } : {
        valid: !1,
        name: "",
        keywords: ""
    };
};
DIL.tools.decomposeURI = function(a) {
    var d = DIL.getDil("error"), e = document.createElement("a");
    e.href = a || document.referrer;
    return {
        hash: e.hash,
        host: e.host.split(":").shift(),
        hostname: e.hostname,
        href: e.href,
        pathname: e.pathname.replace(/^\//, ""),
        protocol: e.protocol,
        search: e.search,
        uriParams: function(a, e) {
            d.helpers.map(e.split("&"), function(d) {
                d = d.split("=");
                a[d.shift()] = d.shift();
            });
            return a;
        }({}, e.search.replace(/^(\/|\?)?|\/$/g, ""))
    };
};
DIL.tools.getMetaTags = function() {
    var a = {}, d = document.getElementsByTagName("meta"), e, b, h1, f, k;
    e = 0;
    for(h1 = arguments.length; e < h1; e++)if (f = arguments[e], null !== f) {
        for(b = 0; b < d.length; b++)if (k = d[b], k.name === f) {
            a[f] = k.content;
            break;
        }
    }
    return a;
};
DIL.modules.siteCatalyst = {
    dil: null,
    handle: DIL.modules.helpers.handleModuleError,
    init: function(a, d, e, b) {
        try {
            var h1 = this, f = {
                name: "DIL Site Catalyst Module Error"
            }, k = function(a) {
                f.message = a;
                DIL.errorModule.handleError(f);
                return a;
            };
            this.options = b === Object(b) ? b : {};
            this.dil = null;
            if (d instanceof DIL) this.dil = d;
            else return k("dilInstance is not a valid instance of DIL");
            f.partner = d.api.getPartner();
            if (a !== Object(a)) return k("siteCatalystReportingSuite is not an object");
            window.AppMeasurement_Module_DIL = a.m_DIL = function(a) {
                var b = "function" === typeof a.m_i ? a.m_i("DIL") : this;
                if (b !== Object(b)) return k("m is not an object");
                b.trackVars = h1.constructTrackVars(e);
                b.d = 0;
                b.s = a;
                b._t = function() {
                    var a, b, d = "," + this.trackVars + ",", e = this.s, f, r = [];
                    f = [];
                    var n = {}, q = !1;
                    if (e !== Object(e)) return k("Error in m._t function: s is not an object");
                    if (this.d) {
                        if ("function" === typeof e.foreachVar) e.foreachVar(function(a, b) {
                            "undefined" !== typeof b && (n[a] = b, q = !0);
                        }, this.trackVars);
                        else {
                            if (!(e.va_t instanceof Array)) return k("Error in m._t function: s.va_t is not an array");
                            if (e.lightProfileID) (a = e.lightTrackVars) && (a = "," + a + "," + e.vl_mr + ",");
                            else if (e.pe || e.linkType) a = e.linkTrackVars, e.pe && (b = e.pe.substring(0, 1).toUpperCase() + e.pe.substring(1), e[b] && (a = e[b].trackVars)), a && (a = "," + a + "," + e.vl_l + "," + e.vl_l2 + ",");
                            if (a) {
                                b = 0;
                                for(r = a.split(","); b < r.length; b++)0 <= d.indexOf("," + r[b] + ",") && f.push(r[b]);
                                f.length && (d = "," + f.join(",") + ",");
                            }
                            f = 0;
                            for(b = e.va_t.length; f < b; f++)a = e.va_t[f], 0 <= d.indexOf("," + a + ",") && "undefined" !== typeof e[a] && null !== e[a] && "" !== e[a] && (n[a] = e[a], q = !0);
                        }
                        h1.includeContextData(e, n).store_populated && (q = !0);
                        q && this.d.api.signals(n, "c_").submit();
                    }
                };
            };
            a.loadModule("DIL");
            a.DIL.d = d;
            return f.message ? f.message : "DIL.modules.siteCatalyst.init() completed with no errors";
        } catch (q) {
            return this.handle(q, "DIL.modules.siteCatalyst.init() caught error with message ", this.dil);
        }
    },
    constructTrackVars: function(a) {
        var d = [], e, b, h1, f, k;
        if (a === Object(a)) {
            e = a.names;
            if (e instanceof Array && (h1 = e.length)) for(b = 0; b < h1; b++)f = e[b], "string" === typeof f && f.length && d.push(f);
            a = a.iteratedNames;
            if (a instanceof Array && (h1 = a.length)) {
                for(b = 0; b < h1; b++)if (e = a[b], e === Object(e) && (f = e.name, k = parseInt(e.maxIndex, 10), "string" === typeof f && f.length && !isNaN(k) && 0 <= k)) for(e = 0; e <= k; e++)d.push(f + e);
            }
            if (d.length) return d.join(",");
        }
        return this.constructTrackVars({
            names: "pageName channel campaign products events pe pev1 pev2 pev3".split(" "),
            iteratedNames: [
                {
                    name: "prop",
                    maxIndex: 75
                },
                {
                    name: "eVar",
                    maxIndex: 250
                }
            ]
        });
    },
    includeContextData: function(a, d) {
        var e = {}, b = !1;
        if (a.contextData === Object(a.contextData)) {
            var h1 = a.contextData, f = this.options.replaceContextDataPeriodsWith, k = this.options.filterFromContextVariables, q = {}, n, r, m, y;
            "string" === typeof f && f.length || (f = "_");
            if (k instanceof Array) for(n = 0, r = k.length; n < r; n++)m = k[n], this.dil.validators.isPopulatedString(m) && (q[m] = !0);
            for(y in h1)!h1.hasOwnProperty(y) || q[y] || !(k = h1[y]) && "number" !== typeof k || (y = ("contextData." + y).replace(/\./g, f), d[y] = k, b = !0);
        }
        e.store_populated = b;
        return e;
    }
};
DIL.modules.GA = {
    submitUniversalAnalytics: function(a, d, e) {
        try {
            var b = a.getAll()[0], h1 = b[e || "b"].data.keys;
            a = {};
            var f, k, q, n;
            f = 0;
            for(k = h1.length; f < k; f++)q = h1[f], n = b.get(q), "undefined" === typeof n || "function" === typeof n || n === Object(n) || /^_/.test(q) || /^&/.test(q) || (a[q] = n);
            d.api.signals(a, "c_").submit();
            return a;
        } catch (r) {
            return "Caught error with message: " + r.message;
        }
    },
    dil: null,
    arr: null,
    tv: null,
    errorMessage: "",
    defaultTrackVars: [
        "_setAccount",
        "_setCustomVar",
        "_addItem",
        "_addTrans",
        "_trackSocial"
    ],
    defaultTrackVarsObj: null,
    signals: {},
    hasSignals: !1,
    handle: DIL.modules.helpers.handleModuleError,
    init: function(a, d, e) {
        try {
            this.tv = this.arr = this.dil = null;
            this.errorMessage = "";
            this.signals = {};
            this.hasSignals = !1;
            var b = {
                name: "DIL GA Module Error"
            }, h1 = "";
            d instanceof DIL ? (this.dil = d, b.partner = this.dil.api.getPartner()) : (h1 = "dilInstance is not a valid instance of DIL", b.message = h1, DIL.errorModule.handleError(b));
            a instanceof Array && a.length ? this.arr = a : (h1 = "gaArray is not an array or is empty", b.message = h1, DIL.errorModule.handleError(b));
            this.tv = this.constructTrackVars(e);
            this.errorMessage = h1;
        } catch (f) {
            this.handle(f, "DIL.modules.GA.init() caught error with message ", this.dil);
        } finally{
            return this;
        }
    },
    constructTrackVars: function(a) {
        var d = [], e, b, h1, f;
        if (this.defaultTrackVarsObj !== Object(this.defaultTrackVarsObj)) {
            h1 = this.defaultTrackVars;
            f = {};
            e = 0;
            for(b = h1.length; e < b; e++)f[h1[e]] = !0;
            this.defaultTrackVarsObj = f;
        } else f = this.defaultTrackVarsObj;
        if (a === Object(a)) {
            a = a.names;
            if (a instanceof Array && (b = a.length)) for(e = 0; e < b; e++)h1 = a[e], "string" === typeof h1 && h1.length && h1 in f && d.push(h1);
            if (d.length) return d;
        }
        return this.defaultTrackVars;
    },
    constructGAObj: function(a) {
        var d = {};
        a = a instanceof Array ? a : this.arr;
        var e, b, h1, f;
        e = 0;
        for(b = a.length; e < b; e++)h1 = a[e], h1 instanceof Array && h1.length && (h1 = [], f = a[e], h1 instanceof Array && f instanceof Array && Array.prototype.push.apply(h1, f), f = h1.shift(), "string" === typeof f && f.length && (d[f] instanceof Array || (d[f] = []), d[f].push(h1)));
        return d;
    },
    addToSignals: function(a, d) {
        if ("string" !== typeof a || "" === a || null == d || "" === d) return !1;
        this.signals[a] instanceof Array || (this.signals[a] = []);
        this.signals[a].push(d);
        return this.hasSignals = !0;
    },
    constructSignals: function() {
        var a = this.constructGAObj(), d = {
            _setAccount: function(a) {
                this.addToSignals("c_accountId", a);
            },
            _setCustomVar: function(a, b, d) {
                "string" === typeof b && b.length && this.addToSignals("c_" + b, d);
            },
            _addItem: function(a, b, d, e, f, h1) {
                this.addToSignals("c_itemOrderId", a);
                this.addToSignals("c_itemSku", b);
                this.addToSignals("c_itemName", d);
                this.addToSignals("c_itemCategory", e);
                this.addToSignals("c_itemPrice", f);
                this.addToSignals("c_itemQuantity", h1);
            },
            _addTrans: function(a, b, d, e, f, h1, k, n) {
                this.addToSignals("c_transOrderId", a);
                this.addToSignals("c_transAffiliation", b);
                this.addToSignals("c_transTotal", d);
                this.addToSignals("c_transTax", e);
                this.addToSignals("c_transShipping", f);
                this.addToSignals("c_transCity", h1);
                this.addToSignals("c_transState", k);
                this.addToSignals("c_transCountry", n);
            },
            _trackSocial: function(a, b, d, e) {
                this.addToSignals("c_socialNetwork", a);
                this.addToSignals("c_socialAction", b);
                this.addToSignals("c_socialTarget", d);
                this.addToSignals("c_socialPagePath", e);
            }
        }, e = this.tv, b, h1, f, k, q, n;
        b = 0;
        for(h1 = e.length; b < h1; b++)if (f = e[b], a.hasOwnProperty(f) && d.hasOwnProperty(f) && (n = a[f], n instanceof Array)) for(k = 0, q = n.length; k < q; k++)d[f].apply(this, n[k]);
    },
    submit: function() {
        try {
            if ("" !== this.errorMessage) return this.errorMessage;
            this.constructSignals();
            return this.hasSignals ? (this.dil.api.signals(this.signals).submit(), "Signals sent: " + this.dil.helpers.convertObjectToKeyValuePairs(this.signals, "=", !0) + this.dil.log) : "No signals present";
        } catch (a) {
            return this.handle(a, "DIL.modules.GA.submit() caught error with message ", this.dil);
        }
    },
    Stuffer: {
        LIMIT: 5,
        dil: null,
        cookieName: null,
        delimiter: null,
        errorMessage: "",
        handle: DIL.modules.helpers.handleModuleError,
        callback: null,
        v: function() {
            return !1;
        },
        init: function(a, d, e) {
            try {
                this.callback = this.dil = null, this.errorMessage = "", a instanceof DIL ? (this.dil = a, this.v = this.dil.validators.isPopulatedString, this.cookieName = this.v(d) ? d : "aam_ga", this.delimiter = this.v(e) ? e : "|") : this.handle({
                    message: "dilInstance is not a valid instance of DIL"
                }, "DIL.modules.GA.Stuffer.init() error: ");
            } catch (b) {
                this.handle(b, "DIL.modules.GA.Stuffer.init() caught error with message ", this.dil);
            } finally{
                return this;
            }
        },
        process: function(a) {
            var d, e, b, h1, f, k;
            k = !1;
            var q = 1;
            if (a === Object(a) && (d = a.stuff) && d instanceof Array && (e = d.length)) {
                for(a = 0; a < e; a++)if ((b = d[a]) && b === Object(b) && (h1 = b.cn, f = b.cv, h1 === this.cookieName && this.v(f))) {
                    k = !0;
                    break;
                }
            }
            if (k) {
                d = f.split(this.delimiter);
                "undefined" === typeof window._gaq && (window._gaq = []);
                b = window._gaq;
                a = 0;
                for(e = d.length; a < e && !(k = d[a].split("="), f = k[0], k = k[1], this.v(f) && this.v(k) && b.push([
                    "_setCustomVar",
                    q++,
                    f,
                    k,
                    1
                ]), q > this.LIMIT); a++);
                this.errorMessage = 1 < q ? "No errors - stuffing successful" : "No valid values to stuff";
            } else this.errorMessage = "Cookie name and value not found in json";
            if ("function" === typeof this.callback) return this.callback();
        },
        submit: function() {
            try {
                var a = this;
                if ("" !== this.errorMessage) return this.errorMessage;
                this.dil.api.afterResult(function(d) {
                    a.process(d);
                }).submit();
                return "DIL.modules.GA.Stuffer.submit() successful";
            } catch (d) {
                return this.handle(d, "DIL.modules.GA.Stuffer.submit() caught error with message ", this.dil);
            }
        }
    }
};
DIL.modules.Peer39 = {
    aid: "",
    dil: null,
    optionals: null,
    errorMessage: "",
    calledBack: !1,
    script: null,
    scriptsSent: [],
    returnedData: [],
    handle: DIL.modules.helpers.handleModuleError,
    init: function(a, d, e) {
        try {
            this.dil = null;
            this.errorMessage = "";
            this.calledBack = !1;
            this.optionals = e === Object(e) ? e : {};
            e = {
                name: "DIL Peer39 Module Error"
            };
            var b = [], h1 = "";
            this.isSecurePageButNotEnabled(document.location.protocol) && (h1 = "Module has not been enabled for a secure page", b.push(h1), e.message = h1, DIL.errorModule.handleError(e));
            d instanceof DIL ? (this.dil = d, e.partner = this.dil.api.getPartner()) : (h1 = "dilInstance is not a valid instance of DIL", b.push(h1), e.message = h1, DIL.errorModule.handleError(e));
            "string" === typeof a && a.length ? this.aid = a : (h1 = "aid is not a string or is empty", b.push(h1), e.message = h1, DIL.errorModule.handleError(e));
            this.errorMessage = b.join("\n");
        } catch (f) {
            this.handle(f, "DIL.modules.Peer39.init() caught error with message ", this.dil);
        } finally{
            return this;
        }
    },
    isSecurePageButNotEnabled: function(a) {
        return "https:" === a && !0 !== this.optionals.enableHTTPS ? !0 : !1;
    },
    constructSignals: function() {
        var a = this, d = this.constructScript(), e = DIL.variables.scriptNodeList[0];
        window["afterFinished_" + this.aid] = function() {
            try {
                var b = a.processData(p39_KVP_Short("c_p", "|").split("|"));
                b.hasSignals && a.dil.api.signals(b.signals).submit();
            } catch (d) {} finally{
                a.calledBack = !0, "function" === typeof a.optionals.afterResult && a.optionals.afterResult();
            }
        };
        e.parentNode.insertBefore(d, e);
        this.scriptsSent.push(d);
        return "Request sent to Peer39";
    },
    processData: function(a) {
        var d, e, b, h1, f = {}, k = !1;
        this.returnedData.push(a);
        if (a instanceof Array) for(d = 0, e = a.length; d < e; d++)b = a[d].split("="), h1 = b[0], b = b[1], h1 && isFinite(b) && !isNaN(parseInt(b, 10)) && (f[h1] instanceof Array || (f[h1] = []), f[h1].push(b), k = !0);
        return {
            hasSignals: k,
            signals: f
        };
    },
    constructScript: function() {
        var a = document.createElement("script"), d = this.optionals, e = d.scriptId, b = d.scriptSrc, d = d.scriptParams;
        a.id = "string" === typeof e && e.length ? e : "peer39ScriptLoader";
        a.type = "text/javascript";
        "string" === typeof b && b.length ? a.src = b : (a.src = document.location.protocol + "//stags.peer39.net/" + this.aid + "/trg_" + this.aid + ".js", "string" === typeof d && d.length && (a.src += "?" + d));
        return a;
    },
    submit: function() {
        try {
            return "" !== this.errorMessage ? this.errorMessage : this.constructSignals();
        } catch (a) {
            return this.handle(a, "DIL.modules.Peer39.submit() caught error with message ", this.dil);
        }
    }
};

},{}],"9fy0t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MessengerLink", ()=>MessengerLink);
var _defineProperty = require("@swc/helpers/_/_define_property");
var _utils = require("./utils");
class MessengerLink {
    constructor(Messengers){
        (0, _defineProperty._)(this, "Messengers", void 0);
        (0, _defineProperty._)(this, "videoElement", void 0);
        // player events
        (0, _defineProperty._)(this, "onBitrateChange", (bitrateObj)=>{
            this.Messengers.bitrateChange$.send(bitrateObj.detail.bitRate);
        });
        (0, _defineProperty._)(this, "onTimeUpdate", ()=>this.Messengers.timeUpdate$.send(this.videoElement.currentTime));
        (0, _defineProperty._)(this, "onId3Metadata", (id3Obj)=>this.Messengers.id3Metadata$.send(id3Obj));
        (0, _defineProperty._)(this, "onError", (errorObj)=>this.Messengers.playerError$.send(errorObj));
        (0, _defineProperty._)(this, "onAppHidden", (detailObj)=>this.Messengers.appHiddenWithoutAudio$.send(detailObj.detail.blocked));
        // player states
        (0, _defineProperty._)(this, "onInitialising", ()=>this.Messengers.playerState$.send((0, _utils.PlayerStates).Initialising));
        (0, _defineProperty._)(this, "onPlaying", ()=>this.Messengers.playerState$.send((0, _utils.PlayerStates).Playing));
        (0, _defineProperty._)(this, "onPause", ()=>this.Messengers.playerState$.send((0, _utils.PlayerStates).Paused));
        (0, _defineProperty._)(this, "onWaiting", ()=>this.Messengers.playerState$.send((0, _utils.PlayerStates).Buffering));
        (0, _defineProperty._)(this, "onSeeking", ()=>this.Messengers.playerState$.send((0, _utils.PlayerStates).Seeking));
        (0, _defineProperty._)(this, "linkVideoElementListeners", (videoElement)=>{
            videoElement.addEventListener("timeupdate", this.onTimeUpdate);
            videoElement.addEventListener("bitrateChanged", this.onBitrateChange);
            videoElement.addEventListener("id3Metadata", this.onId3Metadata);
            videoElement.addEventListener("error", this.onError);
            videoElement.addEventListener("blocked", this.onAppHidden);
            videoElement.addEventListener("loadedmetadata", this.onInitialising);
            videoElement.addEventListener("playing", this.onPlaying);
            videoElement.addEventListener("pause", this.onPause);
            videoElement.addEventListener("waiting", this.onWaiting);
            videoElement.addEventListener("seeking", this.onSeeking);
            this.videoElement = videoElement;
        });
        (0, _defineProperty._)(this, "unlinkVideoElementListeners", (videoElement)=>{
            videoElement.removeEventListener("timeupdate", this.onTimeUpdate);
            videoElement.removeEventListener("bitrateChanged", this.onBitrateChange);
            videoElement.removeEventListener("id3Metadata", this.onId3Metadata);
            videoElement.removeEventListener("error", this.onError);
            videoElement.removeEventListener("blocked", this.onAppHidden);
            videoElement.removeEventListener("loadedmetadata", this.onInitialising);
            videoElement.removeEventListener("playing", this.onPlaying);
            videoElement.removeEventListener("pause", this.onPause);
            videoElement.removeEventListener("waiting", this.onWaiting);
            videoElement.removeEventListener("seeking", this.onSeeking);
            this.videoElement = null;
        });
        this.Messengers = Messengers;
    }
}

},{"@swc/helpers/_/_define_property":"9kWBJ","./utils":"lhCx6","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"lhCx6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NetworkConnectionType", ()=>NetworkConnectionType);
parcelHelpers.export(exports, "PlayerStates", ()=>PlayerStates);
parcelHelpers.export(exports, "OztamEventType", ()=>OztamEventType);
parcelHelpers.export(exports, "generateUUID", ()=>generateUUID);
parcelHelpers.export(exports, "AsyncFunctionQueue", ()=>AsyncFunctionQueue);
var _defineProperty = require("@swc/helpers/_/_define_property");
class NetworkConnectionType {
}
(0, _defineProperty._)(NetworkConnectionType, "WIFI", "WIFI");
(0, _defineProperty._)(NetworkConnectionType, "LAN", "LAN");
(0, _defineProperty._)(NetworkConnectionType, "UNKNOWN", "Unknown");
class PlayerStates {
}
(0, _defineProperty._)(PlayerStates, "Playing", "Playing");
(0, _defineProperty._)(PlayerStates, "Paused", "Paused");
(0, _defineProperty._)(PlayerStates, "Buffering", "Buffering");
(0, _defineProperty._)(PlayerStates, "Seeking", "Seeking");
(0, _defineProperty._)(PlayerStates, "Initialising", "Initialising");
class OztamEventType {
}
(0, _defineProperty._)(OztamEventType, "LOAD", "LOAD");
(0, _defineProperty._)(OztamEventType, "BEGIN", "BEGIN");
(0, _defineProperty._)(OztamEventType, "PROGRESS", "PROGRESS");
(0, _defineProperty._)(OztamEventType, "COMPLETE", "COMPLETE");
(0, _defineProperty._)(OztamEventType, "AD_BEGIN", "AD_BEGIN");
(0, _defineProperty._)(OztamEventType, "AD_COMPLETE", "AD_COMPLETE");
const generateUUID = ()=>{
    // Public Domain/MIT
    let d = new Date().getTime(); //Timestamp
    let d2 = typeof performance !== "undefined" && performance.now && performance.now() * 1000 || 0; //Time in microseconds since page-load or 0 if unsupported
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        let r = Math.random() * 16; //random number between 0 and 16
        if (d > 0) {
            //Use timestamp until depleted
            r = (d + r) % 16 | 0;
            d = Math.floor(d / 16);
        } else {
            //Use microseconds since page-load if supported
            r = (d2 + r) % 16 | 0;
            d2 = Math.floor(d2 / 16);
        }
        return (c === "x" ? r : r & 0x3 | 0x8).toString(16);
    });
};
class AsyncFunctionQueue {
    pushFunction(fn) {
        this._functionQueue.push(fn);
        this._tryStartQueueProcessing();
    }
    constructor(){
        (0, _defineProperty._)(this, "_functionQueue", []);
        (0, _defineProperty._)(this, "_functionRunningInProgress", false);
        (0, _defineProperty._)(this, "_tryStartQueueProcessing", async ()=>{
            if (this._functionRunningInProgress || !this._functionQueue.length) return;
            this._functionRunningInProgress = true;
            await this._functionQueue.shift()();
            this._functionRunningInProgress = false;
            this._tryStartQueueProcessing();
        });
    }
}

},{"@swc/helpers/_/_define_property":"9kWBJ","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"48YTm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Messengers", ()=>Messengers);
var _defineProperty = require("@swc/helpers/_/_define_property");
var _messenger = require("./Messenger");
var _utils = require("./utils");
class NineMessengers {
    constructor(){
        // 9Now specific
        (0, _defineProperty._)(this, "streamReady$", new (0, _messenger.Messenger)(null));
        (0, _defineProperty._)(this, "programChange$", new (0, _messenger.Messenger)(null));
        // player
        (0, _defineProperty._)(this, "playerState$", new (0, _messenger.Messenger)((0, _utils.PlayerStates).Initialising));
        (0, _defineProperty._)(this, "timeUpdate$", new (0, _messenger.Messenger)(0));
        (0, _defineProperty._)(this, "bitrateChange$", new (0, _messenger.Messenger)(0));
        (0, _defineProperty._)(this, "id3Metadata$", new (0, _messenger.Messenger)(null));
        (0, _defineProperty._)(this, "playerError$", new (0, _messenger.Messenger)(null));
        (0, _defineProperty._)(this, "appHiddenWithoutAudio$", new (0, _messenger.Messenger)(false));
        // ads
        (0, _defineProperty._)(this, "currentAd$", new (0, _messenger.Messenger)(null));
        // other
        (0, _defineProperty._)(this, "appTeardown$", new (0, _messenger.Messenger)(undefined));
        (0, _defineProperty._)(this, "oztamSessionId$", new (0, _messenger.Messenger)((0, _utils.generateUUID)()));
    }
}
const Messengers = new NineMessengers();

},{"@swc/helpers/_/_define_property":"9kWBJ","./Messenger":"9pINz","./utils":"lhCx6","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"9pINz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Messenger", ()=>Messenger);
var _defineProperty = require("@swc/helpers/_/_define_property");
class Receiver {
    constructor(action){
        (0, _defineProperty._)(this, "teardownFunctions", []);
        (0, _defineProperty._)(this, "addTeardown", (teardownFn)=>{
            this.teardownFunctions.push(teardownFn);
        });
        (0, _defineProperty._)(this, "callAction", (value)=>this.action(value));
        (0, _defineProperty._)(this, "unlisten", ()=>{
            this.teardownFunctions.forEach((teardownFn)=>teardownFn());
            this.teardownFunctions = [];
        });
        this.action = action;
    }
}
class PartialMessenger {
    addReceiver(receiverAction, immediatelySendData = false) {
        const newReceiver = new Receiver(receiverAction);
        if (this.messengerLink) {
            const linkTeardownFunction = this.messengerLink(newReceiver, immediatelySendData);
            newReceiver.addTeardown(linkTeardownFunction);
        }
        newReceiver.addTeardown(()=>{
            this.receivers = this.receivers.filter((receiver)=>receiver !== newReceiver);
        });
        this.receivers.push(newReceiver);
        return newReceiver;
    }
    pipe(...fns) {
        const aggregateOfAll = (source)=>fns.reduce((observableSoFar, operatorFunction)=>operatorFunction(observableSoFar), source);
        return aggregateOfAll(this);
    }
    constructor(messengerLink){
        (0, _defineProperty._)(this, "receivers", []);
        this.messengerLink = messengerLink;
    }
}
class Messenger extends PartialMessenger {
    constructor(state){
        super(undefined);
        (0, _defineProperty._)(this, "initialValue", void 0);
        (0, _defineProperty._)(this, "state", void 0);
        (0, _defineProperty._)(this, "addReceiver", (receiverAction, immediatelySendData = false)=>{
            const newReceiver = super.addReceiver(receiverAction);
            if (immediatelySendData) newReceiver.callAction(this.state);
            return newReceiver;
        });
        (0, _defineProperty._)(this, "send", (data)=>{
            this.state = data;
            this.receivers.forEach((receiver)=>{
                receiver.callAction(data);
            });
        });
        (0, _defineProperty._)(this, "reset", ()=>{
            this.send(this.initialValue);
        });
        (0, _defineProperty._)(this, "getCurrentValue", ()=>this.state);
        this.initialValue = state;
        this.state = state;
    }
}

},{"@swc/helpers/_/_define_property":"9kWBJ","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"d7nPH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Store", ()=>Store);
var _utils = require("./utils");
var _packageJson = require("../package.json");
var _packageJsonDefault = parcelHelpers.interopDefault(_packageJson);
const nineStagingConfigKey = "au.com.nine_USE_STAGING_CONFIG";
// run this in debugger to set staging config, then reload
// localStorage.setItem("au.com.nine_USE_STAGING_CONFIG", "true");
const useProdConfig = localStorage.getItem(nineStagingConfigKey) !== "true";
const Store = {
    nuid: "",
    region: "",
    accessToken: "",
    channelSlug: "",
    appConfig: null,
    useProdConfig,
    aampVersion: "unknown",
    appVersion: (0, _packageJsonDefault.default).version,
    apiConfig: useProdConfig ? {
        apiBaseUrl: "https://api.9now.com.au",
        regionServiceUrl: "https://loc.nine.com.au",
        nuidUrl: "https://adc.api.nine.com.au",
        loginUrl: "https://login.nine.com.au"
    } : {
        apiBaseUrl: "https://au-proxy.apac.ninja/nine-stag-api-proxy",
        regionServiceUrl: "https://staging.loc.nine.com.au",
        nuidUrl: "https://au-proxy.apac.ninja/nine-stag-nuid-proxy",
        loginUrl: "https://au-proxy.apac.ninja/nine-stag-login-proxy"
    },
    deviceId: "",
    devicePlatform: "",
    deviceNetworkConnection: (0, _utils.NetworkConnectionType).UNKNOWN,
    getOztamVendorVersion: function() {
        const platformString = this.devicePlatform.toLowerCase() === "soip-pck" ? "Puck" : "TV";
        return `9Now_Foxtel-${platformString}-Linear_${this.appVersion}`;
    },
    currentStreamUrl: ""
};

},{"./utils":"lhCx6","../package.json":"jiBTS","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"jiBTS":[function(require,module,exports) {
module.exports = JSON.parse('{"name":"au.com.nine","version":"1.0.49","description":"","main":"index.js","scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"author":"","license":"ISC","dependencies":{"@yospace/admanagement-sdk":"3.6.7","youboralib":"^6.8.50"}}');

},{}],"jTFkH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ErrorTypes", ()=>ErrorTypes);
parcelHelpers.export(exports, "MLEError", ()=>MLEError);
parcelHelpers.export(exports, "setTokenInDeviceStorage", ()=>setTokenInDeviceStorage);
var _defineProperty = require("@swc/helpers/_/_define_property");
class ErrorTypes {
}
(0, _defineProperty._)(ErrorTypes, "GENERIC", "GENERIC");
(0, _defineProperty._)(ErrorTypes, "AUTH", "AUTH");
(0, _defineProperty._)(ErrorTypes, "PROVIDER", "PROVIDER");
(0, _defineProperty._)(ErrorTypes, "CHANNEL_MAP", "CHANNEL_MAP");
class MLEError extends Error {
    getDetail() {
        return null;
    }
    getMediaFailedPayload() {
        return {
            error: {
                major: 20000,
                minor: 110,
                desc: `${this.type}|${this.message}|${this.status}`
            }
        };
    }
    constructor(message, type, status){
        super(message);
        (0, _defineProperty._)(this, "type", void 0);
        (0, _defineProperty._)(this, "status", void 0);
        this.message = message;
        this.type = type;
        this.status = status;
    }
}
const setTokenInDeviceStorage = async (storageKey, encodedTokenString)=>{
    // eslint-disable-next-line no-console
    console.log(`Updating token for ${storageKey}`);
    return await fetch(`http://localhost:9005/as/system/token/${storageKey}`, {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify({
            token: encodedTokenString
        })
    });
};

},{"@swc/helpers/_/_define_property":"9kWBJ","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"90vPW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "get9NowLiveChannel", ()=>get9NowLiveChannel);
parcelHelpers.export(exports, "get9NowPlaybackData", ()=>get9NowPlaybackData);
parcelHelpers.export(exports, "getAndStoreConfig", ()=>getAndStoreConfig);
parcelHelpers.export(exports, "getApiRegion", ()=>getApiRegion);
var _providerUtils = require("../../provider-utils");
var _messengers = require("../helpers/Messengers");
var _nineStore = require("../helpers/nine-store");
const isLiveResponse = (response)=>{
    return response && response.data && response.data.getLivestream && response.data.getLivestream.channels && response.data.getLivestream.channels.length;
};
const get9NowLiveChannel = async (channelSlug, region)=>{
    const authToken = (0, _nineStore.Store).accessToken;
    const nineApiUrl = `${(0, _nineStore.Store).apiConfig.apiBaseUrl}/ctv/accedo/livestreams?device=ctv_foxtel&region=${region}&streamParams=foxtel&token=${authToken}`;
    const nineApiFetchResponse = await fetch(nineApiUrl).catch(()=>{
        throw new (0, _providerUtils.MLEError)("HTTP error fetching 9Now livestreams API", (0, _providerUtils.ErrorTypes).PROVIDER);
    });
    if (!nineApiFetchResponse.ok) throw new (0, _providerUtils.MLEError)("API error retrieving livestreams " + nineApiFetchResponse.statusText, (0, _providerUtils.ErrorTypes).PROVIDER, nineApiFetchResponse.status);
    const liveResponse = await nineApiFetchResponse.json();
    if (!isLiveResponse(liveResponse)) throw new (0, _providerUtils.MLEError)("Unexpected live streams API response format", (0, _providerUtils.ErrorTypes).PROVIDER);
    const liveChannels = liveResponse.data.getLivestream.channels;
    for(let i = 0; i < liveChannels.length; i++){
        if (liveChannels[i].slug === channelSlug) return liveChannels[i];
    }
    throw new (0, _providerUtils.MLEError)("Could not find channel with matching slug", (0, _providerUtils.ErrorTypes).CHANNEL_MAP);
};
const getChannelSourceUrl = (channel)=>{
    let playbackUrl = channel.stream.url;
    if (!playbackUrl) throw new (0, _providerUtils.MLEError)("No playback url for channel " + channel.slug, (0, _providerUtils.ErrorTypes).PROVIDER);
    const deviceId = (0, _nineStore.Store).deviceId;
    const nuid = (0, _nineStore.Store).nuid;
    const addedQueryParamsMap = {
        deviceType: "tv",
        userAgentheader: navigator.userAgent,
        vendorVersion: (0, _nineStore.Store).getOztamVendorVersion(),
        device_id: deviceId,
        oztam_session_id: (0, _messengers.Messengers).oztamSessionId$.getCurrentValue(),
        nuid: nuid || "<empty>",
        // 'yo.av' indicates to the Yospace SDK to activate analytics.
        "yo.av": "4",
        "yo.br": "true"
    };
    const queryParamsString = Object.keys(addedQueryParamsMap).map((key)=>`${key}=${addedQueryParamsMap[key]}`).join("&");
    const querySeparator = (playbackUrl === null || playbackUrl === void 0 ? void 0 : playbackUrl.includes("?")) ? "&" : "?";
    return `${playbackUrl}${querySeparator}${queryParamsString}`;
};
const get9NowPlaybackData = async (channelSlug, region)=>{
    console.log("[acc] Channel slug is", channelSlug);
    const matchingChannel = await get9NowLiveChannel(channelSlug, region);
    if (matchingChannel) {
        const playbackUrl = getChannelSourceUrl(matchingChannel);
        (0, _messengers.Messengers).streamReady$.send(matchingChannel);
        return {
            sourceUrl: playbackUrl
        };
    }
    throw new (0, _providerUtils.MLEError)("Could not find matching live object ", (0, _providerUtils.ErrorTypes).PROVIDER);
// no try catch, handle errors in parent
};
const getAndStoreConfig = async ()=>{
    await fetch(`${(0, _nineStore.Store).apiConfig.apiBaseUrl}/accedo-support-api/v2/config/ctv_foxtel/config.json?device=ctv_foxtel`).then((res)=>res.json()).then((res)=>(0, _nineStore.Store).appConfig = res).catch(()=>{
        console.log("[acc] WARNING: Invalid nine API app config request.");
    });
};
const getApiRegion = async (accessToken, isRetryWithoutAccessToken = false)=>{
    const regionUrl = (0, _nineStore.Store).apiConfig.regionServiceUrl;
    const requestUrl = isRetryWithoutAccessToken ? regionUrl : `${regionUrl}?token=${accessToken}`;
    try {
        const regionRequest = await fetch(requestUrl);
        const regionResponse = await regionRequest.json();
        return regionResponse.value;
    } catch (e) {
        if (isRetryWithoutAccessToken) console.warn("Could not get region from api -> Using fallback");
        else {
            console.warn("Could not get region with access_token -> Attempting without access_token");
            return await getApiRegion(accessToken, true);
        }
    }
};

},{"../../provider-utils":"jTFkH","../helpers/Messengers":"48YTm","../helpers/nine-store":"d7nPH","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"2EaaP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "refreshAuth", ()=>refreshAuth);
var _providerUtils = require("../../provider-utils");
var _nineStore = require("../helpers/nine-store");
const refreshAuth = async (refreshToken, oldNuid, retryCount = 0)=>{
    var _Store_appConfig;
    const maxRetries = 2;
    const refreshUrl = `${(0, _nineStore.Store).apiConfig.loginUrl}/api/device/refresh-token?refresh_token=${refreshToken}&client_id=${(_Store_appConfig = (0, _nineStore.Store).appConfig) === null || _Store_appConfig === void 0 ? void 0 : _Store_appConfig.clientId}`;
    try {
        var _Store_appConfig1;
        const refreshRequest = await fetch(refreshUrl, {
            method: "POST"
        });
        if (!refreshRequest.ok) throw new (0, _providerUtils.MLEError)("Invalid refresh response.", (0, _providerUtils.ErrorTypes).PROVIDER, refreshRequest.status);
        const refreshResponse = await refreshRequest.json();
        (0, _nineStore.Store).accessToken = refreshResponse.access_token;
        const nuidRequest = await fetch(`${(0, _nineStore.Store).apiConfig.nuidUrl}/?client_id=${(_Store_appConfig1 = (0, _nineStore.Store).appConfig) === null || _Store_appConfig1 === void 0 ? void 0 : _Store_appConfig1.clientId}&token=${refreshResponse.access_token}&device_id=ctv_foxtel&nuid=${oldNuid}`);
        if (!nuidRequest.ok) throw new (0, _providerUtils.MLEError)("Invalid refresh response.", (0, _providerUtils.ErrorTypes).PROVIDER, nuidRequest.status);
        const nuidResponse = await nuidRequest.json();
        retryCount = 0;
        (0, _nineStore.Store).nuid = nuidResponse.nuid;
        try {
            // do not await, we don't care about the response
            (0, _providerUtils.setTokenInDeviceStorage)("au.com.nine", btoa(JSON.stringify({
                nuid: (0, _nineStore.Store).nuid,
                refresh_token: refreshToken
            }))).then((response)=>{
                if (!response.ok || response.status !== 200) console.warn("[acc] Could not update sky auth tokens", response);
            });
        } catch (err) {
            console.warn("[acc] Could not update sky auth tokens", err);
        }
        // Timeout expires roughly every five minutes and starts the refresh Auth process again.
        const refreshAuthExpiry = window.setTimeout(async ()=>{
            refreshAuth(refreshToken, (0, _nineStore.Store).nuid);
            window.clearTimeout(refreshAuthExpiry);
        }, refreshResponse.expiresIn * 1000);
    } catch (err) {
        if (retryCount < maxRetries) return await refreshAuth(refreshToken, oldNuid, retryCount + 1);
        else {
            console.warn("[acc] Authentication refresh failed, throwing error");
            throw new (0, _providerUtils.MLEError)(err.message, (0, _providerUtils.ErrorTypes).AUTH, err.status);
        }
    }
};

},{"../../provider-utils":"jTFkH","../helpers/nine-store":"d7nPH","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"kDaqD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _defineProperty = require("@swc/helpers/_/_define_property");
var _objectSpread = require("@swc/helpers/_/_object_spread");
var _objectSpreadProps = require("@swc/helpers/_/_object_spread_props");
var _nineStore = require("../helpers/nine-store");
var _utils = require("../helpers/utils");
var _messengers = require("../helpers/Messengers");
const CATEGORY = "9Now-FoxtelMLE";
class AdobeAnalyticsClient {
    constructor(){
        (0, _defineProperty._)(this, "service", null);
        (0, _defineProperty._)(this, "configuration", {
            clientSid: "msnportalaucatmobile",
            trackingServer: "somni.nine.com.au",
            ssl: true,
            appVersion: (0, _nineStore.Store).appVersion,
            userAgent: navigator.userAgent
        });
        (0, _defineProperty._)(this, "videoContentStarted", false);
        (0, _defineProperty._)(this, "videoTime", 0);
        (0, _defineProperty._)(this, "channelData", null);
        (0, _defineProperty._)(this, "currentAd", null);
        (0, _defineProperty._)(this, "adBreakOngoing", false);
        (0, _defineProperty._)(this, "listeners", []);
        (0, _defineProperty._)(this, "init", async ()=>{
            const { clientSid, trackingServer, ssl } = this.configuration;
            if (!window.s_gi) {
                console.warn("[acc] No adobe analytics library loaded");
                return;
            }
            this.service = window.s_gi(clientSid);
            if (this.service) {
                this.service.trackingServer = trackingServer;
                this.service.trackingServerSecure = trackingServer;
                this.service.ssl = ssl;
                this.service.debugTracking = false;
                this.service.pageName = `${CATEGORY}/${this.configuration.appVersion}`;
            }
            console.log("[acc] Adobe Analytics: configured", this.configuration);
            this.removeEventListeners(); // in case monitoringTeardown isn't called
            this.addEventListeners();
        });
        (0, _defineProperty._)(this, "addEventListeners", ()=>{
            this.listeners = [
                ...this.listeners,
                (0, _messengers.Messengers).appTeardown$.addReceiver(this.onAppTeardown),
                (0, _messengers.Messengers).streamReady$.addReceiver(this.onFirstStreamReady),
                (0, _messengers.Messengers).playerState$.addReceiver(this.videoContentStartEvent),
                (0, _messengers.Messengers).currentAd$.addReceiver(this.adBreakEvent),
                (0, _messengers.Messengers).timeUpdate$.addReceiver(this.onUpdateTime),
                (0, _messengers.Messengers).programChange$.addReceiver(this.onProgramChange)
            ];
        });
        (0, _defineProperty._)(this, "removeEventListeners", ()=>{
            this.listeners.forEach((receiver)=>receiver.unlisten());
            this.listeners = [];
        });
        (0, _defineProperty._)(this, "onAppTeardown", ()=>{
            this.removeEventListeners();
            this.videoContentStarted = false;
            this.adBreakOngoing = false;
            this.videoTime = 0;
            this.channelData = null;
            this.currentAd = null;
        });
        (0, _defineProperty._)(this, "dispatchAdobeAnalyticsEvent", (eventType, contextData)=>{
            if (this.service) {
                this.service.pev2 = `AMACTION:${eventType}`;
                this.service.contextData = contextData;
                this.service.t();
            }
        });
        (0, _defineProperty._)(this, "onFirstStreamReady", (channelData)=>{
            this.channelData = channelData;
            // reset so new events go through
            this.videoContentStarted = false;
            this.currentAd = null;
            this.adBreakOngoing = false;
            this.videoTime = 0;
        });
        (0, _defineProperty._)(this, "onProgramChange", (channelData)=>{
            this.channelData = channelData;
        });
        (0, _defineProperty._)(this, "videoContentStartEvent", (playerState)=>{
            this.clearEventData();
            if (this.channelData && playerState === (0, _utils.PlayerStates).Playing && !this.videoContentStarted) {
                var _Store_appConfig;
                let slug = this.channelData.slug;
                if (slug === "channel-9") slug = "ch9";
                const id = this.channelData.listings[0].id;
                // Gen fresh nuid on every event, since nuid can change overtime
                const nuid = (0, _nineStore.Store).nuid || "";
                const state = (0, _nineStore.Store).region;
                const eventType = "content_video_start";
                const contextData = {
                    "video.video_display": "local",
                    "video.device_orientation": "landscape",
                    "nuid.id": nuid,
                    "cid.nuid.id": nuid,
                    "cid.nuid.as": 1,
                    "video.vms_id": `live-${slug}-syd-ssai`,
                    "video.video_id": id,
                    "video.brightcove_account_id": ((_Store_appConfig = (0, _nineStore.Store).appConfig) === null || _Store_appConfig === void 0 ? void 0 : _Store_appConfig.brightcove.accountId) || "",
                    "video.event_type": eventType,
                    "video.contentvideo_current_time": this.videoTime,
                    "video.video_title": `${CATEGORY}|live|${slug}|${state}`,
                    "video.page_name": `livetv|${state}`
                };
                this.dispatchAdobeAnalyticsEvent(eventType, contextData);
                this.videoContentStarted = true;
            }
        });
        (0, _defineProperty._)(this, "updateAdContextData", (contextData, ad)=>{
            var _ad_adBreakDuration;
            const newContextData = (0, _objectSpreadProps._)((0, _objectSpread._)({}, contextData), {
                "video.video_id": (ad === null || ad === void 0 ? void 0 : ad.adId) || "-1",
                "video.ad_break_index": (ad === null || ad === void 0 ? void 0 : ad.adBreakId) || "-1",
                "video.ad_break_duration": (ad === null || ad === void 0 ? void 0 : (_ad_adBreakDuration = ad.adBreakDuration) === null || _ad_adBreakDuration === void 0 ? void 0 : _ad_adBreakDuration.toString()) || "-1"
            });
            return newContextData;
        });
        (0, _defineProperty._)(this, "adBreakEvent", (currentAd)=>{
            const previousAd = this.currentAd;
            this.currentAd = currentAd;
            if (this.channelData) {
                var _Store_appConfig;
                let slug = this.channelData.slug;
                if (slug === "channel-9") slug = "ch9";
                const nuid = (0, _nineStore.Store).nuid || "";
                const state = (0, _nineStore.Store).region;
                let eventType = "";
                let contextData = {
                    "video.video_display": "local",
                    "video.device_orientation": "landscape",
                    "nuid.id": nuid,
                    "cid.nuid.id": nuid,
                    "cid.nuid.as": 1,
                    "video.vms_id": `live-${slug}-syd-ssai`,
                    "video.video_id": "-1",
                    "video.brightcove_account_id": ((_Store_appConfig = (0, _nineStore.Store).appConfig) === null || _Store_appConfig === void 0 ? void 0 : _Store_appConfig.brightcove.accountId) || "",
                    "video.event_type": "",
                    "video.contentvideo_current_time": this.videoTime.toString(),
                    "video.video_title": `${CATEGORY}|live|${slug}|${state}`,
                    "video.page_name": `livetv|${state}`,
                    "video.ad_break_index": "-1",
                    "video.ad_break_duration": "-1",
                    "video.ad_break_type": "midroll"
                };
                if (!this.adBreakOngoing && this.currentAd !== null) {
                    eventType = "ad_break_started";
                    contextData = this.updateAdContextData(contextData, currentAd);
                    this.adBreakOngoing = true;
                } else if (this.adBreakOngoing && this.currentAd) {
                    eventType = "ad_break_ended";
                    contextData["video.event_type"] = eventType;
                    contextData["video.contentvideo_current_time"] = this.videoTime.toString();
                    contextData = this.updateAdContextData(contextData, previousAd);
                    this.dispatchAdobeAnalyticsEvent(eventType, contextData);
                    contextData = this.updateAdContextData(contextData, currentAd);
                    eventType = "ad_break_started";
                } else if (this.adBreakOngoing && this.currentAd == null) {
                    eventType = "ad_break_ended";
                    contextData = this.updateAdContextData(contextData, previousAd);
                    this.adBreakOngoing = false;
                }
                contextData["video.event_type"] = eventType;
                contextData["video.contentvideo_current_time"] = this.videoTime.toString();
                this.dispatchAdobeAnalyticsEvent(eventType, contextData);
            }
        });
        (0, _defineProperty._)(this, "onUpdateTime", (time)=>{
            this.videoTime = Math.round(time);
        });
        (0, _defineProperty._)(this, "clearEventData", ()=>{
            if (this.service) {
                // clear global specific values
                this.service.pev2 = "";
                // clear context data
                this.service.contextData = {};
            }
        });
    }
}
exports.default = new AdobeAnalyticsClient();

},{"@swc/helpers/_/_define_property":"9kWBJ","@swc/helpers/_/_object_spread":"lupAG","@swc/helpers/_/_object_spread_props":"8Y68S","../helpers/nine-store":"d7nPH","../helpers/utils":"lhCx6","../helpers/Messengers":"48YTm","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"8Y68S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_object_spread_props", ()=>_object_spread_props);
parcelHelpers.export(exports, "_", ()=>_object_spread_props);
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    else ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
    return target;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"he4KR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _defineProperty = require("@swc/helpers/_/_define_property");
var _nineStore = require("../helpers/nine-store");
var _messengers = require("../helpers/Messengers");
var _utils = require("../helpers/utils");
const CATEGORY = "9Now-FoxtelMLE";
const COMPANY = "ninenow";
class AdobeAudienceManagerClient {
    constructor(){
        (0, _defineProperty._)(this, "service", null);
        (0, _defineProperty._)(this, "configuration", {
            deviceId: (0, _nineStore.Store).deviceId,
            appVersion: (0, _nineStore.Store).appVersion,
            userAgent: navigator.userAgent
        });
        (0, _defineProperty._)(this, "channelData", null);
        (0, _defineProperty._)(this, "videoContentStarted", false);
        (0, _defineProperty._)(this, "listeners", []);
        (0, _defineProperty._)(this, "init", async ()=>{
            if (!window.DIL) {
                console.warn("No adobe audience manager library loaded");
                return;
            }
            this.service = window.DIL.create({
                partner: "nd",
                uuidCookie: {
                    name: "",
                    days: 30
                }
            });
            this.removeEventListeners(); // in case monitoringTeardown isn't called
            this.addEventListeners();
        });
        (0, _defineProperty._)(this, "addEventListeners", ()=>{
            this.listeners = [
                ...this.listeners,
                (0, _messengers.Messengers).appTeardown$.addReceiver(this.removeEventListeners),
                (0, _messengers.Messengers).streamReady$.addReceiver(this.onFirstStreamReady, true),
                (0, _messengers.Messengers).playerState$.addReceiver(this.videoPlaybackEvent, true),
                (0, _messengers.Messengers).programChange$.addReceiver(this.onProgramChange)
            ];
        });
        (0, _defineProperty._)(this, "removeEventListeners", ()=>{
            this.listeners.forEach((receiver)=>receiver.unlisten());
            this.listeners = [];
        });
        (0, _defineProperty._)(this, "onFirstStreamReady", (channelData)=>{
            this.channelData = channelData;
            // reset session
            this.videoContentStarted = false;
        });
        (0, _defineProperty._)(this, "onProgramChange", (channelData)=>{
            this.channelData = channelData;
        });
        (0, _defineProperty._)(this, "videoPlaybackEvent", (playerState)=>{
            if (this.shouldSendRequest() && this.channelData && playerState === (0, _utils.PlayerStates).Playing && !this.videoContentStarted) {
                var _this_channelData, _this_channelData1, _Store_appConfig;
                this.setCID();
                let slug = (_this_channelData = this.channelData) === null || _this_channelData === void 0 ? void 0 : _this_channelData.slug;
                if (slug === "channel-9") slug = "ch9";
                const site = "livetv";
                const hierarchy = `${CATEGORY}|livetv|${(0, _nineStore.Store).region};${slug}`;
                const section = hierarchy.replace("|", ":");
                const channel = `${CATEGORY}:${site}`;
                const payload = {
                    app_version: this.configuration.appVersion,
                    is_user_logged_in: "1",
                    user_agent: this.configuration.userAgent,
                    company: COMPANY,
                    hierarchy: hierarchy,
                    site: site,
                    section: section,
                    channel: channel,
                    page_name: section,
                    category: CATEGORY,
                    event_type: "content_video_start",
                    video_title: `${CATEGORY}|live|${slug}|${(0, _nineStore.Store).region}`,
                    video_id: (_this_channelData1 = this.channelData) === null || _this_channelData1 === void 0 ? void 0 : _this_channelData1.listings[0].id,
                    brightcove_account_id: ((_Store_appConfig = (0, _nineStore.Store).appConfig) === null || _Store_appConfig === void 0 ? void 0 : _Store_appConfig.brightcove.accountId) || "",
                    vms_id: `live-${slug}-syd-ssai`
                };
                if (this.service) {
                    this.service.api.signals(payload, "c_video_");
                    this.service.api.submit();
                }
                this.videoContentStarted = true;
            }
        });
        (0, _defineProperty._)(this, "shouldSendRequest", ()=>{
            return !!(0, _nineStore.Store).nuid;
        });
        (0, _defineProperty._)(this, "setCID", ()=>{
            const { deviceId } = this.configuration;
            const separator = decodeURIComponent("%01");
            const nuid = (0, _nineStore.Store).nuid;
            const cid = {
                cid: `${encodeURIComponent("154549") + separator + encodeURIComponent(deviceId) + separator}1`
            };
            if (nuid) cid.cid_ic = `${encodeURIComponent("nuid") + separator + encodeURIComponent(nuid) + separator}1`;
            if (this.service) this.service.api.signals(cid, "d_");
        });
    }
}
exports.default = new AdobeAudienceManagerClient();

},{"@swc/helpers/_/_define_property":"9kWBJ","../helpers/nine-store":"d7nPH","../helpers/Messengers":"48YTm","../helpers/utils":"lhCx6","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"dDF9x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _defineProperty = require("@swc/helpers/_/_define_property");
var _oztamClient = require("./OztamClient");
var _nineStore = require("../helpers/nine-store");
var _utils = require("../helpers/utils");
var _messengers = require("../helpers/Messengers");
const OztamBaseUrl = (0, _nineStore.Store).useProdConfig ? "https://deliver.oztam.com.au/api/meter" : "https://sdeliver.oztam.com.au/api/meter";
const PROGRESS_INTERVAL_SECONDS = 60;
const SESSION_UPDATER_TIMER_SECONDS = 600;
class OztamBridge {
    constructor(){
        (0, _defineProperty._)(this, "client", null);
        (0, _defineProperty._)(this, "currentTime", -1);
        (0, _defineProperty._)(this, "sessionStarted", false);
        (0, _defineProperty._)(this, "currentAd", null);
        (0, _defineProperty._)(this, "playerState", (0, _utils.PlayerStates).Initialising);
        (0, _defineProperty._)(this, "progressInterval", 0);
        (0, _defineProperty._)(this, "sessionStartedInAdBreak", false);
        (0, _defineProperty._)(this, "isAppHiddenFromView", false);
        // session 10 minute pause
        (0, _defineProperty._)(this, "sessionRefreshHandler", null);
        (0, _defineProperty._)(this, "justRegeneratedSessionId", false);
        // when tuning to a channel with parental PIN we will
        // get hidden true then false after the LOAD event has
        // been fired. In that case do not resend the LOAD event
        // unless the session updater has run
        (0, _defineProperty._)(this, "hasStartedTrackingProgressDuringAppLaunch", false);
        (0, _defineProperty._)(this, "listeners", []);
        (0, _defineProperty._)(this, "init", ()=>{
            this.removeEventListeners(); // in case monitoringTeardown isn't called
            this.addListeners();
        });
        (0, _defineProperty._)(this, "addListeners", ()=>{
            this.listeners = [
                ...this.listeners,
                (0, _messengers.Messengers).playerState$.addReceiver(this.onPlayerStateChange, true),
                (0, _messengers.Messengers).streamReady$.addReceiver(this.onChannelDataReceived, true),
                (0, _messengers.Messengers).timeUpdate$.addReceiver(this.onTimeUpdate),
                (0, _messengers.Messengers).currentAd$.addReceiver(this.onAdChange),
                (0, _messengers.Messengers).playerError$.addReceiver(this.onAppErrored),
                (0, _messengers.Messengers).appTeardown$.addReceiver(this.onAppTeardown),
                (0, _messengers.Messengers).appHiddenWithoutAudio$.addReceiver(this.onAppHidden),
                (0, _messengers.Messengers).oztamSessionId$.addReceiver(this.onSessionIdChange)
            ];
        });
        (0, _defineProperty._)(this, "removeEventListeners", ()=>{
            this.listeners.forEach((receiver)=>receiver.unlisten());
            this.listeners = [];
        });
        (0, _defineProperty._)(this, "onChannelDataReceived", (channelData)=>{
            if (channelData) {
                var _listings_, _listings_1, _listings_2, _listings_3, _listings_4, _listings_5;
                const { oztamPublisherId, listings, name: channelName } = channelData;
                const userId = (0, _nineStore.Store).nuid || "empty";
                const oztamStaticConfig = {
                    vendorVersion: (0, _nineStore.Store).getOztamVendorVersion(),
                    connectionType: (0, _nineStore.Store).deviceNetworkConnection,
                    deviceId: (0, _nineStore.Store).deviceId,
                    userId: userId,
                    baseUrl: OztamBaseUrl
                };
                const oztamStreamConfig = {
                    eventIdentificationData: {
                        publisherId: oztamPublisherId,
                        mediaId: listings[0].materialKey || "empty",
                        mediaDuration: 0,
                        mediaType: "live",
                        demo1: userId
                    },
                    streamMetadata: {
                        channel: channelName,
                        classification: ((_listings_ = listings[0]) === null || _listings_ === void 0 ? void 0 : _listings_.classification) || "empty",
                        seriesId: ((_listings_1 = listings[0]) === null || _listings_1 === void 0 ? void 0 : _listings_1.id) || "empty",
                        seriesName: ((_listings_2 = listings[0]) === null || _listings_2 === void 0 ? void 0 : _listings_2.name) || "empty",
                        episodeId: ((_listings_3 = listings[0]) === null || _listings_3 === void 0 ? void 0 : _listings_3.id) || "empty",
                        episodeName: ((_listings_4 = listings[0]) === null || _listings_4 === void 0 ? void 0 : _listings_4.episodeTitle) || "empty",
                        genre: ((_listings_5 = listings[0]) === null || _listings_5 === void 0 ? void 0 : _listings_5.genre) || "empty",
                        programName: "",
                        usr1: "live_page"
                    }
                };
                if (!this.client) this.client = new (0, _oztamClient.OzTamClient)((0, _messengers.Messengers).oztamSessionId$.getCurrentValue());
                this.client.init(oztamStaticConfig, oztamStreamConfig);
                this.client.loadEvent();
            }
        });
        (0, _defineProperty._)(this, "onTimeUpdate", (time)=>{
            this.currentTime = time;
            if (!this.sessionStarted) this.tryToBegin();
        });
        (0, _defineProperty._)(this, "onPlayerStateChange", (playerState)=>{
            const previousState = this.playerState;
            this.playerState = playerState;
            if (this.isAppHiddenFromView) return;
            if (playerState === (0, _utils.PlayerStates).Playing && previousState !== (0, _utils.PlayerStates).Playing) {
                if (!this.currentAd && this.sessionStarted) {
                    var _this_client;
                    // Resume playing content after pause, seek etc
                    console.log("[acc] oztam resumed");
                    this.startProgressInterval();
                    (_this_client = this.client) === null || _this_client === void 0 ? void 0 : _this_client.setPositionForResume();
                }
                if (this.justRegeneratedSessionId) {
                    // first playing event after regenerate -> send load & begin
                    this.justRegeneratedSessionId = false;
                    this.client.loadEvent();
                    this.tryToBegin();
                } else if (!this.sessionStarted) // if start in ad break let ad begin event go first
                this.tryToBegin();
            }
            // Log progress from last interval to when stream was paused
            // or seeked, buffering
            if (playerState !== (0, _utils.PlayerStates).Playing && previousState === (0, _utils.PlayerStates).Playing && !this.currentAd && this.sessionStarted) {
                var _this_client1;
                console.log("[acc] oztam no longer playing");
                (_this_client1 = this.client) === null || _this_client1 === void 0 ? void 0 : _this_client1.progressEvent();
                this.clearProgressInterval();
                this.clearProgressInterval();
                this.setupSessionUpdater();
            }
        });
        (0, _defineProperty._)(this, "onAdChange", (currentAd)=>{
            const prevAd = this.currentAd;
            this.currentAd = currentAd;
            if (this.isAppHiddenFromView) return;
            if (!prevAd && !!this.currentAd) {
                // AD BREAK START
                if (!this.sessionStarted) this.tryToBegin();
                else {
                    var _this_client, _this_client1;
                    (_this_client = this.client) === null || _this_client === void 0 ? void 0 : _this_client.progressEvent();
                    (_this_client1 = this.client) === null || _this_client1 === void 0 ? void 0 : _this_client1.adBeginEvent();
                    this.clearProgressInterval();
                }
            } else if (prevAd && this.currentAd) {
                var // AD CHANGE IN BREAK
                _this_client2, _this_client3, _this_client4;
                (_this_client2 = this.client) === null || _this_client2 === void 0 ? void 0 : _this_client2.adCompleteEvent();
                (_this_client3 = this.client) === null || _this_client3 === void 0 ? void 0 : _this_client3.progressEvent();
                (_this_client4 = this.client) === null || _this_client4 === void 0 ? void 0 : _this_client4.adBeginEvent();
            } else if (prevAd && !this.currentAd) {
                var // AD BREAK END
                _this_client5, _this_client6;
                (_this_client5 = this.client) === null || _this_client5 === void 0 ? void 0 : _this_client5.adCompleteEvent();
                (_this_client6 = this.client) === null || _this_client6 === void 0 ? void 0 : _this_client6.progressEvent();
                this.startProgressInterval();
            }
        });
        (0, _defineProperty._)(this, "tryToBegin", (restartExistingSession = false)=>{
            if (this.isAppHiddenFromView || this.playerState !== (0, _utils.PlayerStates).Playing || this.currentTime <= 0) return;
            if (!this.sessionStarted || restartExistingSession) {
                var _this_client;
                if (!restartExistingSession) (_this_client = this.client) === null || _this_client === void 0 ? void 0 : _this_client.beginEvent();
                if (!!this.currentAd) this.client.adBeginEvent();
                else this.startProgressInterval();
                this.sessionStarted = true;
            }
        });
        (0, _defineProperty._)(this, "onAppHidden", (isHidden)=>{
            if (this.isAppHiddenFromView === isHidden) return;
            this.isAppHiddenFromView = isHidden;
            console.log("[acc] change hidden state in oztam", isHidden);
            // change to hidden
            if (this.isAppHiddenFromView) {
                var // partial progress
                _this_client;
                if (this.sessionStarted && !this.currentAd) (_this_client = this.client) === null || _this_client === void 0 ? void 0 : _this_client.progressEvent();
                this.clearProgressInterval();
                if (this.sessionStarted || !this.hasStartedTrackingProgressDuringAppLaunch) this.setupSessionUpdater();
            } else {
                // change to foreground
                if (!this.sessionStarted) {
                    var // Only send load event if we've already tracked and are re-starting
                    // a session
                    // Handles case where load event fired on startup and then
                    // again when hidden set to false
                    _this_client1;
                    // probably was hidden long enough to regenerate session ID
                    if (this.hasStartedTrackingProgressDuringAppLaunch) (_this_client1 = this.client) === null || _this_client1 === void 0 ? void 0 : _this_client1.loadEvent();
                    // begin as new session
                    this.tryToBegin();
                } else {
                    var // un-hidden within same session, try to begin means starting
                    // again in ad break or content, pass true to bypass begin event
                    _this_client2;
                    (_this_client2 = this.client) === null || _this_client2 === void 0 ? void 0 : _this_client2.setPositionForResume();
                    this.tryToBegin(true);
                }
                this.clearSessionUpdater();
            }
        });
        (0, _defineProperty._)(this, "clearSessionUpdater", ()=>{
            if (this.sessionRefreshHandler) {
                console.log("[acc] oztam clear updater...");
                clearTimeout(this.sessionRefreshHandler);
                this.sessionRefreshHandler = null;
            }
        });
        (0, _defineProperty._)(this, "setupSessionUpdater", ()=>{
            this.clearSessionUpdater();
            console.log("[acc] oztam setting up updater...");
            this.sessionRefreshHandler = window.setTimeout(()=>{
                // should be cleared if we are unpaused or setting pro
                console.log("[acc] oztam updater updating Session ID!!");
                (0, _messengers.Messengers).oztamSessionId$.send((0, _utils.generateUUID)());
                this.justRegeneratedSessionId = true;
                this.sessionStarted = false;
                // set this flag so we send out another load event
                // with updated session id
                // in case we are hidden and transition to foreground
                this.hasStartedTrackingProgressDuringAppLaunch = true;
            }, SESSION_UPDATER_TIMER_SECONDS * 1000);
        });
        (0, _defineProperty._)(this, "onSessionIdChange", (sessionId)=>{
            var _this_client;
            (_this_client = this.client) === null || _this_client === void 0 ? void 0 : _this_client.setSessionID(sessionId);
        });
        (0, _defineProperty._)(this, "startProgressInterval", ()=>{
            this.clearProgressInterval();
            this.clearSessionUpdater();
            this.hasStartedTrackingProgressDuringAppLaunch = true;
            this.progressInterval = window.setInterval(()=>{
                var _this_client;
                (_this_client = this.client) === null || _this_client === void 0 ? void 0 : _this_client.progressEvent();
            }, PROGRESS_INTERVAL_SECONDS * 1000);
        });
        (0, _defineProperty._)(this, "onAppTeardown", ()=>{
            var _this_client, _this_client1;
            if (!this.isAppHiddenFromView && !this.currentAd) (_this_client = this.client) === null || _this_client === void 0 ? void 0 : _this_client.progressEvent();
            (_this_client1 = this.client) === null || _this_client1 === void 0 ? void 0 : _this_client1.setPositionForResume(0);
            this.clearProgressInterval();
            this.clearSessionUpdater();
            // reset session ID after but before listener is
            // removed that sets on client
            (0, _messengers.Messengers).oztamSessionId$.send((0, _utils.generateUUID)());
            this.removeEventListeners();
            this.sessionStarted = false;
            this.isAppHiddenFromView = false;
            this.justRegeneratedSessionId = false;
            this.currentTime = -1;
            this.currentAd = null;
            this.playerState = (0, _utils.PlayerStates).Initialising;
            this.hasStartedTrackingProgressDuringAppLaunch = false;
        });
        (0, _defineProperty._)(this, "onAppErrored", ()=>{
            var _this_client;
            (_this_client = this.client) === null || _this_client === void 0 ? void 0 : _this_client.progressEvent();
            this.clearProgressInterval();
            this.clearSessionUpdater();
        });
        (0, _defineProperty._)(this, "clearProgressInterval", ()=>{
            clearInterval(this.progressInterval);
        });
    }
}
exports.default = new OztamBridge();

},{"@swc/helpers/_/_define_property":"9kWBJ","./OztamClient":"2SUJv","../helpers/nine-store":"d7nPH","../helpers/utils":"lhCx6","../helpers/Messengers":"48YTm","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"2SUJv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OzTamClient", ()=>OzTamClient);
var _defineProperty = require("@swc/helpers/_/_define_property");
var _objectSpread = require("@swc/helpers/_/_object_spread");
var _objectSpreadProps = require("@swc/helpers/_/_object_spread_props");
var _utils = require("../helpers/utils");
const roundPosition = (pos)=>Math.round(pos * 10) / 10;
class OzTamClient {
    constructor(sessionId){
        (0, _defineProperty._)(this, "timezoneOffset", Math.abs(new Date().getTimezoneOffset()));
        (0, _defineProperty._)(this, "baseUrl", "");
        (0, _defineProperty._)(this, "oztamUserId", "");
        (0, _defineProperty._)(this, "vendorVersion", "");
        (0, _defineProperty._)(this, "deviceId", "");
        (0, _defineProperty._)(this, "connectionType", (0, _utils.NetworkConnectionType).UNKNOWN);
        (0, _defineProperty._)(this, "streamConfig", null);
        (0, _defineProperty._)(this, "lastStartPosition", 0);
        (0, _defineProperty._)(this, "eventDispatcherHandler", null);
        (0, _defineProperty._)(this, "sessionId", "<empty>");
        (0, _defineProperty._)(this, "isLive", true);
        (0, _defineProperty._)(this, "ptsEpochDifference", 0);
        (0, _defineProperty._)(this, "stopRecordingEvents", false);
        (0, _defineProperty._)(this, "eventDispatchQueue", new (0, _utils.AsyncFunctionQueue)());
        (0, _defineProperty._)(this, "setSessionID", (sessionId)=>{
            this.sessionId = sessionId;
        });
        (0, _defineProperty._)(this, "init", async (staticConfig, streamConfig)=>{
            this.baseUrl = staticConfig.baseUrl;
            if (staticConfig.userId) this.oztamUserId = staticConfig.userId;
            this.vendorVersion = staticConfig.vendorVersion;
            this.deviceId = staticConfig.deviceId;
            this.connectionType = staticConfig.connectionType;
            this.streamConfig = streamConfig;
        });
        (0, _defineProperty._)(this, "setPtsEpochDiff", (diff)=>{
            this.ptsEpochDifference = diff;
        });
        (0, _defineProperty._)(this, "loadEvent", ()=>{
            const position = new Date().getTime() / 1000;
            this.generateOztamEvent((0, _utils.OztamEventType).LOAD, position, position);
        });
        (0, _defineProperty._)(this, "beginEvent", ()=>{
            const currentTime = new Date().getTime() / 1000;
            this.currentPosition = currentTime;
            this.lastStartPosition = currentTime;
            this.generateOztamEvent((0, _utils.OztamEventType).BEGIN, this.currentPosition, this.currentPosition);
        });
        (0, _defineProperty._)(this, "completeEvent", (position)=>{
            this.generateOztamEvent((0, _utils.OztamEventType).COMPLETE, this.lastStartPosition, position);
            this.lastStartPosition = 0;
        });
        (0, _defineProperty._)(this, "setPositionForResume", ()=>{
            this.lastStartPosition = new Date().getTime() / 1000;
        });
        (0, _defineProperty._)(this, "progressEvent", ()=>{
            this.currentPosition = new Date().getTime() / 1000;
            this.generateOztamEvent((0, _utils.OztamEventType).PROGRESS, this.lastStartPosition, this.currentPosition);
        });
        (0, _defineProperty._)(this, "adBeginEvent", ()=>{
            this.currentPosition = new Date().getTime() / 1000;
            this.generateOztamEvent((0, _utils.OztamEventType).AD_BEGIN, this.currentPosition, this.currentPosition);
        });
        (0, _defineProperty._)(this, "adCompleteEvent", ()=>{
            this.currentPosition = new Date().getTime() / 1000;
            this.generateOztamEvent((0, _utils.OztamEventType).AD_COMPLETE, this.currentPosition, this.currentPosition);
        });
        (0, _defineProperty._)(this, "setStopRecordingEvents", (stop)=>{
            this.stopRecordingEvents = stop;
        });
        (0, _defineProperty._)(this, "generateOztamEvent", (eventType, fromPosition, toPosition)=>{
            if (this.stopRecordingEvents) return;
            const eventTimestamp = new Date();
            const event = {
                timestamp: eventTimestamp.toISOString(),
                event: eventType,
                fromPosition: 0,
                toPosition: 0
            };
            let boundedPosition = Math.max(0, toPosition);
            boundedPosition = Math.min(fromPosition + 60, boundedPosition);
            event.fromPosition = roundPosition(fromPosition);
            event.toPosition = roundPosition(boundedPosition);
            if (this.ptsEpochDifference) {
                event.toPosition = roundPosition(event.toPosition + this.ptsEpochDifference);
                event.timestamp = new Date(event.toPosition * 1000).toISOString();
            }
            const meterEvent = this.generateMeterEvent(event);
            this.sendEvent(meterEvent);
            if (!(eventType === (0, _utils.OztamEventType).AD_COMPLETE || eventType === (0, _utils.OztamEventType).AD_BEGIN)) this.lastStartPosition = this.currentPosition;
        });
        (0, _defineProperty._)(this, "generateMeterEvent", (oztamEvent)=>{
            if (!this.streamConfig) {
                console.error("[acc] video data required for ozTeam event");
                return null;
            }
            const { eventIdentificationData, streamMetadata } = this.streamConfig;
            // properties needed only for begin event
            const shouldAppendProperties = oztamEvent.event === (0, _utils.OztamEventType).BEGIN;
            const meterEvent = (0, _objectSpreadProps._)((0, _objectSpread._)({
                protocolVersion: "1.1.1",
                vendorVersion: this.vendorVersion,
                plugin: "native",
                timestamp: new Date().toISOString(),
                timezoneOffset: this.timezoneOffset,
                sessionId: this.sessionId,
                userAgent: {
                    deviceType: "tv"
                }
            }, eventIdentificationData), {
                events: [
                    oztamEvent
                ]
            });
            if (shouldAppendProperties) meterEvent.properties = (0, _objectSpread._)({
                connectionType: this.connectionType,
                deviceId: this.deviceId,
                demo1: this.oztamUserId
            }, streamMetadata);
            return meterEvent;
        });
        (0, _defineProperty._)(this, "sendEvent", (meterEvent)=>{
            this.eventDispatchQueue.pushFunction(async ()=>{
                await this._dispatchMeterEvent(meterEvent);
            });
        });
        (0, _defineProperty._)(this, "_dispatchMeterEvent", async (meterEvent)=>{
            if (!meterEvent) return;
            const options = {
                method: "POST",
                headers: {
                    Accept: "application/json",
                    "Content-Type": "application/json;charset=UTF-8"
                },
                body: JSON.stringify(meterEvent)
            };
            console.log(`[acc] Oztam dispatch meter event ${meterEvent.events[0].event} from ${meterEvent.events[0].fromPosition} to ${meterEvent.events[0].toPosition} diff ${meterEvent.events[0].toPosition - meterEvent.events[0].fromPosition}`);
            try {
                const oztamRequest = await fetch(this.baseUrl, options);
                if (!oztamRequest.ok) throw oztamRequest;
            } catch (error) {
                console.error(error);
            }
        });
        if (sessionId) this.sessionId = sessionId;
    }
}

},{"@swc/helpers/_/_define_property":"9kWBJ","@swc/helpers/_/_object_spread":"lupAG","@swc/helpers/_/_object_spread_props":"8Y68S","../helpers/utils":"lhCx6","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"doV6l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _defineProperty = require("@swc/helpers/_/_define_property");
var _messengers = require("../helpers/Messengers");
var _admanagementSdk = require("@yospace/admanagement-sdk");
var _yospaceTags = require("../helpers/yospace-tags");
var _utils = require("../helpers/utils");
// YoLog.setDebugFlags(DebugFlags.DEBUG_VALIDATION);
class LiveAAMPYospace {
    constructor(){
        (0, _defineProperty._)(this, "currentTime", -1);
        (0, _defineProperty._)(this, "listeners", []);
        (0, _defineProperty._)(this, "futureTags", []);
        (0, _defineProperty._)(this, "currentAdId", null);
        (0, _defineProperty._)(this, "playerState", (0, _utils.PlayerStates).Initialising);
        (0, _defineProperty._)(this, "hasPlayed", false);
        (0, _defineProperty._)(this, "session", null);
        (0, _defineProperty._)(this, "hasProcessedFirstTag", false);
        (0, _defineProperty._)(this, "adBreakContentBeginTimeout", null);
        (0, _defineProperty._)(this, "init", ()=>{
            this.removeListeners(); // remove in case monitoringTeardown isn't called
            this.addListeners();
        });
        (0, _defineProperty._)(this, "createSession", async (playbackUrl)=>{
            var _this_session;
            if (this.session) return;
            this.session = await (0, _admanagementSdk.SessionLive).create(playbackUrl, new (0, _admanagementSdk.SessionProperties)());
            return (_this_session = this.session) === null || _this_session === void 0 ? void 0 : _this_session.getPlaybackUrl();
        });
        (0, _defineProperty._)(this, "addListeners", ()=>{
            this.listeners = [
                ...this.listeners,
                (0, _messengers.Messengers).id3Metadata$.addReceiver(this.onID3TagReceived),
                (0, _messengers.Messengers).timeUpdate$.addReceiver(this.onTimeUpdate),
                (0, _messengers.Messengers).playerState$.addReceiver(this.onPlayerStateChange, true),
                (0, _messengers.Messengers).appTeardown$.addReceiver(this.onAppTeardown)
            ];
        });
        (0, _defineProperty._)(this, "removeListeners", ()=>{
            this.listeners.forEach((receiver)=>receiver.unlisten());
            this.listeners = [];
        });
        (0, _defineProperty._)(this, "onAppTeardown", ()=>{
            this.removeListeners();
            if (this.session) {
                var _this_session;
                (_this_session = this.session) === null || _this_session === void 0 ? void 0 : _this_session.shutdown();
                this.session = undefined;
            }
            this.currentTime = -1;
            this.listeners = [];
            this.futureTags = [];
            this.currentAdId = null;
            this.hasProcessedFirstTag = false;
            this.playerState = (0, _utils.PlayerStates).Initialising;
            this.hasPlayed = false;
        });
        (0, _defineProperty._)(this, "onID3TagReceived", (aampId3Data)=>{
            var _aampId3Data_detail;
            if (!((_aampId3Data_detail = aampId3Data.detail) === null || _aampId3Data_detail === void 0 ? void 0 : _aampId3Data_detail.presentationTime)) return;
            const { presentationTime, timeScale, data } = aampId3Data.detail;
            const id3TagTime = presentationTime / timeScale;
            const yospaceTagOrNull = (0, _yospaceTags.parseYospaceID3Tag)(data);
            this.futureTags.push({
                time: id3TagTime,
                tag: yospaceTagOrNull
            });
            // case where we enter the stream during an ad and get id3 events first. We assume if the
            // first id3 tag we get is an ad tag we are starting content in an ad break.
            // Otherwise analytics will get content progress events before we pass the ID3 start time
            // in futureTags below
            if (this.currentTime === -1 && yospaceTagOrNull && !this.currentAdId && !this.hasProcessedFirstTag) {
                var _this_futureTags_, _firstTag_adData;
                const firstTag = (_this_futureTags_ = this.futureTags[0]) === null || _this_futureTags_ === void 0 ? void 0 : _this_futureTags_.tag;
                this.currentAdId = firstTag === null || firstTag === void 0 ? void 0 : (_firstTag_adData = firstTag.adData) === null || _firstTag_adData === void 0 ? void 0 : _firstTag_adData.adId;
                console.log("[acc] !! got yospace tag before first time update, sending as ad start event");
                (0, _messengers.Messengers).currentAd$.send(this.currentAdId);
            }
            this.hasProcessedFirstTag = true;
        });
        (0, _defineProperty._)(this, "adIdsAreTheSame", (adId1, adId2)=>{
            return !adId1 && !adId2 || adId1 === adId2;
        });
        (0, _defineProperty._)(this, "onTimeUpdate", (currentTime)=>{
            var _this_futureTags_;
            if (currentTime < this.currentTime) {
                console.warn(`[acc] Went ${this.currentTime - currentTime} seconds back in time, this should not happen`);
                // arbitrary 5, if we seek back or reset for whatever reason, clear ad tags as who knows what's going on
                if (this.currentTime - currentTime > 5) {
                    console.warn("[acc] clearing ad tags...");
                    this.futureTags = [];
                }
            }
            this.currentTime = currentTime;
            while(((_this_futureTags_ = this.futureTags[0]) === null || _this_futureTags_ === void 0 ? void 0 : _this_futureTags_.time) < this.currentTime){
                var _nextTag_tag_adData, _nextTag_tag, _nextTag_tag1, _nextTag_tag2;
                // ad logic
                const nextTag = this.futureTags.shift();
                const nextAdId = (_nextTag_tag = nextTag.tag) === null || _nextTag_tag === void 0 ? void 0 : (_nextTag_tag_adData = _nextTag_tag.adData) === null || _nextTag_tag_adData === void 0 ? void 0 : _nextTag_tag_adData.adId;
                if (!this.adIdsAreTheSame(nextAdId, this.currentAdId)) (0, _messengers.Messengers).currentAd$.send(nextAdId || null);
                // yospace tag logic
                const yoAttributes = nextTag === null || nextTag === void 0 ? void 0 : (_nextTag_tag1 = nextTag.tag) === null || _nextTag_tag1 === void 0 ? void 0 : _nextTag_tag1.attributes;
                if (yoAttributes) {
                    var _this_session;
                    const metadata = (0, _admanagementSdk.TimedMetadata).createFromMetadata(yoAttributes.YMID, yoAttributes.YSEQ, yoAttributes.YTYP, Number(yoAttributes.YDUR), this.currentTime * 1000);
                    (_this_session = this.session) === null || _this_session === void 0 ? void 0 : _this_session.onTimedMetadata(metadata);
                }
                // ad break end logic
                const adData = (_nextTag_tag2 = nextTag.tag) === null || _nextTag_tag2 === void 0 ? void 0 : _nextTag_tag2.adData;
                if (adData) {
                    const isLastTagInAd = adData.currentFragNumberInAd === adData.totalFragsInAd && adData.tagPositionInFrag === "E";
                    if (isLastTagInAd) this.adBreakContentBeginTimeout = window.setTimeout(()=>{
                        // If there is another ad, we expect its starting id3 tag pretty
                        // much immediately after the previous ad's ending id3 tag.
                        // This timeout should be cleared when any new yospace tag is
                        // emitted (below)
                        // Arbitrary 1 seconds for the timer should be enough time +
                        // get an ad break ended event within a second accuracy
                        (0, _messengers.Messengers).currentAd$.send(null);
                    }, 1000);
                    else if (this.adBreakContentBeginTimeout) {
                        clearTimeout(this.adBreakContentBeginTimeout);
                        this.adBreakContentBeginTimeout = null;
                    }
                }
                this.currentAdId = nextAdId || null;
            }
        });
        (0, _defineProperty._)(this, "onPlayerStateChange", (playerState)=>{
            var _this_session;
            const prevState = this.playerState;
            this.playerState = playerState;
            if (this.playerState === (0, _utils.PlayerStates).Playing) {
                var _this_session1, _this_session2;
                if (!this.hasPlayed) {
                    var _this_session3;
                    (_this_session3 = this.session) === null || _this_session3 === void 0 ? void 0 : _this_session3.onPlayerEvent((0, _admanagementSdk.PlayerEvent).START, this.currentTime);
                    this.hasPlayed = true;
                } else if (prevState === (0, _utils.PlayerStates).Buffering) (_this_session1 = this.session) === null || _this_session1 === void 0 ? void 0 : _this_session1.onPlayerEvent((0, _admanagementSdk.PlayerEvent).CONTINUE, this.currentTime);
                else (_this_session2 = this.session) === null || _this_session2 === void 0 ? void 0 : _this_session2.onPlayerEvent((0, _admanagementSdk.PlayerEvent).RESUME, this.currentTime);
            } else if (this.playerState === (0, _utils.PlayerStates).Buffering) {
                if (prevState === (0, _utils.PlayerStates).Playing) (_this_session = this.session) === null || _this_session === void 0 ? void 0 : _this_session.onPlayerEvent((0, _admanagementSdk.PlayerEvent).STALL, this.currentTime);
            }
        });
    }
}
exports.default = new LiveAAMPYospace();

},{"@swc/helpers/_/_define_property":"9kWBJ","../helpers/Messengers":"48YTm","@yospace/admanagement-sdk":"BeLXq","../helpers/yospace-tags":"kOYtJ","../helpers/utils":"lhCx6","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"BeLXq":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
var _YoLog = require("2b18704a8f4d7b12");
exports.DEBUG_ALL = _YoLog.DEBUG_ALL;
exports.DEBUG_PLAYBACK = _YoLog.DEBUG_PLAYBACK;
exports.DEBUG_HTTP_REQUESTS = _YoLog.DEBUG_HTTP_REQUESTS;
exports.DEBUG_LIFECYCLE = _YoLog.DEBUG_LIFECYCLE;
exports.DEBUG_PARSING = _YoLog.DEBUG_PARSING;
exports.DEBUG_POLLING = _YoLog.DEBUG_POLLING;
exports.DEBUG_REPORTS = _YoLog.DEBUG_REPORTS;
exports.DEBUG_STATE_MACHINE = _YoLog.DEBUG_STATE_MACHINE;
exports.DEBUG_VALIDATION = _YoLog.DEBUG_VALIDATION;
exports.DebugFlags = _YoLog.DebugFlags;
exports.YoLog = _YoLog.YoLog;
var _AdBreak = require("96ed0005d0e061d6");
exports.AdBreak = _AdBreak.AdBreak;
exports.BreakType = _AdBreak.BreakType;
var _AdBreakEventHandler = require("622c52da52c08913");
exports.AdBreakEventHandler = _AdBreakEventHandler.AdBreakEventHandler;
var _AdVerification = require("2c2914bf21e5c17d");
exports.AdVerification = _AdVerification.AdVerification;
var _Advert = require("5ba73b7cdf4963ea");
exports.Advert = _Advert.Advert;
var _AdvertEventHandler = require("b206fc94ceb26bb1");
exports.AdvertEventHandler = _AdvertEventHandler.AdvertEventHandler;
exports.ViewableEvent = _AdvertEventHandler.ViewableEvent;
var _AdvertWrapper = require("c88a8cb36eb653a7");
exports.AdvertWrapper = _AdvertWrapper.AdvertWrapper;
var _AnalyticEventObserver = require("da3b2a3c032544c8");
exports.AnalyticEventObserver = _AnalyticEventObserver.AnalyticEventObserver;
var _CompanionCreative = require("3acf1d1f6326171a");
exports.CompanionCreative = _CompanionCreative.CompanionCreative;
var _Creative = require("99085b4b08664ccf");
exports.Creative = _Creative.Creative;
var _CreativeEventHandler = require("9b7a8b1589f132ac");
exports.CreativeEventHandler = _CreativeEventHandler.CreativeEventHandler;
var _IconClickFallbackImage = require("e473d7cac0b7761");
exports.IconClickFallbackImage = _IconClickFallbackImage.IconClickFallbackImage;
var _IndustryIcon = require("75cb80e4bcdcdc1a");
exports.IndustryIcon = _IndustryIcon.IndustryIcon;
var _InteractiveCreative = require("90b1b8cb00bab0b6");
exports.InteractiveCreative = _InteractiveCreative.InteractiveCreative;
var _LinearCreative = require("98096fe6756c6461");
exports.LinearCreative = _LinearCreative.LinearCreative;
var _NonLinearCreative = require("425603020f98b964");
exports.NonLinearCreative = _NonLinearCreative.NonLinearCreative;
var _PlaybackEventHandler = require("3030163d3c3b84f6");
exports.PlaybackEventHandler = _PlaybackEventHandler.PlaybackEventHandler;
exports.PlayerEvent = _PlaybackEventHandler.PlayerEvent;
exports.ViewSize = _PlaybackEventHandler.ViewSize;
var _PlaybackPolicy = require("b45f0dff1c662963");
exports.PlaybackPolicy = _PlaybackPolicy.PlaybackPolicy;
var _PlaybackPolicyHandler = require("ae3fae7a225e2a4b");
exports.PlaybackPolicyHandler = _PlaybackPolicyHandler.PlaybackPolicyHandler;
var _Session = require("29ad616cbefff6e8");
exports.PlaybackMode = _Session.PlaybackMode;
exports.Session = _Session.Session;
exports.SessionProperties = _Session.SessionProperties;
exports.SessionState = _Session.SessionState;
exports.SessionErrorCode = _Session.SessionErrorCode;
exports.CONNECTION_ERROR = _Session.CONNECTION_ERROR;
exports.CONNECTION_TIMEOUT = _Session.CONNECTION_TIMEOUT;
exports.MALFORMED_URL = _Session.MALFORMED_URL;
exports.UNKNOWN_FORMAT = _Session.UNKNOWN_FORMAT;
exports.NO_DVRLIVE = _Session.NO_DVRLIVE;
exports.FALLBACK_URL = _Session.FALLBACK_URL;
exports.INVALID_WINDOW = _Session.INVALID_WINDOW;
exports.PARTIAL_VMAP = _Session.PARTIAL_VMAP;
var _Constant = require("8a3beea14b8db8af");
exports.CAT_AD_BREAK_EVENTS = _Constant.CAT_AD_BREAK_EVENTS;
exports.CAT_TIMELINE_EVENTS = _Constant.CAT_TIMELINE_EVENTS;
var _Resource = require("33864c08079a9de2");
exports.Resource = _Resource.Resource;
exports.ResourceType = _Resource.ResourceType;
var _SessionDVRLive = require("d9c9ce91a061343e");
exports.SessionDVRLive = _SessionDVRLive.SessionDVRLive;
var _SessionLive = require("9474bf9ba2eecf29");
exports.SessionLive = _SessionLive.SessionLive;
var _SessionVOD = require("38549eae1e541167");
exports.SessionVOD = _SessionVOD.SessionVOD;
var _TimedMetadata = require("d102f9e1b79791ea");
exports.TimedMetadata = _TimedMetadata.TimedMetadata;
var _VASTProperty = require("13900b9f13f22b99");
exports.VASTProperty = _VASTProperty.VASTProperty;
var _VerificationEventHandler = require("48af4adf68001371");
exports.VerificationEventHandler = _VerificationEventHandler.VerificationEventHandler;

},{"2b18704a8f4d7b12":"9KS65","96ed0005d0e061d6":"8JE54","622c52da52c08913":"a7Gde","2c2914bf21e5c17d":"153sX","5ba73b7cdf4963ea":"h21pj","b206fc94ceb26bb1":"gTmyD","c88a8cb36eb653a7":"dVAhT","da3b2a3c032544c8":"8raP1","3acf1d1f6326171a":"lj3Py","99085b4b08664ccf":"fZ00L","9b7a8b1589f132ac":"jBmxg","e473d7cac0b7761":"cg5iB","75cb80e4bcdcdc1a":"heno1","90b1b8cb00bab0b6":"Ir4VY","98096fe6756c6461":"cZC7f","425603020f98b964":"1lIbj","3030163d3c3b84f6":"cPeeN","b45f0dff1c662963":"lIDzX","ae3fae7a225e2a4b":"f3eUj","29ad616cbefff6e8":"62muZ","8a3beea14b8db8af":"5j00o","33864c08079a9de2":"3iyI3","d9c9ce91a061343e":"hoOHl","9474bf9ba2eecf29":"4FieK","38549eae1e541167":"f2Ak4","d102f9e1b79791ea":"50n6I","13900b9f13f22b99":"kiVVI","48af4adf68001371":"eGK0f"}],"9KS65":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.YoLog = exports.DebugFlags = exports.DEBUG_VALIDATION = exports.DEBUG_STATE_MACHINE = exports.DEBUG_REPORTS = exports.DEBUG_POLLING = exports.DEBUG_PLAYBACK = exports.DEBUG_PARSING = exports.DEBUG_LIFECYCLE = exports.DEBUG_HTTP_REQUESTS = exports.DEBUG_ALL = void 0;
var _Logger = require("9953aa3b02de02e2");
var _Constant = require("4b943b7ec9aad6ca");
/*
 * COPYRIGHT 2020-2021 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 *
 */ /**
 * Enumeration of possible debug flags
 * @enum {number}
 * @category Enumerations
 */ var DebugFlags = exports.DebugFlags = Object.freeze({
    /** When set, traces server playback events */ DEBUG_PLAYBACK: 1,
    /** When set, traces SDK lifecycle */ DEBUG_LIFECYCLE: 2,
    /** When set, traces VMAP polling events */ DEBUG_POLLING: 4,
    /** When set, traces VMAP and VAST tracking reports */ DEBUG_REPORTS: 8,
    /** When set, traces state machine state */ DEBUG_STATE_MACHINE: 16,
    /** When set, traces HTTP requests and responses */ DEBUG_HTTP_REQUESTS: 32,
    /** When set, traces VAST and VMAP parsing events */ DEBUG_PARSING: 64,
    /** When set, traces validation statements */ DEBUG_VALIDATION: 128,
    /** When set, enables all trace options */ DEBUG_ALL: Number.MAX_SAFE_INTEGER
});
/** When set, traces server playback events
 * @deprecated Will be removed in 3.7.0.  Use DebugFlags instead
 * @category Debug Flags */ var DEBUG_PLAYBACK = exports.DEBUG_PLAYBACK = DebugFlags.DEBUG_PLAYBACK;
/** When set, traces SDK lifecycle
 * @deprecated Will be removed in 3.7.0.  Use DebugFlags instead
 * @category Debug Flags */ var DEBUG_LIFECYCLE = exports.DEBUG_LIFECYCLE = DebugFlags.DEBUG_LIFECYCLE;
/** When set, traces VMAP polling events
 * @deprecated Will be removed in 3.7.0.  Use DebugFlags instead
 * @category Debug Flags */ var DEBUG_POLLING = exports.DEBUG_POLLING = DebugFlags.DEBUG_POLLING;
/** When set, traces VMAP and VAST tracking reports
 * @deprecated Will be removed in 3.7.0.  Use DebugFlags instead
 * @category Debug Flags */ var DEBUG_REPORTS = exports.DEBUG_REPORTS = DebugFlags.DEBUG_REPORTS;
/** When set, traces state machine state
 * @deprecated Will be removed in 3.7.0.  Use DebugFlags instead
 * @category Debug Flags */ var DEBUG_STATE_MACHINE = exports.DEBUG_STATE_MACHINE = DebugFlags.DEBUG_STATE_MACHINE;
/** When set, traces HTTP requests and responses
 * @deprecated Will be removed in 3.7.0.  Use DebugFlags instead
 * @category Debug Flags */ var DEBUG_HTTP_REQUESTS = exports.DEBUG_HTTP_REQUESTS = DebugFlags.DEBUG_HTTP_REQUESTS;
/** When set, traces VAST and VMAP parsing events
 * @deprecated Will be removed in 3.7.0.  Use DebugFlags instead
 * @category Debug Flags */ var DEBUG_PARSING = exports.DEBUG_PARSING = DebugFlags.DEBUG_PARSING;
/** When set, traces validation statements
 * @deprecated Will be removed in 3.7.0.  Use DebugFlags instead
 * @category Debug Flags */ var DEBUG_VALIDATION = exports.DEBUG_VALIDATION = DebugFlags.DEBUG_VALIDATION;
/** When set, enables all trace options
 * @deprecated Will be removed in 3.7.0.  Use DebugFlags instead
 * @category Debug Flags */ var DEBUG_ALL = exports.DEBUG_ALL = DebugFlags.DEBUG_ALL;
/**
 * Logging class for the SDK, defining flags that conditionally switch categories of debugging trace statements.
 */ var YoLog = exports.YoLog = /*#__PURE__*/ function() {
    function YoLog() {}
    /**
   *        Sets a custom logging implementation
   * @param logger the custom logger
   */ YoLog.setLogger = function setLogger(logger) {
        YoLog.logger = logger;
    } /**
   *        Sets the debug flags, specified as an ORed list, as the list of enabled flags.
   *        By default, no flags are enabled.
   * @param {number} flags the debug flags to use for this session
   */ ;
    YoLog.setDebugFlags = function setDebugFlags(flags) {
        YoLog.debugflags = flags;
    } /**
   *        Get the debug flags, specified as an ORed list, as the list of enabled flags.
   *        By default, no flags are enabled.
   * @return {number} the debug flags in use for this session
   */ ;
    YoLog.getDebugFlags = function getDebugFlags() {
        return YoLog.debugflags;
    } /**
   * Conditionally logs the supplied message if the message category is defined and if *debug*
   * log level is defined.
    @param cat the category (debug flags)
   @param msg the trace message
   */ ;
    YoLog.d = function d(cat, msg) {
        if (YoLog.debugflags & cat) YoLog.logger.debug((0, _Constant.getLogTag)() + msg);
    } /**
   * Logs the supplied error message.
    @param msg the trace message
   */ ;
    YoLog.e = function e(msg) {
        YoLog.logger.error((0, _Constant.getLogTag)() + msg);
    } /**
   * Conditionally logs the supplied message if the message category is defined and if *information*
   * log level is defined.
    @param cat the category (debug flags)
   @param msg the trace message
   */ ;
    YoLog.i = function i(cat, msg) {
        if (YoLog.debugflags & cat) YoLog.logger.info((0, _Constant.getLogTag)() + msg);
    } /**
   * Conditionally logs the supplied warning message if *warning* log level is defined.
    @param msg the trace message
   */ ;
    YoLog.w = function w(msg) {
        YoLog.logger.warn((0, _Constant.getLogTag)() + msg);
    };
    YoLog.trace = function trace(msg) {
        YoLog.d(DebugFlags.DEBUG_VALIDATION, "[" + Date.now() + "][YoSDK:" + msg + "]");
    };
    return YoLog;
}();
YoLog.debugflags = 0;
YoLog.logger = _Logger.Logger;

},{"9953aa3b02de02e2":"ce8LW","4b943b7ec9aad6ca":"5j00o"}],"ce8LW":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.Logger = void 0;
/*
 * COPYRIGHT 2020-2021 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 *
 */ /*
 *  This class is intended to be replaced by third party code if required.  The console suite of functions is not available
 *  on all platforms.
 */ var Logger = exports.Logger = /*#__PURE__*/ function() {
    function Logger() {}
    Logger.debug = function debug(string) {
        console.log(string);
    };
    Logger.error = function error(string) {
        console.error(string);
    };
    Logger.info = function info(string) {
        console.info(string);
    };
    Logger.warn = function warn(string) {
        console.warn(string);
    };
    return Logger;
}();

},{}],"5j00o":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.VISIBLE_EVENTS = exports.VERIFICATION_EVENTS = exports.TIMELINE_EVENTS = exports.Payload = exports.PLAYER_OPERATION_EVENTS = exports.NON_LINEAR_EVENTS = exports.LINEAR_EVENTS = exports.INTERACTIVE_EVENTS = exports.Constant = exports.COMPANION_EVENTS = exports.CAT_TIMELINE_EVENTS = exports.CAT_AD_BREAK_EVENTS = exports.AD_BREAK_EVENTS = void 0;
exports.getLogTag = getLogTag;
/*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ var USER_AGENT = "Yospace SDK/3.0";
var PLAYER_OPERATION_EVENTS = exports.PLAYER_OPERATION_EVENTS = [
    "mute",
    "unmute",
    "pause",
    "resume",
    "rewind",
    "playerExpand",
    "playerCollapse",
    "closeLinear",
    "skip"
];
var COMPANION_EVENTS = exports.COMPANION_EVENTS = [
    "creativeView"
];
var INTERACTIVE_EVENTS = exports.INTERACTIVE_EVENTS = [
    "interactiveStart"
];
var LINEAR_EVENTS = exports.LINEAR_EVENTS = [
    "loaded",
    "start",
    "firstQuartile",
    "midpoint",
    "thirdQuartile",
    "complete",
    "progress",
    "mute",
    "unmute",
    "pause",
    "resume",
    "rewind",
    "playerExpand",
    "playerCollapse",
    "closeLinear",
    "skip",
    "otherAdInteraction"
];
var NON_LINEAR_EVENTS = exports.NON_LINEAR_EVENTS = [
    "creativeView",
    "mute",
    "unmute",
    "pause",
    "resume",
    "rewind",
    "skip",
    "playerExpand",
    "playerCollapse",
    "adExpand",
    "adCollapse",
    "minimize",
    "overlayViewDuration",
    "acceptInvitation",
    "close",
    "otherAdInteraction"
];
var VISIBLE_EVENTS = exports.VISIBLE_EVENTS = [
    "creativeView",
    "close",
    "interactiveStart"
];
var VERIFICATION_EVENTS = exports.VERIFICATION_EVENTS = [
    "verificationNotExecuted"
];
var TIMELINE_EVENTS = exports.TIMELINE_EVENTS = [
    "loaded",
    "start",
    "firstQuartile",
    "midpoint",
    "thirdQuartile",
    "complete",
    "progress"
];
var AD_BREAK_EVENTS = exports.AD_BREAK_EVENTS = [
    "breakStart",
    "breakEnd"
];
var Constant = exports.Constant = Object.freeze({
    ADVERT_START_TIMESLOT: 5,
    DEFAULT_POLLING_DELAY: 11000,
    EVENT_CUEPOINT_TOL: 10,
    EXPECTED_POLL_COMPLETE_TIME: 250,
    INTERSEGMENT_TIMEOUT: 2700,
    REQUEST_TIMEOUT: 5000,
    MAX_CADENCE: 250,
    MIN_INTRASEGMENT_TIMEOUT: 2500,
    MIN_SEGMENT_LENGTH: 2000,
    USER_AGENT: USER_AGENT
});
function getLogTag() {
    return "YoAdManagement: ";
}
/**
 * Event category used for suppression of analytics: Ad break events defined in the VMAP specification
 * @category Suppression Categories
 */ var CAT_AD_BREAK_EVENTS = exports.CAT_AD_BREAK_EVENTS = 1;
/**
 *
 * Event category used for suppression of analytics: timeline events ('quartiles') defined in the VAST specification
 * @category Suppression Categories
 */ var CAT_TIMELINE_EVENTS = exports.CAT_TIMELINE_EVENTS = 2;
// parsing map keys
var Payload = exports.Payload = Object.freeze({
    IDENTIFIER: "SESSIONIDENTIFIER",
    LOCATION: "LOCATION",
    HOSTNODE: "HOST",
    PORT: "PORT",
    ANALYTICURL: "ANALYTICURL",
    PAUSEURL: "PAUSEURL",
    SCHEME: "SCHEME",
    QS: "QUERYSTRING",
    AVAILABILITYSTART: "AVAILABILITYSTARTTIME"
});

},{}],"8JE54":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.BreakType = exports.AdBreak = void 0;
exports.normalisePosition = normalisePosition;
var _YoLog = require("770a943a8f0fa2e3");
var _AdBreakEventHandler2 = require("8bb8a6500129fd");
var _Advert = require("652308a769032a55");
var _XmlNode = require("dd46c55b54d59671");
var _StringUtils = require("6d2e70285b244961");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// Imports for jsdoc/Typescript
/**
 * Defines the possible ad break types as defined by the IAB VMAP specification
 * @enum {number}
 */ var BreakType = exports.BreakType = Object.freeze({
    /** Linear break type */ LINEAR: 0,
    /** Non-linear break type */ NONLINEAR: 1,
    /** Display break type */ DISPLAY: 2
});
function normalisePosition(position, start, breakType) {
    var pos = position ? position.toLowerCase() : "";
    if (pos === "preroll" || pos === "midroll" || pos === "postroll") return pos;
    else if (start === 0) return "preroll";
    else {
        // The position attribute may only ever be empty in a VOD stream with CSM < 2.40 or for
        // non-linear breaks. There is only a very small chance it could be postroll with these conditions
        if (breakType === BreakType.LINEAR) return "midroll";
        else return "unknown";
    }
}
/**
 * Represents an ad break object.
 *
 * The AdBreak encapsulates the data from the `<vmap:AdBreak>` element of a VMAP document: its
 * attributes, adverts and positional information.
 *
 * Through {@link AdBreakEventHandler} it supports the ability for a client app to signal non-linear events.
 * 
 * @hideconstructor
 * @see {@link AdBreakEventHandler}, which this class implements
 */ var AdBreak = exports.AdBreak = /*#__PURE__*/ function(_AdBreakEventHandler) {
    _inheritsLoose(AdBreak, _AdBreakEventHandler);
    function AdBreak(start, duration, position, trackingMap, breakType, identifier, extensions, adTagUri) {
        var _this;
        _this = _AdBreakEventHandler.call(this) || this;
        /** @private */ _this.startMillis = start;
        /** @private */ _this.duration = duration;
        /** @private */ _this.trackingMap = trackingMap ? trackingMap : new Map();
        /** @private */ _this.breakType = AdBreak.getBreakTypeFromString(breakType);
        /** @private */ _this.position = normalisePosition(position, start, _this.breakType);
        /** @private */ _this.identifier = identifier;
        /** @private */ _this.extensions = extensions;
        /** @private */ _this.broker = null;
        /** @private */ _this.adverts = [];
        /** @private */ _this.adTagUri = adTagUri ? adTagUri : null;
        if (_this.breakType !== BreakType.LINEAR && _this.startMillis === -1) _this.startMillis = 0;
        return _this;
    }
    AdBreak.getBreakTypeFromString = function getBreakTypeFromString(type) {
        if ((0, _StringUtils.equalsIgnoreCase)(type, "nonlinear")) return BreakType.NONLINEAR;
        else if ((0, _StringUtils.equalsIgnoreCase)(type, "display")) return BreakType.DISPLAY;
        else return BreakType.LINEAR;
    };
    var _proto = AdBreak.prototype;
    _proto.adjustForEarlyReturn = function adjustForEarlyReturn(playhead) {
        var ad = this.getAdvertFromPlayhead(playhead);
        if (ad) {
            var onBoundary = ad.getStart() === playhead;
            if (!onBoundary) ad.adjustForEarlyReturn(playhead);
            this.removeAdvertsFrom(ad, onBoundary);
            this.setDuration(playhead - this.startMillis);
            return true;
        }
        return false;
    };
    _proto.getAdvertForCreative = function getAdvertForCreative(creative) {
        for(var _iterator = _createForOfIteratorHelperLoose(this.adverts), _step; !(_step = _iterator()).done;){
            var ad = _step.value;
            if (ad.containsCreative(creative)) return ad;
        }
        return null;
    };
    _proto.getAdvertFromPlayhead = function getAdvertFromPlayhead(playhead) {
        for(var _iterator2 = _createForOfIteratorHelperLoose(this.adverts), _step2; !(_step2 = _iterator2()).done;){
            var ad = _step2.value;
            if (ad.getStart() <= playhead && playhead < ad.getEnd()) return ad;
        }
        return null;
    };
    _proto.getAdvertFromIdentifier = function getAdvertFromIdentifier(mediaId) {
        for(var _iterator3 = _createForOfIteratorHelperLoose(this.adverts), _step3; !(_step3 = _iterator3()).done;){
            var ad = _step3.value;
            if (ad.getMediaIdentifier() === mediaId) return ad;
        }
        return null;
    } /**
   *
   * @return {Advert[]} an array of all `Advert` objects in this ad break
   */ ;
    _proto.getAdverts = function getAdverts() {
        return Object.assign([], this.adverts);
    };
    _proto.getAdTagUri = function getAdTagUri() {
        return this.adTagUri;
    };
    _proto.getBreakTypeAsString = function getBreakTypeAsString() {
        switch(this.breakType){
            case BreakType.NONLINEAR:
                return "nonlinear";
            case BreakType.DISPLAY:
                return "display";
            default:
                return "linear";
        }
    } /**
   *
   * @return {BreakType} the break type of the ad break. Possible values are LINEAR, NONLINEAR and DISPLAY.
   */ ;
    _proto.getType = function getType() {
        return this.breakType;
    } /**
   * @return {number} the duration of the ad break, in milliseconds
   */ ;
    _proto.getDuration = function getDuration() {
        return this.duration;
    } /**
   *
   * @return {XmlNode} the XML VAST extensions for this ad break as an `XmlNode` or null if there are no extensions.
   */ ;
    _proto.getExtensions = function getExtensions() {
        return this.extensions;
    } /**
   * @return {string} the identifier of the ad break
   */ ;
    _proto.getIdentifier = function getIdentifier() {
        return this.identifier;
    } /**
   * @return {boolean} true if the break is a placeholder break
   */ ;
    _proto.isPlaceholder = function isPlaceholder() {
        return this.adTagUri !== null;
    } /**
   * Returns the position of the ad break in the stream, which may be one of:
   * 
   * - `preroll`
   * - `midroll`
   * - `postroll`
   * - `unknown`
   * 
   * @return {string} the position of the ad break as a `string`.
   */ ;
    _proto.getPosition = function getPosition() {
        return this.position;
    } /** Returns the amount of natural time remaining for the ad break from the given playhead position.
   * The value returned has a maximum value of the advert duration and a minimum value of zero.
   * 
   * @param {number} playhead The playhead position, in milliseconds.
   * @return {number} the time remaining in the ad break from the playhead provided, in milliseconds
   */ ;
    _proto.getRemainingTime = function getRemainingTime(playhead) {
        var delta = 0;
        if (this.adverts.length > 0) {
            var advert = this.adverts[0];
            var end = advert.getStart() + this.getDuration();
            delta = Math.min(end - playhead, this.getDuration());
        }
        return Math.max(0, delta);
    } /**
   * @return {number} the start position in milliseconds
   */ ;
    _proto.getStart = function getStart() {
        return this.startMillis;
    };
    _proto.getTrackingMap = function getTrackingMap() {
        return this.trackingMap;
    };
    _proto.getTrackingReport = function getTrackingReport(type, shouldRemove) {
        var report = this.trackingMap.get(type);
        if (report && shouldRemove) this.trackingMap["delete"](type);
        return report;
    } /** Returns whether the ad break is active, that is, whether any of its adverts have not yet been played.
   * @return {boolean} true if the ad break is active, false otherwise.
   */ ;
    _proto.isActive = function isActive() {
        if (!this.adverts) return false;
        for(var _iterator4 = _createForOfIteratorHelperLoose(this.adverts), _step4; !(_step4 = _iterator4()).done;){
            var ad = _step4.value;
            if (ad.isActive()) return true;
        }
        return false;
    };
    _proto.isNonLinear = function isNonLinear() {
        return this.breakType !== BreakType.LINEAR;
    };
    _proto.isValid = function isValid() {
        if (this.breakType === BreakType.LINEAR && this.startMillis === -1) {
            _YoLog.YoLog.e("Linear AdBreak is invalid - start position is unknown");
            return false;
        }
        return this.adverts.length > 0 || this.trackingMap.size > 0 || this.isPlaceholder();
    };
    _proto.onNonLinearTrackingEvent = function onNonLinearTrackingEvent(event) {
        if (!this.isNonLinear()) {
            _YoLog.YoLog.w("Warning: AdBreak is not nonlinear - can't signal NonLinearTrackingEvent");
            return;
        }
        var report = this.getTrackingReport(event, false);
        if (report) this.broker.fireTrackingReport(report);
    };
    _proto.postParse = function postParse(broker) {
        this.broker = broker;
        var offset = this.startMillis;
        for(var _iterator5 = _createForOfIteratorHelperLoose(this.adverts), _step5; !(_step5 = _iterator5()).done;){
            var ad = _step5.value;
            ad.setStart(offset);
            offset += ad.getDuration();
            ad.postParse(broker);
        }
    };
    _proto.removeAdvertsFrom = function removeAdvertsFrom(advert, inclusive) {
        for(var i = 0; i < this.adverts.length; ++i){
            var ad = this.adverts[i];
            if (ad === advert) {
                var index = inclusive === true ? i : i + 1;
                this.adverts.splice(index, this.adverts.length - index);
                return;
            }
        }
    };
    _proto.setAdverts = function setAdverts(adverts) {
        Array.prototype.push.apply(this.adverts, adverts);
        var offset = this.startMillis;
        for(var _iterator6 = _createForOfIteratorHelperLoose(this.adverts), _step6; !(_step6 = _iterator6()).done;){
            var advert = _step6.value;
            advert.setStart(offset);
            offset += advert.getDuration();
        }
    } /*  Returns false is not all adverts were set inactive.  Otherwise true. */ ;
    _proto.setAdvertsInactivePriorTo = function setAdvertsInactivePriorTo(playhead) {
        for(var _iterator7 = _createForOfIteratorHelperLoose(this.adverts), _step7; !(_step7 = _iterator7()).done;){
            var ad = _step7.value;
            if (ad.getEnd() < playhead) ad.setInactive();
            else return false;
        }
        return true;
    };
    _proto.setDuration = function setDuration(duration) {
        this.duration = duration;
    } /**
   * Sets the ad break inactive such that no analytic beacons will fire. The only client Callbacks
   * that will be raised are `onAdBreakStart` and `onAdBreakEnd`.
   */ ;
    _proto.setInactive = function setInactive() {
        // If ad break is non-linear, ads are always active
        if (this.isNonLinear()) return;
        for(var _iterator8 = _createForOfIteratorHelperLoose(this.adverts), _step8; !(_step8 = _iterator8()).done;){
            var ad = _step8.value;
            ad.setInactive();
        }
        this.trackingMap.clear();
    };
    _proto.toString = function toString() {
        return "\n--- AdBreak ---\n breakType:" + this.getBreakTypeAsString() + " start:" + this.startMillis + " milliseconds, duration:" + this.duration + ", position:" + this.position + "\nNumber of adverts:" + this.adverts.length;
    };
    return AdBreak;
}(_AdBreakEventHandler2.AdBreakEventHandler);

},{"770a943a8f0fa2e3":"9KS65","8bb8a6500129fd":"a7Gde","652308a769032a55":"h21pj","dd46c55b54d59671":"hUwGK","6d2e70285b244961":"7uXt7"}],"a7Gde":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.AdBreakEventHandler = void 0;
var _XmlValidation2 = require("3dd4fa75ef06067d");
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2021 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
/**
 * AdBreakEventHandler declares a set of methods that allow clients to provide event information to an ad break.
 *
 * It is implemented by AdBreak and clients <b>must</b> call each method at the appropriate time so that
 * the SDK can signal analytics on behalf of the app.
 * @hideconstructor
 */ var AdBreakEventHandler = exports.AdBreakEventHandler = /*#__PURE__*/ function(_XmlValidation) {
    _inheritsLoose(AdBreakEventHandler, _XmlValidation);
    function AdBreakEventHandler() {
        return _XmlValidation.apply(this, arguments) || this;
    }
    var _proto = AdBreakEventHandler.prototype;
    /** Indicates that a tracking event occurred for a non-linear ad break. The SDK fires beacons for any `<Tracking>` URLs defined for the ad break.<br/>
   * Clients should call this method in order to fire the appropriate tracking beacons, which may be `breakStart` or `breakEnd`.
   *
   * <b>NOTE:</b> `error` event is not supported.
   *
   * <b>NOTE:</b> Clients should call this method only for nonlinear ad breaks. Calling this method on a linear adbreak has no effect.
   * @param {string} event the tracking event
   */ _proto.onNonLinearTrackingEvent = function onNonLinearTrackingEvent(event) {
        throw new Error("Function must be overridden");
    };
    return AdBreakEventHandler;
}(_XmlValidation2.XmlValidation);

},{"3dd4fa75ef06067d":"6US9y"}],"6US9y":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.XmlValidation = void 0;
/*
 * COPYRIGHT 2020,2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ var XmlValidation = exports.XmlValidation = /*#__PURE__*/ function() {
    function XmlValidation() {
        if ((this instanceof XmlValidation ? this.constructor : void 0) === XmlValidation) throw new TypeError("Cannot construct abstract class XmlValidation directly");
    }
    var _proto = XmlValidation.prototype;
    _proto.isValid = function isValid() {
        return true;
    };
    return XmlValidation;
}();

},{}],"h21pj":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.Advert = void 0;
var _CompanionAds = require("73920728beeb5ca5");
var _CompanionCreative = require("5446c1fe8fadded3");
var _YoLog = require("3e7dd16ff0b07b81");
var _ConversionUtils = require("a03acccf262ce6f2");
var _NonLinearAds = require("ba93216d153997bd");
var _StringUtils = require("543038d0eeff2357");
var _AdvertEventHandler2 = require("a46de6c323c14a5d");
var _AdVerification = require("f2316918c30258b4");
var _AdvertWrapper = require("d85f965e17186519");
var _IndustryIcon = require("e653ed150b695656");
var _InteractiveCreative = require("800f051879a678cf");
var _LinearCreative = require("13c227f96361cf1e");
var _NonLinearCreative = require("aea71d76f153f5a7");
var _Resource = require("be992535096f686d");
var _VASTProperty = require("80fe5acfe887886f");
var _XmlNode = require("e20fef3ad531f329");
var _TrackingReport = require("45c5fc3212ab7a5f");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// Imports for jsdoc/Typescript
/**
 * Represents an advert object.
 *
 * The Advert encapsulates the data from the `<Ad>` and `<inline>` element of a VAST document: its
 * attributes, creatives and positional information.
 *
 * Through {@link AdvertEventHandler} it supports the ability for a client app to signal error, viewable and impression events.
 *
 * @hideconstructor
 * @see {@link AdvertEventHandler}, which this class implements
 */ var Advert = exports.Advert = /*#__PURE__*/ function(_AdvertEventHandler) {
    _inheritsLoose(Advert, _AdvertEventHandler);
    Advert.buildMapString = function buildMapString(map) {
        var s = "";
        if (map.size > 0) for(var _iterator = _createForOfIteratorHelperLoose(map), _step; !(_step = _iterator()).done;){
            var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
            s += "\n " + key + "=" + value;
        }
    };
    function Advert(advertData) {
        var _this;
        _this = _AdvertEventHandler.call(this) || this;
        /** @private */ _this.startMillis = 0;
        /** @private */ _this.active = false;
        /** @private */ _this.identifier = advertData.identifier;
        /** @private */ _this.mediaIdentifier = advertData.mediaIdentifier;
        /** @private */ _this.properties = advertData.properties ? advertData.properties : [];
        /** @private */ _this.linearCreative = advertData.linearCreative;
        /** @private */ _this.nonLinearAds = advertData.nonLinearAds ? advertData.nonLinearAds : new _NonLinearAds.NonLinearAds();
        /** @private */ _this.companionAds = advertData.companionAds ? advertData.companionAds : new _CompanionAds.CompanionAds();
        /** @private */ _this.impressions = advertData.impressions;
        /** @private */ _this.errors = advertData.errors;
        /** @private */ _this.viewableImpressions = advertData.viewableImpressions ? advertData.viewableImpressions : new Map();
        /** @private */ _this.adVerifications = advertData.adVerifications ? advertData.adVerifications : [];
        /** @private */ _this.sequence = advertData.sequence;
        /** @private */ _this.adType = advertData.adType;
        /** @private */ _this.nonLinear = advertData.nonLinear;
        /** @private */ _this.filler = advertData.filler;
        /** @private */ _this.trackingSchedule = new Map();
        if (!advertData.topLevelWrapper || !advertData.topLevelWrapper.isValid()) /** @private */ _this.wrapper = null;
        else _this.wrapper = advertData.topLevelWrapper;
        /** @private */ _this.extensions = advertData.extensions;
        /** @private */ _this.broker = null;
        /** @private */ _this.macroSubstitutions = new Map();
        /** @private */ _this.earlyReturn = false;
        return _this;
    }
    /**
   * Adds a entry to the client macro substitutions map such that any tracking URL containing
   * a macro matching the key will be substituted with the entry's value.
   *
   * <b>NOTE</b>: the key should not be enclosed in square brackets.
   * @param {string} key the macro name
   * @param {string} value the macro substitution value
   */ var _proto = Advert.prototype;
    _proto.addMacroSubstitution = function addMacroSubstitution(key, value) {
        this.macroSubstitutions.set(key, value);
    };
    _proto.addTrackingScheduleEntry = function addTrackingScheduleEntry(type, proportion) {
        var delay = proportion * this.linearCreative.getDuration();
        while(this.trackingSchedule.has(delay))++delay;
        this.trackingSchedule.set(delay, type);
    };
    _proto.adjustForEarlyReturn = function adjustForEarlyReturn(playhead) {
        var duration = playhead - this.startMillis;
        this.setDuration(duration);
        var trackingMap = this.getTrackingSchedule();
        for(var _iterator2 = _createForOfIteratorHelperLoose(trackingMap.keys()), _step2; !(_step2 = _iterator2()).done;){
            var k = _step2.value;
            if (k > duration) this.removeFromTrackingSchedule(k);
        }
        this.earlyReturn = true;
    };
    _proto.clearTrackingSchedule = function clearTrackingSchedule() {
        this.trackingSchedule.clear();
    };
    _proto.containsCreative = function containsCreative(creative) {
        if (creative instanceof _LinearCreative.LinearCreative) return creative === this.linearCreative;
        else if (creative instanceof _NonLinearCreative.NonLinearCreative) return this.nonLinearAds.containsCreative(creative);
        else if (creative instanceof _CompanionCreative.CompanionCreative) return this.companionAds.containsCreative(creative);
        return false;
    };
    _proto.containsIcon = function containsIcon(icon) {
        for(var _iterator3 = _createForOfIteratorHelperLoose(this.linearCreative.getIndustryIcons()), _step3; !(_step3 = _iterator3()).done;){
            var ii = _step3.value;
            if (ii === icon) return true;
        }
        return false;
    } /** Returns an array of verification objects used to execute third-party measurement code for an advert.
   * @return {AdVerification[]} an array of `AdVerification` objects associated with the advert
   */ ;
    _proto.getAdVerifications = function getAdVerifications() {
        return Object.assign([], this.adVerifications);
    } /**
   * @return {string} the advert's ad type as a `string`
   */ ;
    _proto.getAdType = function getAdType() {
        return this.adType;
    };
    _proto.getCompanionAds = function getCompanionAds() {
        return this.companionAds;
    } /**
   * Returns an array of `CompanionCreative` objects of the specified resource type
   * @param {ResourceType} type the resource type
   * @return {CompanionCreative[]} an `array` of `CompanionCreative`s
   */ ;
    _proto.getCompanionAdsByType = function getCompanionAdsByType(type) {
        return this.companionAds.getCompanionsByType(type);
    } /**
   * The required attribute for the `CompanionCreative` objects contained within this Ad.
   *
   * Possible values are 'all', 'any', 'none' or blank.
   * @return {string} the `required` attribute as a `string`
   */ ;
    _proto.getCompanionRequired = function getCompanionRequired() {
        return this.companionAds.getRequired();
    } /**
   * @return {number} the duration of the advert in milliseconds
   */ ;
    _proto.getDuration = function getDuration() {
        if (this.nonLinear) return 0;
        return this.linearCreative.getDuration();
    };
    _proto.getEnd = function getEnd() {
        return this.startMillis + this.linearCreative.getDuration();
    } /**
   * @return {XmlNode} the XML VAST extensions for this advert as an `XmlNode` or null if there are no extensions.
   */ ;
    _proto.getExtensions = function getExtensions() {
        return this.extensions;
    } /**
   * @return {string} the identifier of the advert as a `string`
   */ ;
    _proto.getIdentifier = function getIdentifier() {
        return this.identifier;
    };
    _proto.getImpressions = function getImpressions(shouldRemove) {
        if (!this.impressions) return null;
        var report = this.impressions.copy();
        if (shouldRemove) this.impressions = null;
        return report;
    } /**
   * @return {IndustryIcon[]} an array of `IndustryIcon` objects associated with the advert
   */ ;
    _proto.getIndustryIcons = function getIndustryIcons() {
        return this.linearCreative.getIndustryIcons();
    } /**
   * @return {InteractiveCreative} the `InteractiveCreative` of the advert or null if one is not present
   */ ;
    _proto.getInteractiveCreative = function getInteractiveCreative() {
        return this.linearCreative.getInteractiveCreative();
    };
    _proto.isTruncated = function isTruncated() {
        return this.earlyReturn;
    } /**
   * @return {AdvertWrapper} an `AdvertWrapper` representing the advert's wrapper data as a one-way 'linked list'
   */ ;
    _proto.getLineage = function getLineage() {
        return this.wrapper;
    } /**
   * @return {LinearCreative} the `LinearCreative` of the advert
   */ ;
    _proto.getLinearCreative = function getLinearCreative() {
        return this.linearCreative;
    } /**
   * @return {string[]} an `array` of macro substitutions as `string`s
   */ ;
    _proto.getMacroSubstitutions = function getMacroSubstitutions() {
        return this.macroSubstitutions;
    } /**
   *
   * @return {string} the Yospace identifier associated with the ingested advert media
   */ ;
    _proto.getMediaIdentifier = function getMediaIdentifier() {
        return this.mediaIdentifier;
    };
    _proto.getNonLinearAds = function getNonLinearAds() {
        return this.nonLinearAds;
    } /**
   * @param {ResourceType} type the resource type
   * @return {NonLinearCreative[]} an `array` of `NonLinearCreative` objects for the advert
   */ ;
    _proto.getNonLinearCreativesByType = function getNonLinearCreativesByType(type) {
        return this.nonLinearAds.getNonLinearCreativesByType(type);
    } /**
   * Returns the inline properties for the advert. The properties are represented as YOVASTProperty objects. Possible properties are:
   *
   * - AdSystem (Defines the source ad server of the advert)
   * - AdTitle (Defines the common name of the advert)
   * - AdServingId (Defines an identifier used to compare impression-level data across systems)
   * - Category (Defines the category of the advert content)
   * - Description (Defines a longer description of the advert)
   * - Advertiser (Defines the advertiser name)
   * - Pricing (Defines the pricing element of the advert)
   * - Survey (Defines a URI to any resource file having to do with collecting survey data)
   * - Expires (Defines the number of seconds in which the ad is valid for execution)
   *
   * @return {VASTProperty[]} an `array` of `VASTProperty` objects
   */ ;
    _proto.getProperties = function getProperties() {
        return Object.assign([], this.properties);
    } /**
   * Returns a named inline property for the advert if it exists. Possible properties are:
   *
   * - AdSystem (Defines the source ad server of the advert)
   * - AdTitle (Defines the common name of the advert)
   * - AdServingId (Defines an identifier used to compare impression-level data across systems)
   * - Category (Defines the category of the advert content)
   * - Description (Defines a longer description of the advert)
   * - Advertiser (Defines the advertiser name)
   * - Pricing (Defines the pricing element of the advert)
   * - Survey (Defines a URI to any resource file having to do with collecting survey data)
   * - Expires (Defines the number of seconds in which the ad is valid for execution)
   *
   * @param {string} name the name of the property
   * @return {VASTProperty} a `VASTProperty` object or `null` if not found
   */ ;
    _proto.getProperty = function getProperty(name) {
        for(var _iterator4 = _createForOfIteratorHelperLoose(this.properties), _step4; !(_step4 = _iterator4()).done;){
            var prop = _step4.value;
            if (prop.getName() === name) return prop;
        }
        return null;
    };
    _proto.getProportion = function getProportion(key) {
        var proportion = 0;
        var split = key.split("-");
        if (split.length !== 2) {
            _YoLog.YoLog.w("Badly formed progress event in VAST/VMAP: " + key);
            proportion = -1;
        } else if (split[1].indexOf("%") !== -1) {
            var d = parseFloat(split[1].substring(0, split[1].length - 1));
            proportion = d ? d / 100.0 : -1;
            if (proportion < 0) _YoLog.YoLog.w("Badly formed percentage string in VAST/VMAP: " + split[1]);
        } else proportion = parseFloat((0, _ConversionUtils.timeStringToMillis)(split[1], -1) / this.linearCreative.getDuration());
        return proportion;
    } /**
   * Returns the natural playback time remaining for the advert in milliseconds
   * @param {number} playhead the current playhead position in milliseconds
   * @return {number} the remaining time in milliseconds
   */ ;
    _proto.getRemainingTime = function getRemainingTime(playhead) {
        var end = this.startMillis + this.linearCreative.getDuration();
        var delta = Math.min(end - playhead, this.linearCreative.getDuration());
        return Math.max(0, delta);
    } /**
   * @return {number} the sequence of the advert as a `number`
   */ ;
    _proto.getSequence = function getSequence() {
        return this.sequence;
    } /**
   * @return {number} the value of skip offset for the advert, in milliseconds. If the VAST skip offset is not defined then this method
   * returns `-1`, signifying that the advert cannot be skipped.
   */ ;
    _proto.getSkipOffset = function getSkipOffset() {
        return this.linearCreative.getSkipOffset();
    } /**
   * @return {number} the start playhead position of the advert in milliseconds
   */ ;
    _proto.getStart = function getStart() {
        return this.startMillis;
    };
    _proto.getTrackingReports = function getTrackingReports(type) {
        var reports = [];
        // linear creative
        var report = this.linearCreative.getTrackingReport(type);
        if (report) reports.push(report);
        // nonlinear
        report = this.nonLinearAds.getTrackingReport(type);
        if (report) reports.push(report);
        return reports;
    };
    _proto.getTrackingReportLinear = function getTrackingReportLinear(type) {
        if (!this.linearCreative) return undefined;
        return this.linearCreative.getTrackingReport(type);
    };
    _proto.getTrackingReportNonLinear = function getTrackingReportNonLinear(type) {
        if (!this.nonLinearAds) return undefined;
        return this.nonLinearAds.getTrackingReport(type);
    };
    _proto.getTrackingSchedule = function getTrackingSchedule() {
        return this.trackingSchedule;
    };
    _proto.getViewableImpressions = function getViewableImpressions() {
        return this.viewableImpressions;
    } /**
   * @return {boolean} whether this advert is active i.e. whether it has been watched through to completion.
   */ ;
    _proto.isActive = function isActive() {
        return this.active;
    } /**
   * @return {boolean} whether this advert represents filler content
   */ ;
    _proto.isFiller = function isFiller() {
        return this.filler;
    } /**
   * @return {boolean} whether this advert represents nonlinear content
   */ ;
    _proto.isNonLinear = function isNonLinear() {
        return this.nonLinear;
    };
    _proto.isValid = function isValid() {
        if (this.nonLinear) return this.linearCreative ? false : true;
        else return !(0, _StringUtils.isNullOrEmpty)(this.mediaIdentifier) && this.linearCreative !== null;
    };
    _proto.onErrorEvent = function onErrorEvent(errorCode) {
        if (this.errors) {
            // add the macro substitution if required
            if (errorCode) this.addMacroSubstitution("ERRORCODE", errorCode.toString());
            // error beacons are fired at the discretion of the client application
            this.broker.fireTrackingReport(this.errors);
        }
    };
    _proto.onImpressionEvent = function onImpressionEvent() {
        if (!this.nonLinear) {
            _YoLog.YoLog.w("Warning: Advert is not nonlinear - can't signal ImpressionEvent");
            return;
        }
        var report = this.getImpressions(false);
        if (report) this.broker.fireTrackingReport(report);
    };
    _proto.onViewableEvent = function onViewableEvent(event) {
        var eventStr = Advert.viewableEventMap.get(event);
        var report = this.viewableImpressions.get(eventStr);
        if (report) // publisher determined viewability, therefore there are no conditions for firing beacon
        this.broker.fireTrackingReport(report);
    };
    _proto.postParse = function postParse(broker) {
        var _this2 = this;
        this.broker = broker;
        if (!this.nonLinear) {
            // add the 'standard' tracking schedule items
            this.addTrackingScheduleEntry("loaded", 0);
            this.addTrackingScheduleEntry("start", 0);
            this.addTrackingScheduleEntry("firstQuartile", 0.25);
            this.addTrackingScheduleEntry("midpoint", 0.5);
            this.addTrackingScheduleEntry("thirdQuartile", 0.75);
            this.addTrackingScheduleEntry("complete", 1.0);
            // get any progress events from the linear, modify name to 'progress-[offset-in-millis] and add offsets to tracking schedule
            for(var _iterator5 = _createForOfIteratorHelperLoose(this.linearCreative.getTrackingMap()), _step5; !(_step5 = _iterator5()).done;){
                var _step5$value = _step5.value, key = _step5$value[0], value = _step5$value[1];
                if (key.indexOf("progress") !== -1) {
                    var proportion = this.getProportion(key, value);
                    if (proportion >= 0) this.addTrackingScheduleEntry(key, proportion);
                }
            }
            // now sort
            this.trackingSchedule = new Map(Array.from(this.trackingSchedule).sort(function(a, b) {
                return a[0] - b[0];
            }));
        }
        // provision AdVerification
        for(var _iterator6 = _createForOfIteratorHelperLoose(this.adVerifications), _step6; !(_step6 = _iterator6()).done;){
            var adVerification = _step6.value;
            adVerification.postParse(this.broker, function(event) {
                _this2.addMacroSubstitution("REASON", event.getPayload());
            });
        }
        // provision non-linear creatives
        this.nonLinearAds.postParse();
        // provision interactive creative
        if (this.linearCreative) this.linearCreative.initialiseInteractiveCreative(this.nonLinearAds.getNonLinearCreatives());
        // prefetch resources as required
        this.prefetchResources(broker.getSessionProperties());
        this.active = true;
    };
    _proto.prefetchResources = function prefetchResources(properties) {
        if (properties.getPrefetchResources()) {
            this.nonLinearAds.prefetchResources(properties.getResourceTimeout());
            this.companionAds.prefetchResources(properties.getResourceTimeout());
        }
    };
    _proto.removeFromTrackingSchedule = function removeFromTrackingSchedule(key) {
        this.trackingSchedule["delete"](key);
    } /**
   * Removes the specified macro substitution if present
   * @param {string} key the macro name
   */ ;
    _proto.removeMacroSubstitution = function removeMacroSubstitution(key) {
        this.macroSubstitutions["delete"](key);
    };
    _proto.removeTrackingSchedule = function removeTrackingSchedule() {
        this.trackingSchedule.clear();
    };
    _proto.setDuration = function setDuration(duration) {
        if (this.linearCreative) this.linearCreative.setDuration(duration);
    };
    _proto.setInactive = function setInactive() {
        this.active = false;
    };
    _proto.setStart = function setStart(start) {
        this.startMillis = start;
    };
    _proto.toString = function toString() {
        if (this.isFiller()) return "\n--- Advert ---\n - Filler duration: " + this.getDuration();
        var impressions = "\n* Impression(s):";
        if (this.impressions) for(var _iterator7 = _createForOfIteratorHelperLoose(this.impressions.getTrackingUrls()), _step7; !(_step7 = _iterator7()).done;){
            var trackingUrl = _step7.value;
            impressions += trackingUrl;
        }
        else impressions += "NONE";
        var viewableImpressions = "\n* Viewable Impression(s):";
        viewableImpressions += Advert.buildMapString(this.viewableImpressions);
        var adVerifications = "\n * Ad Verification(s):";
        adVerifications += (0, _StringUtils.toIndentedString)(this.adVerifications);
        var errors = "\n Error(s):";
        if (this.errors) for(var _iterator8 = _createForOfIteratorHelperLoose(this.errors.getTrackingUrls()), _step8; !(_step8 = _iterator8()).done;){
            var error = _step8.value;
            errors += (0, _StringUtils.toIndentedString)("\n - " + error);
        }
        else errors += "NONE";
        var advertString = "\n--- Advert ---\n ID:";
        advertString += this.mediaIdentifier;
        advertString += "(";
        advertString += this.identifier;
        advertString += ")";
        advertString += " duration:";
        advertString += this.getDuration();
        advertString += " sequence:";
        advertString += this.sequence;
        advertString += " adtype:";
        advertString += this.adType;
        for(var _iterator9 = _createForOfIteratorHelperLoose(this.properties), _step9; !(_step9 = _iterator9()).done;){
            var prop = _step9.value;
            advertString += "\n" + (0, _StringUtils.toIndentedString)(prop);
        }
        if (this.extensions) {
            advertString += "\n * Extensions:";
            advertString += "\n" + (0, _StringUtils.toIndentedString)(this.getExtensions());
        }
        if (this.wrapper) {
            advertString += "\n * Lineage -\n";
            advertString += (0, _StringUtils.toIndentedString)(this.wrapper);
        }
        advertString += (0, _StringUtils.toIndentedString)(impressions);
        advertString += (0, _StringUtils.toIndentedString)(viewableImpressions);
        advertString += (0, _StringUtils.toIndentedString)(adVerifications);
        advertString += (0, _StringUtils.toIndentedString)(errors);
        if (!this.nonLinear) advertString += (0, _StringUtils.toIndentedString)(this.linearCreative);
        advertString += (0, _StringUtils.toIndentedString)(this.nonLinearAds);
        advertString += (0, _StringUtils.toIndentedString)(this.companionAds);
        return advertString;
    };
    return Advert;
}(_AdvertEventHandler2.AdvertEventHandler);
/** @private */ Advert.viewableEventMap = new Map();
Advert.viewableEventMap.set(_AdvertEventHandler2.ViewableEvent.VIEWABLE, "Viewable");
Advert.viewableEventMap.set(_AdvertEventHandler2.ViewableEvent.NOT_VIEWABLE, "NotViewable");
Advert.viewableEventMap.set(_AdvertEventHandler2.ViewableEvent.VIEW_UNDETERMINED, "ViewUndetermined");

},{"73920728beeb5ca5":"dG5RW","5446c1fe8fadded3":"lj3Py","3e7dd16ff0b07b81":"9KS65","a03acccf262ce6f2":"8owmX","ba93216d153997bd":"boy2w","543038d0eeff2357":"7uXt7","a46de6c323c14a5d":"gTmyD","f2316918c30258b4":"153sX","d85f965e17186519":"dVAhT","e653ed150b695656":"heno1","800f051879a678cf":"Ir4VY","13c227f96361cf1e":"cZC7f","aea71d76f153f5a7":"1lIbj","be992535096f686d":"3iyI3","80fe5acfe887886f":"kiVVI","e20fef3ad531f329":"hUwGK","45c5fc3212ab7a5f":"fbiP9"}],"dG5RW":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.CompanionAds = void 0;
var _StringUtils = require("3a1e3499415f84b3");
var _Resource = require("271f2b549ea0c33d");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
} /*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
var CompanionAds = exports.CompanionAds = /*#__PURE__*/ function() {
    function CompanionAds(required, companions) {
        /** @private */ this.required = required;
        /** @private */ this.companions = companions ? companions : [];
    }
    var _proto = CompanionAds.prototype;
    _proto.containsCreative = function containsCreative(creative) {
        return this.companions.indexOf(creative) !== -1;
    };
    _proto.getCompanions = function getCompanions() {
        return Object.assign([], this.companions);
    };
    _proto.getCompanionsByType = function getCompanionsByType(type) {
        var arr = [];
        for(var _iterator = _createForOfIteratorHelperLoose(this.companions), _step; !(_step = _iterator()).done;){
            var comp = _step.value;
            if (comp.getResource(type) || type === _Resource.ResourceType.UNKNOWN && comp.getResources().size === 0) arr.push(comp);
        }
        return arr;
    };
    _proto.getRequired = function getRequired() {
        return this.required;
    };
    _proto.prefetchResources = function prefetchResources(timeout) {
        for(var _iterator2 = _createForOfIteratorHelperLoose(this.companions), _step2; !(_step2 = _iterator2()).done;){
            var comp = _step2.value;
            comp.prefetchResources(timeout);
        }
    };
    _proto.toString = function toString() {
        var s = "";
        if (this.companions.length > 0) {
            s = "\n--- Companion Ads required:";
            s += this.required;
            for(var _iterator3 = _createForOfIteratorHelperLoose(this.companions), _step3; !(_step3 = _iterator3()).done;){
                var comp = _step3.value;
                s += (0, _StringUtils.toIndentedString)(comp);
            }
        }
        return s;
    };
    return CompanionAds;
}();

},{"3a1e3499415f84b3":"7uXt7","271f2b549ea0c33d":"3iyI3"}],"7uXt7":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.equalsIgnoreCase = equalsIgnoreCase;
exports.formatHtml = formatHtml;
exports.isNullOrEmpty = isNullOrEmpty;
exports.isString = isString;
exports.toIndentedString = toIndentedString;
exports.toUnindentedString = toUnindentedString;
/*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ function equalsIgnoreCase(s1, s2) {
    if (s1 === null) return s2 === null;
    if (s1 === undefined) return s2 === undefined;
    if (isString(s1) && isString(s2)) return s1.toUpperCase() === s2.toUpperCase();
    else return false;
}
function isString(s) {
    return typeof s === "string" || s instanceof String;
}
function formatHtml(s) {
    if (!s) return "";
    try {
        var lvl = 0;
        var res = "";
        var cur = null;
        var last = 0;
        for(var i = 0; i < s.length; ++i){
            cur = s[i];
            if (cur === "<") {
                var next = s[i + 1];
                if (next === "/") lvl--;
                res = pad(res, last, lvl);
                if (next !== "/" && next !== "!") lvl++;
            }
            res += cur;
            last = cur;
        }
        if (lvl === 0) return res;
    } catch (e) {
    // Malformed string
    }
    return s;
}
function toIndentedString(o) {
    if (!o) return "null";
    return "    " + o.toString().replace("\n", "\n    ");
}
function toUnindentedString(o) {
    if (!o) return "null";
    else return "" + o.toString().replace("\n    ", "\n");
}
function isNullOrEmpty(s) {
    return !s || s === "";
}
function pad(str, last, lvl) {
    var res = str;
    if (last === 0 || last === ">") {
        res += "\n";
        for(var i = 0; i < lvl * 4; ++i)res += " ";
    }
    return res;
}

},{}],"3iyI3":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.ResourceType = exports.Resource = void 0;
var _StringUtils = require("7387d7ea7ba2769");
var _XmlValidation2 = require("4825b60b601b9ad2");
var _YoLog = require("8f389e24557fb4ae");
var _HttpConnection = require("f795808ec88d2552");
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
/**
 * Enumeration of possible Creative resource types:
 * @category Enumerations
 * @enum {number}
 */ var ResourceType = exports.ResourceType = {
    /** Static resource e.g. jpeg, png */ STATIC: 0,
    /** HTML resource */ HTML: 1,
    /** Iframe resource */ IFRAME: 2,
    /** Unknown resource: Used only to obtain Companions from the Advert that have tracking but no Resource. */ UNKNOWN: 3
};
/**
 * Represents a resource object for a linear, non-linear or companion creative, or for an Industry Icon.
 *
 * Encapsulates the data from the `<Resource>` element of a VAST document.<br/>
 * It represents one of the following VAST resource types:
 * - StaticResource
 * - HTMLResource
 * - IFrameResource
 * 
 * @hideconstructor
 */ var Resource = exports.Resource = /*#__PURE__*/ function(_XmlValidation) {
    _inheritsLoose(Resource, _XmlValidation);
    function Resource(type, stringData, creativeType, encoded) {
        var _this;
        _this = _XmlValidation.call(this) || this;
        switch(type){
            case ResourceType.STATIC:
                /** @private */ _this.stringData = stringData;
                /** @private */ _this.creativeType = creativeType;
                /** @private */ _this.encoded = false;
                /** @private */ _this.type = type;
                break;
            case ResourceType.IFRAME:
                /** @private */ _this.stringData = stringData;
                /** @private */ _this.creativeType = null;
                /** @private */ _this.type = type;
                /** @private */ _this.encoded = false;
                break;
            case ResourceType.HTML:
                /** @private */ _this.stringData = stringData;
                /** @private */ _this.creativeType = null;
                /** @private */ _this.type = type;
                /** @private */ _this.encoded = encoded;
                break;
        }
        /** @private */ _this.byteData = null;
        return _this;
    }
    /**
   * Returns the byte data associated with this resource, if the type is StaticResource or IFrameResource,
   * or null if the type is HTMLResource.
   *
   * @return {number[]} a byte array representing the {@link Resource}, or null if it has not been loaded
   */ var _proto = Resource.prototype;
    _proto.getByteData = function getByteData() {
        return this.byteData;
    } /**
   * @return {string} the value of creativeType - the MIME type of the static resource, or null if one wasn't provided in the VAST
   */ ;
    _proto.getCreativeType = function getCreativeType() {
        return this.creativeType;
    } /**
   * @return {ResourceType} the {@link ResourceType} of this resource
   */ ;
    _proto.getResourceType = function getResourceType() {
        return this.type;
    } /**
   * Returns the string data associated with this resource if the type is HTMLResource,
   * or the URL associated with this resource if the type is StaticResource or IFrameResource.
   *
   * @return {string} a string representing the resource, or the URL of the resource
   */ ;
    _proto.getStringData = function getStringData() {
        return this.stringData;
    } /**
   * Returns whether the string data for this resource is encoded. This method is only valid for
   * resources of type HTMLResource.
   * @return {boolean} true if the string data is encoded
   */ ;
    _proto.isEncoded = function isEncoded() {
        return this.encoded;
    };
    _proto.isValid = function isValid() {
        switch(this.type){
            case ResourceType.STATIC:
                if (!this.creativeType || this.creativeType === "") return false;
                break;
            case ResourceType.HTML:
                if (!this.stringData || this.stringData === "") return false;
                break;
            case ResourceType.IFRAME:
                try {
                    new URL(this.stringData);
                } catch (e) {
                    return false;
                }
                break;
            default:
                return false;
        }
        return true;
    };
    _proto.prefetch = function prefetch(timeout) {
        var _this2 = this;
        if (this.byteData || this.type === ResourceType.HTML || this.type === ResourceType.UNKNOWN) return;
        _HttpConnection.HttpConnection.get(this.stringData, {}, timeout).then(function(response) {
            if (response.ok) _this2.byteData = response.body;
            else _YoLog.YoLog.e("Resource prefetch request failed: " + _this2.stringData + ", status: " + response.status + ", error:" + response.statusText);
        });
    };
    _proto.toString = function toString() {
        var s = "";
        switch(this.type){
            case ResourceType.STATIC:
                s += "\nStatic resource (";
                s += this.creativeType;
                s += "): ";
                s += this.stringData;
                break;
            case ResourceType.HTML:
                s += "\nHTML resource (";
                s += this.encoded ? "encoded): " : "unencoded): ";
                s += (0, _StringUtils.formatHtml)(this.stringData);
                break;
            case ResourceType.IFRAME:
                s += "\niFrame resource: ";
                s += this.stringData;
                break;
        }
        return s;
    };
    return Resource;
}(_XmlValidation2.XmlValidation);

},{"7387d7ea7ba2769":"7uXt7","4825b60b601b9ad2":"6US9y","8f389e24557fb4ae":"9KS65","f795808ec88d2552":"6cS9V"}],"6cS9V":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.HttpConnection = void 0;
var _HttpUtils = require("7d7932c57276f571");
var _Constant = require("b938446bd526fba3");
var _YoLog = require("153c48a4db7fe331");
var _Session = require("7cb314ad40f5b7f3");
function _regeneratorRuntime() {
    "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ 
    _regeneratorRuntime = function _regeneratorRuntime() {
        return e;
    };
    var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t, e, r) {
        t[e] = r.value;
    }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
    function define(t, e, r) {
        return Object.defineProperty(t, e, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }), t[e];
    }
    try {
        define({}, "");
    } catch (t) {
        define = function define(t, e, r) {
            return t[e] = r;
        };
    }
    function wrap(t, e, r, n) {
        var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []);
        return o(a, "_invoke", {
            value: makeInvokeMethod(t, r, c)
        }), a;
    }
    function tryCatch(t, e, r) {
        try {
            return {
                type: "normal",
                arg: t.call(e, r)
            };
        } catch (t) {
            return {
                type: "throw",
                arg: t
            };
        }
    }
    e.wrap = wrap;
    var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var p = {};
    define(p, a, function() {
        return this;
    });
    var d = Object.getPrototypeOf, v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t) {
        [
            "next",
            "throw",
            "return"
        ].forEach(function(e) {
            define(t, e, function(t) {
                return this._invoke(e, t);
            });
        });
    }
    function AsyncIterator(t, e) {
        function invoke(r, o, i, a) {
            var c = tryCatch(t[r], t, o);
            if ("throw" !== c.type) {
                var u = c.arg, h = u.value;
                return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function(t) {
                    invoke("next", t, i, a);
                }, function(t) {
                    invoke("throw", t, i, a);
                }) : e.resolve(h).then(function(t) {
                    u.value = t, i(u);
                }, function(t) {
                    return invoke("throw", t, i, a);
                });
            }
            a(c.arg);
        }
        var r;
        o(this, "_invoke", {
            value: function value(t, n) {
                function callInvokeWithMethodAndArg() {
                    return new e(function(e, r) {
                        invoke(t, n, e, r);
                    });
                }
                return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
            }
        });
    }
    function makeInvokeMethod(e, r, n) {
        var o = h;
        return function(i, a) {
            if (o === f) throw new Error("Generator is already running");
            if (o === s) {
                if ("throw" === i) throw a;
                return {
                    value: t,
                    done: !0
                };
            }
            for(n.method = i, n.arg = a;;){
                var c = n.delegate;
                if (c) {
                    var u = maybeInvokeDelegate(c, n);
                    if (u) {
                        if (u === y) continue;
                        return u;
                    }
                }
                if ("next" === n.method) n.sent = n._sent = n.arg;
                else if ("throw" === n.method) {
                    if (o === h) throw o = s, n.arg;
                    n.dispatchException(n.arg);
                } else "return" === n.method && n.abrupt("return", n.arg);
                o = f;
                var p = tryCatch(e, r, n);
                if ("normal" === p.type) {
                    if (o = n.done ? s : l, p.arg === y) continue;
                    return {
                        value: p.arg,
                        done: n.done
                    };
                }
                "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
            }
        };
    }
    function maybeInvokeDelegate(e, r) {
        var n = r.method, o = e.iterator[n];
        if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
        var i = tryCatch(o, e.iterator, r.arg);
        if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
        var a = i.arg;
        return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
    }
    function pushTryEntry(t) {
        var e = {
            tryLoc: t[0]
        };
        1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
    }
    function resetTryEntry(t) {
        var e = t.completion || {};
        e.type = "normal", delete e.arg, t.completion = e;
    }
    function Context(t) {
        this.tryEntries = [
            {
                tryLoc: "root"
            }
        ], t.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(e) {
        if (e || "" === e) {
            var r = e[a];
            if (r) return r.call(e);
            if ("function" == typeof e.next) return e;
            if (!isNaN(e.length)) {
                var o = -1, i = function next() {
                    for(; ++o < e.length;)if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
                    return next.value = t, next.done = !0, next;
                };
                return i.next = i;
            }
        }
        throw new TypeError(typeof e + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: !0
    }), o(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t) {
        var e = "function" == typeof t && t.constructor;
        return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
    }, e.mark = function(t) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
    }, e.awrap = function(t) {
        return {
            __await: t
        };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
        return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function(t, r, n, o, i) {
        void 0 === i && (i = Promise);
        var a = new AsyncIterator(wrap(t, r, n, o), i);
        return e.isGeneratorFunction(r) ? a : a.next().then(function(t) {
            return t.done ? t.value : a.next();
        });
    }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function() {
        return this;
    }), define(g, "toString", function() {
        return "[object Generator]";
    }), e.keys = function(t) {
        var e = Object(t), r = [];
        for(var n in e)r.push(n);
        return r.reverse(), function next() {
            for(; r.length;){
                var t = r.pop();
                if (t in e) return next.value = t, next.done = !1, next;
            }
            return next.done = !0, next;
        };
    }, e.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(e) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for(var r in this)"t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
        },
        stop: function stop() {
            this.done = !0;
            var t = this.tryEntries[0].completion;
            if ("throw" === t.type) throw t.arg;
            return this.rval;
        },
        dispatchException: function dispatchException(e) {
            if (this.done) throw e;
            var r = this;
            function handle(n, o) {
                return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
            }
            for(var o = this.tryEntries.length - 1; o >= 0; --o){
                var i = this.tryEntries[o], a = i.completion;
                if ("root" === i.tryLoc) return handle("end");
                if (i.tryLoc <= this.prev) {
                    var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc");
                    if (c && u) {
                        if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
                        if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
                    } else if (c) {
                        if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
                    } else {
                        if (!u) throw new Error("try statement without catch or finally");
                        if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
                    }
                }
            }
        },
        abrupt: function abrupt(t, e) {
            for(var r = this.tryEntries.length - 1; r >= 0; --r){
                var o = this.tryEntries[r];
                if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
                    var i = o;
                    break;
                }
            }
            i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
            var a = i ? i.completion : {};
            return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
        },
        complete: function complete(t, e) {
            if ("throw" === t.type) throw t.arg;
            return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
        },
        finish: function finish(t) {
            for(var e = this.tryEntries.length - 1; e >= 0; --e){
                var r = this.tryEntries[e];
                if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
            }
        },
        "catch": function _catch(t) {
            for(var e = this.tryEntries.length - 1; e >= 0; --e){
                var r = this.tryEntries[e];
                if (r.tryLoc === t) {
                    var n = r.completion;
                    if ("throw" === n.type) {
                        var o = n.arg;
                        resetTryEntry(r);
                    }
                    return o;
                }
            }
            throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(e, r, n) {
            return this.delegate = {
                iterator: values(e),
                resultName: r,
                nextLoc: n
            }, "next" === this.method && (this.arg = t), y;
        }
    }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) resolve(value);
    else Promise.resolve(value).then(_next, _throw);
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
/*
 * Connection class for making HTTP get requests. The class wraps fetch.
 */ var HttpConnection = exports.HttpConnection = /*#__PURE__*/ function() {
    function HttpConnection(url, opts, timeout) {
        this.url = url;
        this.opts = opts;
        this.requestTimeout = timeout ? timeout : _Constant.Constant.REQUEST_TIMEOUT;
    }
    HttpConnection.get = function get(url, opts, timeout, customHttpHeaders, customParams) {
        return HttpConnection.handleGet(url, opts, timeout, customHttpHeaders, customParams);
    };
    HttpConnection.handleGet = function handleGet(url, opts, timeout, customHttpHeaders, customParams) {
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_HTTP_REQUESTS, "Requesting " + url);
        if (customParams instanceof Map) {
            var urlOb = (0, _HttpUtils.getUrl)(url);
            // Don't handle the URL failing to parse - fetch will handle that for us.  We are just setting custom params
            // at this stage.
            if (urlOb) {
                for(var _iterator = _createForOfIteratorHelperLoose(customParams), _step; !(_step = _iterator()).done;){
                    var _step$value = _step.value, key = _step$value[0], val = _step$value[1];
                    urlOb.searchParams.set(key, val);
                }
                url = urlOb.toString();
            }
        }
        if (customHttpHeaders) {
            var headers = new Headers();
            for(var _iterator2 = _createForOfIteratorHelperLoose(customHttpHeaders), _step2; !(_step2 = _iterator2()).done;){
                var _step2$value = _step2.value, _key = _step2$value[0], value = _step2$value[1];
                headers.set(_key, value);
            }
            opts.headers = headers;
        }
        var conn = new HttpConnection(url, opts, timeout);
        return conn.executeGet();
    };
    var _proto = HttpConnection.prototype;
    _proto.executeGet = /*#__PURE__*/ function() {
        var _executeGet = _asyncToGenerator(/*#__PURE__*/ _regeneratorRuntime().mark(function _callee() {
            var response, result;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
                while(true)switch(_context.prev = _context.next){
                    case 0:
                        response = {}; // This is intended to not throw.
                        _context.next = 3;
                        return (0, _HttpUtils.fetchWithTimeout)(this.url, this.opts, this.requestTimeout);
                    case 3:
                        result = _context.sent;
                        // Modifying result isn't an option because if fetch completes instead of timeout within fetchWithTimeout,
                        // the response object cannot be modified
                        response.ok = result.ok;
                        response.headers = result.headers;
                        response.status = result.status;
                        response.statusText = result.statusText;
                        response.timeout = result.timeout;
                        response.url = result.url;
                        response.error = result.error;
                        response.type = result.type;
                        if (response.timeout) _YoLog.YoLog.w("Request to " + response.url + " timed out");
                        if (response.error) _YoLog.YoLog.w("Request to " + response.url + " failed: " + response.error);
                        if (!result.ok) {
                            _context.next = 28;
                            break;
                        }
                        _context.prev = 15;
                        _context.next = 18;
                        return result.text();
                    case 18:
                        response.body = _context.sent;
                        _context.next = 28;
                        break;
                    case 21:
                        _context.prev = 21;
                        _context.t0 = _context["catch"](15);
                        response.ok = false;
                        response.status = _Session.CONNECTION_ERROR;
                        response.statusText = _context.t0.message;
                        response.error = _context.t0;
                        return _context.abrupt("return", response);
                    case 28:
                        // Note: we have no information about CORS responses.  response.status will be undefined.
                        if (response.status) _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_HTTP_REQUESTS, "HTTP response: " + response.status + " (" + this.url + ")");
                        return _context.abrupt("return", response);
                    case 30:
                    case "end":
                        return _context.stop();
                }
            }, _callee, this, [
                [
                    15,
                    21
                ]
            ]);
        }));
        function executeGet() {
            return _executeGet.apply(this, arguments);
        }
        return executeGet;
    }();
    return HttpConnection;
}();

},{"7d7932c57276f571":"2wJyf","b938446bd526fba3":"5j00o","153c48a4db7fe331":"9KS65","7cb314ad40f5b7f3":"62muZ"}],"2wJyf":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.createHeaders = createHeaders;
exports.fetchWithTimeout = fetchWithTimeout;
exports.getAbsolute = getAbsolute;
exports.getUrl = getUrl;
var _StringUtils = require("abdc6a594e4109c3");
var _YoLog = require("4382207ad09493ae");
var _Session = require("9e7eac8543d265e0");
/*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ function getAbsolute(relativeUrl, absoluteBaseUrl) {
    var bUrl = new URL(absoluteBaseUrl);
    var aUrl = new URL(bUrl, relativeUrl);
    return aUrl.toString();
}
function getUrl(url) {
    if ((0, _StringUtils.isNullOrEmpty)(url)) return null;
    var u = null;
    try {
        u = new URL(url);
    } catch (e) {
        return null;
    }
    if (!u) return null;
    try {
        decodeURI(u.pathname);
    } catch (e) {
        return null;
    }
    return u;
}
function createHeaders(userAgent) {
    var headers = new Headers();
    headers.append("User-Agent", userAgent);
    return headers;
}
// This function should handle any error that arises and handle it gracefully without throwing
function fetchWithTimeout(url, opts, timeout) {
    var handle = null;
    var timer = new Promise(function(resolve) {
        handle = setTimeout(resolve, timeout, {
            timeout: true,
            error: "timeout",
            statusText: "Connection timeout",
            status: _Session.CONNECTION_TIMEOUT
        });
    });
    return Promise.race([
        timer,
        fetch(url, opts)
    ]).then(function(response) {
        if (response.timeout) _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_HTTP_REQUESTS, "Request for " + url + " timed out");
        else if (!response.ok && response.status) // Don't log CORS responses - we have no information on them and they result in support tickets
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_HTTP_REQUESTS, "Request for " + url + " failed. Status: " + response.status + ". Message: " + response.statusText);
        return response;
    })["catch"](function(e) {
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_HTTP_REQUESTS, "Request for " + url + " failed. Exception: " + e);
        var status = _Session.CONNECTION_ERROR;
        if (e.code === "ERR_INVALID_URL" || e.cause && e.cause.code === "ERR_INVALID_URL") status = _Session.MALFORMED_URL;
        return {
            error: e,
            statusText: e.message,
            status: status
        };
    })["finally"](function() {
        clearTimeout(handle);
    });
}

},{"abdc6a594e4109c3":"7uXt7","4382207ad09493ae":"9KS65","9e7eac8543d265e0":"62muZ"}],"62muZ":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.UNKNOWN_FORMAT = exports.SessionState = exports.SessionProperties = exports.SessionErrorCode = exports.Session = exports.PlaybackMode = exports.PARTIAL_VMAP = exports.NO_DVRLIVE = exports.MALFORMED_URL = exports.INVALID_WINDOW = exports.FALLBACK_URL = exports.CONNECTION_TIMEOUT = exports.CONNECTION_ERROR = void 0;
var _Constant = require("69b3a3178da8650d");
var _ReportsManager = require("59b4e2395812c2a9");
var _AnalyticBroker2 = require("1a976bb0ba791707");
var _AdBreak = require("36b39b01677628fa");
var _YoLog = require("a927645a8ed28887");
var _StringUtils = require("fc2be71405a10d7f");
var _TrackingReport = require("2014fce9833c4d");
var _PlaybackEventHandler = require("5eed4d40dd499218");
var _CallbackHelper = require("fc0494e87687a88d");
var _HttpUtils = require("decd12c8cf150665");
var _DefaultPlaybackPolicyHandler = require("59cc23dfa00fdeff");
var _CollectionUtils = require("6d12b9d4dc7f9dfa");
var _AnalyticEventObserver = require("402bc9433cd37f79");
var _Advert = require("55cdb77caa238ee6");
var _LinearCreative = require("9d94eb916f7f41c8");
var _PlaybackPolicyHandler = require("cc4651636e807af8");
var _ParsingError = require("917eab0ec99b1680");
var _TrackingError = require("46bc32753a8d6b0a");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// JsDoc/Typescript imports
var pkg = require("4eb0b5a8c1e8f2fa");
/**
 * Enumeration of possible playback modes:
 * @enum {number}
 * @category Enumerations
 */ var PlaybackMode = exports.PlaybackMode = Object.freeze({
    /** Live playback mode */ LIVE: 0,
    /** DVR Live playback mode */ DVRLIVE: 1,
    /** VOD playback mode */ VOD: 2
});
/**
 * Enumeration of possible Session states
 * @enum {number}
 * @category Enumerations
 */ var SessionState = exports.SessionState = Object.freeze({
    // Undocumented - internal use only
    NONE: 0,
    /** The Session is initialised */ INITIALISED: 1,
    /** The Session will not provide analytic tracking and playback cannot proceed */ FAILED: 2,
    /** The Session will not provide analytic tracking but playback may be possible */ NO_ANALYTICS: 3,
    /** The Session is shut down and is no longer valid */ SHUTDOWN: 4
});
/**
 * Enumeration of Session error codes:
 * @enum {number}
 * @category Enumerations
 */ var SessionErrorCode = exports.SessionErrorCode = Object.freeze({
    /** The session with the Yospace Central Streaming Manager (CSM) service timed-out.
   No further analytics will be signalled after this event. */ TIMEOUT: 0,
    /** The fulfillment payload for an initial VMAP response with placeholder break was not received or did not contain the expected data */ UNRESOLVED_BREAK: 1,
    /** The parser returned error(s) during XML parsing */ PARSING_ERROR: 2,
    /** The result of one or more tracking beacons was unsuccessful. Deprecated - to be removed in 3.8 */ TRACKING_ERROR: 3
});
/**
 * Yospace initialisation result code (-1): failed to establish an HTTP connection.
 * @category Result Codes
 */ var CONNECTION_ERROR = exports.CONNECTION_ERROR = -1;
/**
 * Yospace initialisation result code (-2): failed to complete connection or read the HTTP response before a timeout occurred
 * @category Result Codes
 */ var CONNECTION_TIMEOUT = exports.CONNECTION_TIMEOUT = -2;
/**
 * Yospace initialisation result code (-3): the request URL is malformed
 * @category Result Codes
 */ var MALFORMED_URL = exports.MALFORMED_URL = -3;
/**
 * Yospace initialisation result code: the stream is not configured for DVRLive playback; DVRLive
 * feature is not available.
 */ var NO_DVRLIVE = exports.NO_DVRLIVE = -11;
/**
 * Yospace initialisation result code (-20): the manifest is corrupt or of an unknown format
 * @category Result Codes
 */ var UNKNOWN_FORMAT = exports.UNKNOWN_FORMAT = -20;
/**
 * Yospace initialisation result code (-21): the host provided a fallback URL instead of a manifest
 * @category Result Codes
 */ var FALLBACK_URL = exports.FALLBACK_URL = -21;
/**
 * Yospace initialisation result code (-22): the host provided a "partial" VMAP instead of a full manifest
 * @category Result Codes
 */ var PARTIAL_VMAP = exports.PARTIAL_VMAP = -22;
/**
 * Indication that the Session's DVR window is invalid.
 * @category DVR Live Codes
 */ var INVALID_WINDOW = exports.INVALID_WINDOW = -1;
/**
 * Base class of linear, VOD and DVR Live Yospace CSM sessions.
 * @hideconstructor
 */ var Session = exports.Session = /*#__PURE__*/ function(_AnalyticBroker) {
    _inheritsLoose(Session, _AnalyticBroker);
    /**
   * Session constructor
    @param properties the session properties
   */ function Session(properties) {
        var _this;
        _this = _AnalyticBroker.call(this) || this;
        /** @private */ _this.sessionProperties = properties ? Object.assign(Object.create(Object.getPrototypeOf(properties)), properties) : new SessionProperties();
        /** @protected */ _this.trackingErrors = [];
        /** @protected */ _this.reportsManager = new _ReportsManager.ReportsManager(properties, _this.addTrackingError.bind(_assertThisInitialized(_this)));
        /** @protected */ _this.linearAdBreaks = [];
        /** @protected */ _this.nonLinearAdBreaks = [];
        /** @protected */ _this.displayAdBreaks = [];
        /** @private */ _this.playbackBuffering = false;
        /** @private */ _this.playing = false;
        /** @private */ _this.currentAdBreak = null;
        /** @private */ _this.currentAdvert = null;
        /** @private */ _this.identifier = "";
        /** @private */ _this.playbackUrl = null;
        /** @private */ _this.analyticsUrl = null;
        /** @private */ _this.lastAnalyticUpdate = null;
        /** @private */ _this.playhead = 0;
        /** @private */ _this.lastPlayed = 0;
        /** @private */ _this.lastTraced = 0;
        /** @private */ _this.sessionState = SessionState.NONE;
        /** @private */ _this.resultCode = 0;
        /** @private */ _this.policyHandler = null;
        /** @private */ _this.parsingErrors = [];
        /** @protected */ _this.defaultPolicyHandler = new _DefaultPlaybackPolicyHandler.DefaultPlaybackPolicyHandler(_this.getPlaybackMode());
        /** @protected */ _this.analyticPoller = null;
        _YoLog.YoLog.trace("sdk javascript " + Session.version() + " " + (0, _CollectionUtils.getKeyFromValue)(_this.getPlaybackMode(), PlaybackMode));
        _this.logSessionInfo();
        return _this;
    }
    Session.version = function version() {
        return pkg.version;
    };
    var _proto = Session.prototype;
    _proto.logSessionInfo = function logSessionInfo() {
        _YoLog.YoLog.logger.debug("Yospace AdManagement SDK for JavaScript v" + Session.version() + " (" + (0, _CollectionUtils.getKeyFromValue)(this.getPlaybackMode(), PlaybackMode) + ")");
        _YoLog.YoLog.logger.debug("Debug flags:");
        if (_YoLog.YoLog.getDebugFlags() === _YoLog.DebugFlags.DEBUG_ALL) _YoLog.YoLog.logger.debug("  DEBUG_ALL is set");
        else {
            for(var k in _YoLog.DebugFlags)if (_YoLog.DebugFlags[k] !== _YoLog.DebugFlags.DEBUG_ALL && _YoLog.DebugFlags[k] & _YoLog.YoLog.getDebugFlags()) _YoLog.YoLog.logger.debug("  " + k + " is set");
        }
        _YoLog.YoLog.logger.debug(this.getSessionProperties().toString());
    } /**
   * Register an AnalyticEventObserver instance to receive updates when analytic events are fired
   * @param {AnalyticEventObserver} observer the observer to register for analytic callbacks
   * @throws an Error if the observer is not valid
   */ ;
    _proto.addAnalyticObserver = function addAnalyticObserver(observer) {
        if (!(0, _CallbackHelper.isValidCallbackImplementation)(observer, _AnalyticEventObserver.AnalyticEventObserver)) throw new Error("addAnalyticObserver: invalid observer");
        this.reportsManager.addAnalyticObserver(observer);
        // Send notification for any parsing errors encountered during initialisation
        if (this.parsingErrors.length > 0) this.getReportsManager().raiseSessionErrorCallback(SessionErrorCode.PARSING_ERROR, this);
    };
    _proto.addParsingError = function addParsingError(error) {
        this.parsingErrors.push(error);
    };
    _proto.addTrackingError = function addTrackingError(error) {
        this.trackingErrors.push(error);
        this.reportsManager.raiseTrackingErrorCallback(error, this);
    };
    _proto.clearTrackingErrors = function clearTrackingErrors() {
        this.trackingErrors = [];
    } /**
   * Returns whether analytic tracking is currently suppressed for this playback session.
   * @return {boolean} true if analytic tracking is suppressed, false otherwise.
   */ ;
    _proto.analyticsSuppressed = function analyticsSuppressed() {
        return this.reportsManager.reportsSuppressed();
    };
    _proto.adjustForEarlyReturn = function adjustForEarlyReturn(playhead) {
        var ab = this.getAdBreakForPlayhead(playhead);
        if (ab && ab.adjustForEarlyReturn(playhead)) {
            this.getReportsManager().raiseAdBreakEarlyReturn(ab, this);
            if (!ab.isValid()) this.linearAdBreaks.splice(this.linearAdBreaks.indexOf(ab));
        }
    } /**
   * Implementation of {@link PlaybackPolicy} method
   * @param {boolean} mute The intended volume change: muted or unmuted
   * @return {boolean}
   */ ;
    _proto.canChangeVolume = function canChangeVolume(mute) {
        var ret = (0, _CallbackHelper.raiseCallback)(this.policyHandler, this.policyHandler.canChangeVolume, mute, this.playhead, this.linearAdBreaks);
        if (ret === null) ret = this.defaultPolicyHandler.canChangeVolume(mute, this.playhead, this.linearAdBreaks);
        return ret;
    } /**
   * Implementation of {@link PlaybackPolicy} method
   * @param {string} url The click-through Url.
   * @return {boolean} true if the user can click through, false otherwise.
   */ ;
    _proto.canClickThrough = function canClickThrough(url) {
        var ret = (0, _CallbackHelper.raiseCallback)(this.policyHandler, this.policyHandler.canClickThrough, url, this.playhead, this.linearAdBreaks);
        if (ret === null) ret = this.defaultPolicyHandler.canClickThrough(url, this.playhead, this.linearAdBreaks);
        return ret;
    } /**
   * Implementation of {@link PlaybackPolicy} method
   * @return {boolean} true if playback can pause, false otherwise.
   */ ;
    _proto.canPause = function canPause() {
        var ret = (0, _CallbackHelper.raiseCallback)(this.policyHandler, this.policyHandler.canPause, this.playhead, this.linearAdBreaks);
        if (ret === null) ret = this.defaultPolicyHandler.canPause(this.playhead, this.linearAdBreaks);
        return ret;
    } /**
   * Implementation of {@link PlaybackPolicy} method
   * @param {boolean} fullScreen The intended resize mode
   * @return {boolean} true if full screen mode can change, false otherwise.
   */ ;
    _proto.canResize = function canResize(fullscreen) {
        var ret = (0, _CallbackHelper.raiseCallback)(this.policyHandler, this.policyHandler.canResize, fullscreen, this.playhead, this.linearAdBreaks);
        if (ret === null) ret = this.defaultPolicyHandler.canResize(fullscreen, this.playhead, this.linearAdBreaks);
        return ret;
    } /**
   * Implementation of {@link PlaybackPolicy} method
   * @param {boolean} expand whether to expand the creative or collapse it
   * @return {boolean} true if the creative can be resized, false otherwise.
   */ ;
    _proto.canResizeCreative = function canResizeCreative(expand) {
        var ret = (0, _CallbackHelper.raiseCallback)(this.policyHandler, this.policyHandler.canResizeCreative, expand, this.playhead, this.linearAdBreaks);
        if (ret === null) ret = this.defaultPolicyHandler.canResizeCreative(expand, this.playhead, this.linearAdBreaks);
        return ret;
    } /**
   * Implementation of {@link PlaybackPolicy} method
   * @return {number} delay in seconds before the advert can be skipped, or -1 otherwise.
   */ ;
    _proto.canSkip = function canSkip() {
        var ret = (0, _CallbackHelper.raiseCallback)(this.policyHandler, this.policyHandler.canSkip, this.playhead, this.linearAdBreaks, 0);
        if (ret === null) ret = this.defaultPolicyHandler.canSkip(this.playhead, this.linearAdBreaks, 0);
        return ret;
    } /**
   * Implementation of {@link PlaybackPolicy} method
   * @return {boolean} true if playback can stop, false otherwise.
   */ ;
    _proto.canStop = function canStop() {
        var ret = (0, _CallbackHelper.raiseCallback)(this.policyHandler, this.policyHandler.canStop, this.playhead, this.linearAdBreaks);
        if (ret === null) ret = this.defaultPolicyHandler.canStop(this.playhead, this.linearAdBreaks);
        return ret;
    };
    _proto.clearParsingErrors = function clearParsingErrors() {
        this.parsingErrors = [];
    };
    _proto.completeWithStatus = function completeWithStatus(sessionState, code) {
        this.setState(sessionState);
        this.setResultCode(code);
        if (sessionState === SessionState.INITIALISED) _YoLog.YoLog.trace("sessionStart");
    };
    _proto.fireImpressionReport = function fireImpressionReport() {
        var advert = this.currentAdvert;
        if (advert && advert.isActive()) {
            var impressions = advert.getImpressions(true);
            if (impressions) {
                _YoLog.YoLog.trace("impression");
                var copy = impressions.copy();
                var params = new _ReportsManager.ReportingParams(this.getPlayhead(), advert.getStart(), advert.getLinearCreative().getAssetUri(), advert.getMacroSubstitutions());
                this.reportsManager.fireBeacon(copy, params);
                impressions.removeTrackingUrls();
            }
        }
    };
    _proto.fireTrackingReport = function fireTrackingReport(report) {
        var adStart = null;
        var assetUri = null;
        var macroSubs = null;
        var advert = this.getCurrentAdvert();
        if (advert) {
            adStart = advert.getStart();
            if (advert.getLinearCreative()) assetUri = advert.getLinearCreative().getAssetUri();
            macroSubs = advert.getMacroSubstitutions();
        }
        _YoLog.YoLog.trace("trackingEvent " + report.getEventType());
        var params = new _ReportsManager.ReportingParams(this.getPlayhead(), adStart, assetUri, macroSubs);
        this.reportsManager.fireBeacon(report, params);
    };
    _proto.fireTrackingReportForCreative = function fireTrackingReportForCreative(report, creative) {
        var assetUri = null;
        var advert = this.getAdvertForCreative(creative);
        if (advert) {
            if (advert.getLinearCreative()) assetUri = advert.getLinearCreative().getAssetUri();
            _YoLog.YoLog.trace("trackingEvent " + report.getEventType());
            var params = new _ReportsManager.ReportingParams(this.getPlayhead(), advert.getStart(), assetUri, advert.getMacroSubstitutions());
            this.reportsManager.fireBeacon(report, params);
        }
    };
    _proto.fireTrackingReportForIcon = function fireTrackingReportForIcon(report, icon) {
        var assetUri = null;
        var advert = this.currentAdvert;
        if (advert && advert.isActive() && advert.containsIcon(icon)) {
            if (advert.getLinearCreative()) assetUri = advert.getLinearCreative().getAssetUri();
            _YoLog.YoLog.trace("trackingEvent " + report.getEventType());
            var params = new _ReportsManager.ReportingParams(this.getPlayhead(), advert.getStart(), assetUri, advert.getMacroSubstitutions());
            this.reportsManager.fireBeacon(report, params);
        }
    };
    _proto.getAdBreakForPlayhead = function getAdBreakForPlayhead(playhead) {
        for(var _iterator = _createForOfIteratorHelperLoose(this.linearAdBreaks), _step; !(_step = _iterator()).done;){
            var ab = _step.value;
            if (ab.getStart() <= playhead && playhead < ab.getStart() + ab.getDuration()) return ab;
        }
        return null;
    } /**
   * @return {AdBreak[]} an array of {@link AdBreak} for this session, of the type specified.
   * @param {BreakType} type the type of break
   */ ;
    _proto.getAdBreaksByType = function getAdBreaksByType(type) {
        switch(type){
            case _AdBreak.BreakType.LINEAR:
                return Object.assign([], this.linearAdBreaks);
            case _AdBreak.BreakType.NONLINEAR:
                return Object.assign([], this.nonLinearAdBreaks);
            case _AdBreak.BreakType.DISPLAY:
                return Object.assign([], this.displayAdBreaks);
            default:
                return null;
        }
    };
    _proto.getAnalyticsUrl = function getAnalyticsUrl() {
        return this.analyticsUrl;
    };
    _proto.getAdvertForCreative = function getAdvertForCreative(creative) {
        // check if the creative is a linear from the currently-playing active advert
        var advert = this.currentAdvert;
        if (advert && advert.isActive() && advert.getLinearCreative() === creative) return advert;
        if (creative.isNonLinear()) {
            for(var _iterator2 = _createForOfIteratorHelperLoose(this.nonLinearAdBreaks), _step2; !(_step2 = _iterator2()).done;){
                var ab = _step2.value;
                advert = ab.getAdvertForCreative(creative);
                if (advert) return advert;
            }
            for(var _iterator3 = _createForOfIteratorHelperLoose(this.displayAdBreaks), _step3; !(_step3 = _iterator3()).done;){
                var _ab = _step3.value;
                advert = _ab.getAdvertForCreative(creative);
                if (advert) return advert;
            }
        } else {
            if (!(creative instanceof _LinearCreative.LinearCreative)) for(var _iterator4 = _createForOfIteratorHelperLoose(this.linearAdBreaks), _step4; !(_step4 = _iterator4()).done;){
                var _ab2 = _step4.value;
                advert = _ab2.getAdvertForCreative(creative);
                if (advert) return advert;
            }
        }
        return null;
    } /**
   * @return {AdBreak} the current {@link AdBreak}, or null if not in a break or if the adbreak is not known yet i.e.
   * the VAST document has not yet been received by the SDK for the break.
   */ ;
    _proto.getCurrentAdBreak = function getCurrentAdBreak() {
        return this.currentAdBreak;
    } /**
   * @return {Advert} the current {@link Advert}, or null if not in an advert.
   */ ;
    _proto.getCurrentAdvert = function getCurrentAdvert() {
        return this.currentAdvert;
    } /**
   * @returns {string} the unique identifier of the Session
   */ ;
    _proto.getIdentifier = function getIdentifier() {
        return this.identifier;
    };
    _proto.getJsonResponseUrl = function getJsonResponseUrl(content) {
        try {
            var data = JSON.parse(content);
            return data.url;
        } catch (e) {
            return null;
        }
    } /**
   * @return {PlaybackMode} the stream {@link PlaybackMode} for the Session
   */ ;
    _proto.getPlaybackMode = function getPlaybackMode() {
        throw new Error("This must be overridden");
    } /**
   * @return {string} the stream playback URL, as a `string`, to be played by the applications video player and which
   *          is monitored by this Session
   */ ;
    _proto.getPlaybackUrl = function getPlaybackUrl() {
        return this.playbackUrl;
    };
    _proto.getPlayhead = function getPlayhead() {
        return this.playhead;
    } /**
   *
   * @return {number} the Session result code
   */ ;
    _proto.getResultCode = function getResultCode() {
        return this.resultCode;
    };
    _proto.getLastAnalyticUpdate = function getLastAnalyticUpdate() {
        return this.lastAnalyticUpdate;
    };
    _proto.getLastPlayed = function getLastPlayed() {
        return this.lastPlayed;
    };
    _proto.getReportsManager = function getReportsManager() {
        return this.reportsManager;
    } /**
   * This method should be called in the client implementation of `onSessionError` or within the
   * lifetime of the error, which is until the next analytic payload is parsed.
   * @return {ParsingError[]} array of `SessionError`
   */ ;
    _proto.getParsingErrors = function getParsingErrors() {
        return Object.assign([], this.parsingErrors);
    } /**
   * <b>This method is deprecated. Use `onTrackingError` of {@link AnalyticEventObserver} instead.</b>
   * This method should be called in the client implementation of `onSessionError` or within the
   * lifetime of the error data, which is until the beginning of the next advert break.
   *
   * @return {TrackingError[]} array of `TrackingError`
   * @deprecated To be removed in 3.8 (see also SessionErrorCode.TRACKING_ERROR).
   */ ;
    _proto.getTrackingErrors = function getTrackingErrors() {
        return Object.assign([], this.trackingErrors);
    };
    _proto.getSessionProperties = function getSessionProperties() {
        return Object.freeze(this.sessionProperties);
    } /**
   * @return {SessionState} the state {@link SessionState} of the Session
   */ ;
    _proto.getSessionState = function getSessionState() {
        return this.sessionState;
    } /**
   * @return {string} the unique initialisation token used to identify a session
   */ ;
    _proto.getToken = function getToken() {
        return this.sessionProperties.getToken();
    };
    _proto.handleFallbackUrl = function handleFallbackUrl(body) {
        var playbackUrl = this.getJsonResponseUrl(body);
        if (playbackUrl && (0, _HttpUtils.getUrl)(playbackUrl)) {
            this.setPlaybackUrl(playbackUrl);
            this.completeWithStatus(SessionState.NO_ANALYTICS, FALLBACK_URL);
            return true;
        }
        this.completeWithStatus(SessionState.FAILED, FALLBACK_URL);
        return false;
    };
    _proto.isNotPlaying = function isNotPlaying() {
        return !this.playing;
    };
    _proto.isPlaybackBuffering = function isPlaybackBuffering() {
        return this.playbackBuffering;
    };
    _proto.normaliseAdBreakStart = function normaliseAdBreakStart(start, position) {
        // Get the last break end position if there is one
        var num = this.linearAdBreaks.length;
        if (num) {
            var last = this.linearAdBreaks[num - 1];
            var pos = (0, _AdBreak.normalisePosition)(position, start, _AdBreak.BreakType.LINEAR);
            // Check whether the position types are the same
            if (last.getPosition().toLowerCase() === pos.toLowerCase()) {
                var lastEndPosition = last.getStart() + last.getDuration();
                var maxVal = this.analyticPoller ? this.analyticPoller.getFrequency() : _Constant.Constant.DEFAULT_POLLING_DELAY;
                var tolerance = Math.min(this.sessionProperties.getConsecutiveBreakTolerance(), maxVal);
                // Check whether they are overlapping or the gap is less than one target duration
                if (lastEndPosition > start || start - lastEndPosition < tolerance) return lastEndPosition;
            }
        }
        return start;
    };
    _proto.onAdvertStart = function onAdvertStart(advert, _timestamp) {
        if (advert) _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_REPORTS, "onAdvertStart: " + (advert.isActive() ? "active " : "inactive ") + (advert.isFiller() ? "filler" : "advert") + ", duration: " + advert.getDuration() + ", trackingSchedule: " + (0, _CollectionUtils.mapToString)(advert.getTrackingSchedule()));
    };
    _proto.onAdvertSkip = function onAdvertSkip(playhead) {
        this.signalActionTrackingEvent("skip");
        if (this.policyHandler) (0, _CallbackHelper.raiseCallback)(this.policyHandler, this.policyHandler.didSkip, this.playhead, playhead, this.linearAdBreaks);
        this.playhead = playhead;
    };
    _proto.onPlaybackContinue = function onPlaybackContinue() {
        if (this.playbackBuffering) {
            this.playbackBuffering = false;
            _YoLog.YoLog.trace("playbackEvent continue");
        } else _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PLAYBACK, "Reporting CONTINUE when not buffering");
    };
    _proto.onPlayerEvent = function onPlayerEvent(event, playhead) {
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PLAYBACK, "New playback event: " + (0, _CollectionUtils.getKeyFromValue)(event, _PlaybackEventHandler.PlayerEvent) + ", playhead: " + playhead);
        switch(event){
            case _PlaybackEventHandler.PlayerEvent.START:
                this.onPlaybackStart(playhead);
                break;
            case _PlaybackEventHandler.PlayerEvent.STOP:
                this.onPlaybackStop();
                break;
            case _PlaybackEventHandler.PlayerEvent.PAUSE:
                this.onPlaybackPause();
                break;
            case _PlaybackEventHandler.PlayerEvent.RESUME:
                this.onPlaybackResume();
                break;
            case _PlaybackEventHandler.PlayerEvent.STALL:
                this.onPlaybackStall();
                break;
            case _PlaybackEventHandler.PlayerEvent.CONTINUE:
                this.onPlaybackContinue();
                break;
            case _PlaybackEventHandler.PlayerEvent.ADVERT_REWIND:
                this.onPlaybackRewind(playhead);
                break;
            case _PlaybackEventHandler.PlayerEvent.ADVERT_SKIP:
                this.onAdvertSkip(playhead);
                break;
            case _PlaybackEventHandler.PlayerEvent.SEEK:
                this.onPlaybackSeek(playhead);
                break;
            case _PlaybackEventHandler.PlayerEvent.PLAYBACK_READY:
                this.onPlaybackReady();
                break;
            default:
                _YoLog.YoLog.w("Unknown playback event: " + event);
        }
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PLAYBACK, "Playing: " + this.playing + ", Buffering: " + this.playbackBuffering);
    };
    _proto.onPlaybackPause = function onPlaybackPause() {
        if (this.playing) {
            this.playing = false;
            this.signalActionTrackingEvent("pause");
        } else _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PLAYBACK, "Reporting PAUSE when already paused");
    };
    _proto.onPlaybackResume = function onPlaybackResume() {
        if (!this.playing) {
            this.playing = true;
            this.signalActionTrackingEvent("resume");
        } else _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PLAYBACK, "Reporting RESUME when already paying");
    };
    _proto.onPlaybackReady = function onPlaybackReady() {
        _YoLog.YoLog.trace("playbackevent ready");
        if (this.getSessionState() !== SessionState.INITIALISED) _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PLAYBACK, "Reporting PLAYBACKREADY when the session is not initialised");
        else if (this.playing === true) _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PLAYBACK, "Reporting PLAYBACKREADY when playback has already begun");
    };
    _proto.onPlaybackRewind = function onPlaybackRewind(playhead) {
        this.signalActionTrackingEvent("rewind");
        this.playhead = playhead;
    };
    _proto.onPlaybackSeek = function onPlaybackSeek(playhead) {
        if (this.policyHandler) (0, _CallbackHelper.raiseCallback)(this.policyHandler, this.policyHandler.didSeek, this.playhead, playhead, this.linearAdBreaks);
        _YoLog.YoLog.trace("playbackEvent seek: " + playhead);
        this.playhead = playhead;
    };
    _proto.onPlaybackStall = function onPlaybackStall() {
        if (this.playing && !this.playbackBuffering) {
            this.playbackBuffering = true;
            _YoLog.YoLog.trace("playbackEvent stall");
        } else _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PLAYBACK, "Reporting STALL when not buffering");
    };
    _proto.onPlaybackStart = function onPlaybackStart(_playhead) {
        if (!this.playing) {
            this.playing = true;
            _YoLog.YoLog.trace("playbackEvent start");
        } else _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PLAYBACK, "Reporting START when already playing");
    };
    _proto.onPlaybackStop = function onPlaybackStop() {
        if (this.playing) {
            this.playing = false;
            this.playbackBuffering = false;
            _YoLog.YoLog.trace("playbackEvent stop");
            var ad = this.currentAdvert;
            if (ad) {
                var lc = ad.getLinearCreative();
                if (lc) {
                    var report = lc.getTrackingReport("closeLinear");
                    if (report) this.fireTrackingReport(report);
                }
            }
        }
    };
    _proto.onPlayheadSeek = function onPlayheadSeek(playhead) {
        if (this.policyHandler) (0, _CallbackHelper.raiseCallback)(this.policyHandler, this.policyHandler.didSeek, this.playhead, playhead, this.linearAdBreaks);
        _YoLog.YoLog.trace("playbackEvent seek: " + playhead);
        this.playhead = playhead;
    };
    _proto.onPlayheadUpdate = function onPlayheadUpdate(playhead) {
        // Trace the playhead at 5-second intervals
        if (this.lastTraced === 0 || playhead < this.lastTraced || playhead - this.lastTraced >= 5000) {
            _YoLog.YoLog.trace("sdk playhead " + playhead);
            this.lastTraced = playhead;
        }
        this.lastPlayed = this.playhead;
        this.playhead = playhead;
    };
    _proto.onSessionError = function onSessionError(errorCode) {
        _YoLog.YoLog.trace("sessionerror " + errorCode);
        _YoLog.YoLog.e("Yospace session has expired");
        if (errorCode === SessionErrorCode.TIMEOUT) this.setState(SessionState.SHUTDOWN);
        this.getReportsManager().raiseSessionErrorCallback(errorCode, this);
    };
    _proto.onTimedMetadata = function onTimedMetadata(_metadata) {
    // method overridden in SessionLive
    };
    _proto.onViewSizeChange = function onViewSizeChange(size) {
        switch(size){
            case _PlaybackEventHandler.ViewSize.EXPANDED:
                this.signalActionTrackingEvent("playerExpand");
                break;
            case _PlaybackEventHandler.ViewSize.COLLAPSED:
                this.signalActionTrackingEvent("playerCollapse");
                break;
            default:
                _YoLog.YoLog.w("Unknown ViewSize: " + (0, _CollectionUtils.getKeyFromValue)(size, _PlaybackEventHandler.ViewSize));
        }
    };
    _proto.onVolumeChange = function onVolumeChange(muted) {
        var event = muted ? "mute" : "unmute";
        this.signalActionTrackingEvent(event);
    };
    _proto.raiseTrackingCallbackForCreative = function raiseTrackingCallbackForCreative(event, creative) {
        var ad = this.getAdvertForCreative(creative);
        if (ad) {
            _YoLog.YoLog.trace("trackingEvent " + event);
            this.getReportsManager().raiseTrackingCallback(event, this);
        }
    } /** Removes all nonlinear ad breaks from the stream.
   */ ;
    _proto.removeAllNonLinearAdBreaks = function removeAllNonLinearAdBreaks() {
        this.nonLinearAdBreaks = [];
        this.displayAdBreaks = [];
    } /**
   * Remove the registration of an AnalyticEventObserver
   * @param {AnalyticEventObserver} observer the observer to de-register from analytic callbacks
   */ ;
    _proto.removeAnalyticObserver = function removeAnalyticObserver(observer) {
        this.reportsManager.removeAnalyticObserver(observer);
    } /** Removes a nonlinear adbreak from the stream.
   * @param {AdBreak} ab The nonlinear adbreak to remove.
   */ ;
    _proto.removeNonLinearAdBreak = function removeNonLinearAdBreak(ab) {
        for(var i = 0; i < this.nonLinearAdBreaks.length; ++i){
            var br = this.nonLinearAdBreaks[i];
            if (br === ab) {
                this.nonLinearAdBreaks.splice(i, 1);
                return;
            }
        }
        for(var _i = 0; _i < this.displayAdBreaks.length; ++_i){
            var _br = this.displayAdBreaks[_i];
            if (_br === ab) {
                this.displayAdBreaks.splice(_i, 1);
                return;
            }
        }
    };
    _proto.removeKeysFromTrackingSchedule = function removeKeysFromTrackingSchedule(keys) {
        for(var _iterator5 = _createForOfIteratorHelperLoose(keys), _step5; !(_step5 = _iterator5()).done;){
            var key = _step5.value;
            this.currentAdvert.removeFromTrackingSchedule(key);
        }
    };
    _proto.setAnalyticsUrl = function setAnalyticsUrl(analyticsUrl) {
        this.analyticsUrl = analyticsUrl;
    };
    _proto.setCurrentAdBreak = function setCurrentAdBreak(currentAdBreak) {
        this.currentAdBreak = currentAdBreak;
    };
    _proto.setCurrentAdvert = function setCurrentAdvert(currentAdvert) {
        this.currentAdvert = currentAdvert;
    };
    _proto.setIdentifier = function setIdentifier(identifier) {
        this.identifier = identifier;
    };
    _proto.setLastAnalyticUpdate = function setLastAnalyticUpdate(payload) {
        this.lastAnalyticUpdate = payload;
    } /**
   * Sets the playback policy handler instance on the Session. The Session delegates
   * calls made on PlaybackPolicy to the handler provided.
   * @param {PlaybackPolicyHandler | null} policyHandler the handler to which the Session delegates policy decisions, or null to set to the default
   */ ;
    _proto.setPlaybackPolicyHandler = function setPlaybackPolicyHandler(policyHandler) {
        if (policyHandler) {
            if (!(0, _CallbackHelper.isValidCallbackImplementation)(policyHandler, _PlaybackPolicyHandler.PlaybackPolicyHandler)) throw new Error("setPlaybackPolicyHandler: invalid playback handler");
            this.policyHandler = policyHandler;
        } else this.policyHandler = this.defaultPolicyHandler;
        (0, _CallbackHelper.raiseCallback)(this.policyHandler, this.policyHandler.setPlaybackMode, this.getPlaybackMode());
    };
    _proto.setPlaybackUrl = function setPlaybackUrl(playerUrl) {
        this.playbackUrl = playerUrl;
    };
    _proto.setPlayhead = function setPlayhead(playhead) {
        this.playhead = playhead;
    };
    _proto.setReportsManager = function setReportsManager(rm) {
        this.reportsManager = rm;
    };
    _proto.setResultCode = function setResultCode(resultCode) {
        this.resultCode = resultCode;
    };
    _proto.setState = function setState(sessionState) {
        this.sessionState = sessionState;
    } /**
   * Shutdown the current Session and release all resources. After this point the state and behaviour
   * is undefined and unsupported. The Session instance or subclass must not be used following this call.
   */ ;
    _proto.shutdown = function shutdown() {
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "Session shutdown");
        this.setState(SessionState.SHUTDOWN);
        this.onPlaybackStop();
        _YoLog.YoLog.trace("sessionEnd");
    };
    _proto.signalActionTrackingEvent = function signalActionTrackingEvent(event) {
        var advert = this.currentAdvert;
        if (advert && advert.isActive() && !advert.isFiller() && !(0, _StringUtils.isNullOrEmpty)(event)) {
            _YoLog.YoLog.trace("actionEvent " + event);
            var reports = advert.getTrackingReports(event);
            var params = new _ReportsManager.ReportingParams(this.getPlayhead(), advert.getStart(), advert.getLinearCreative().getAssetUri(), advert.getMacroSubstitutions());
            if (reports.length > 0) this.reportsManager.fireBeacons(reports, params);
            if (event !== "closeLinear") this.reportsManager.raiseTrackingCallback(event, this);
        }
    };
    _proto.signalNonLinearTrackingEvent = function signalNonLinearTrackingEvent(event) {
        var advert = this.currentAdvert;
        if (advert && advert.isActive() && !advert.isFiller() && !(0, _StringUtils.isNullOrEmpty)(event)) {
            _YoLog.YoLog.trace("nonlinearTrackingEvent " + event);
            var report = advert.getTrackingReportLinear(event);
            if (report) {
                var params = new _ReportsManager.ReportingParams(this.getPlayhead(), advert.getStart(), advert.getLinearCreative().getAssetUri(), advert.getMacroSubstitutions());
                this.reportsManager.fireBeacon(report, params);
            }
            this.reportsManager.raiseTrackingCallback(event, this);
        }
    };
    _proto.signalTimelineTrackingEvents = function signalTimelineTrackingEvents(elapsed) {
        var advert = this.currentAdvert;
        if (advert && advert.isActive() && !advert.isFiller()) {
            var params = new _ReportsManager.ReportingParams(this.getPlayhead(), advert.getStart(), advert.getLinearCreative().getAssetUri(), advert.getMacroSubstitutions());
            var keys = [];
            for(var _iterator6 = _createForOfIteratorHelperLoose(advert.getTrackingSchedule()), _step6; !(_step6 = _iterator6()).done;){
                var _step6$value = _step6.value, key = _step6$value[0], value = _step6$value[1];
                if (elapsed + _Constant.Constant.EVENT_CUEPOINT_TOL >= key) {
                    _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_REPORTS, "Tracking schedule entry retrieved: " + value);
                    keys.push(key);
                    var report = advert.getTrackingReportLinear(value);
                    if (report) this.reportsManager.fireBeacon(report, params);
                    var event = value.indexOf("progress") !== -1 ? "progress" : value;
                    _YoLog.YoLog.trace("timelineEvent " + event);
                    this.reportsManager.raiseTrackingCallback(event, this);
                }
            }
            this.removeKeysFromTrackingSchedule(keys);
        }
    };
    _proto.signalTrackingEvent = function signalTrackingEvent(event, report) {
        var advert = this.currentAdvert;
        if (advert && advert.isActive() && !advert.isFiller() && !(0, _StringUtils.isNullOrEmpty)(event)) {
            _YoLog.YoLog.trace("trackingEvent" + event);
            if (report) {
                var params = new _ReportsManager.ReportingParams(this.getPlayhead(), advert.getStart(), advert.getLinearCreative().getAssetUri(), advert.getMacroSubstitutions());
                this.reportsManager.fireBeacon(report, params);
            }
            this.reportsManager.raiseTrackingCallback(event, this);
        }
    } /**
   * Suppresses or enables remote analytic tracking calls. If analytic tracking is unsuppressed during an ad break
   * and the AdBreak has associated breakStart beacons then these will be fired immediately.
   * By default, analytic tracking calls are enabled.
   * @param {boolean} suppress If true then analytic tracking will be suppressed, otherwise it is enabled.
   */ ;
    _proto.suppressAnalytics = function suppressAnalytics(suppress) {
        this.reportsManager.suppressReports(suppress);
        if (!suppress && this.currentAdBreak) {
            var report = this.currentAdBreak.getTrackingReport("breakStart", true);
            this.getReportsManager().fireBeacon(report, new _ReportsManager.ReportingParams(this.getPlayhead()));
        }
    } /**
   * Implementation of {@link PlaybackPolicy} method
   * @param {number} position the playhead position, in milliseconds, that the user wishes to seek to
   * @return {number} the actual playhead position, in milliseconds, that the user can seek to, based on the implemented policy.
   */ ;
    _proto.willSeekTo = function willSeekTo(position) {
        var ret = this.policyHandler ? (0, _CallbackHelper.raiseCallback)(this.policyHandler, this.policyHandler.willSeekTo, position, this.linearAdBreaks, this.getPlayhead()) : position;
        if (ret === null) ret = this.defaultPolicyHandler.willSeekTo(position, this.linearAdBreaks, this.getPlayhead());
        return ret;
    };
    return Session;
}(_AnalyticBroker2.AnalyticBroker);
/**
 * Provides a means for a client to specify custom properties at session initialisation.
 */ var SessionProperties = exports.SessionProperties = /*#__PURE__*/ function() {
    /**
   *
   * @param {SessionProperties} [other] an optional SessionProperties object to copy
   */ function SessionProperties(other) {
        this.requestTimeout = other && other.requestTimeout ? other.requestTimeout : _Constant.Constant.REQUEST_TIMEOUT;
        this.resourceTimeout = other && other.resourceTimeout ? other.resourceTimeout : _Constant.Constant.REQUEST_TIMEOUT;
        this.userAgent = other ? other.userAgent : "";
        this.prefetchResources = other ? other.prefetchResources : false;
        this.fireHistoricalBeacons = other ? other.fireHistoricalBeacons : true;
        this.eventCategories = other ? other.eventCategories : 0;
        this.allowCorsForAnalytics = other ? other.allowCorsForAnalytics : false;
        this.setCustomHttpHeaders(other ? other.customHttpHeaders : new Map());
        this.useHttps = other ? other.useHttps : false;
        this.consecutiveBreakTolerance = other ? other.consecutiveBreakTolerance : 0;
        this.token = other ? other.token : Math.floor(Math.random() * 10e7);
    }
    /**
   * Sets the categories of tracking beacons to exclude from analytic suppression.<br/>
   * By default, no categories are set.
   * @param {number} categories the OR'ed set of categories to exclude from suppression.
   * @see {@link Session}.suppressAnalytics()
   * @see Suppression Categories
   */ var _proto2 = SessionProperties.prototype;
    _proto2.excludeFromSuppression = function excludeFromSuppression(categories) {
        this.eventCategories = categories;
    } /**
   * @return {Map} a Map containing the custom HTTP headers.  Returns null if not set.
   */ ;
    _proto2.getCustomHttpHeaders = function getCustomHttpHeaders() {
        return this.customHttpHeaders;
    } /**
   * @return {number} an OR'ed set of categories of events that are currently excluded from analytic suppression.
   * @see Suppression Categories
   */ ;
    _proto2.getExcludedCategories = function getExcludedCategories() {
        return this.eventCategories;
    } /**
    * @return {boolean} true if the SDK should fire timeline beacons for adverts that have finished
    * playing out. The SDK will only do this if it receives beacon data for the historical advert
    * while still playing back the ad break in which that advert was defined.
    */ ;
    _proto2.getFireHistoricalBeacons = function getFireHistoricalBeacons() {
        return this.fireHistoricalBeacons;
    } /**
    * @return {boolean} true if the Session should prefetch nonlinear resources for an advert
    */ ;
    _proto2.getPrefetchResources = function getPrefetchResources() {
        return this.prefetchResources;
    } /**
    * @return {number} the request timeout, in milliseconds, to use when attempting to establish an HTTP connection
   *  for session initialisation and CSM polling
    */ ;
    _proto2.getRequestTimeout = function getRequestTimeout() {
        return this.requestTimeout;
    } /**
   * @return {number} the resource timeout, in milliseconds, to use when executing an HTTP connection for firing
   * analytic beacons and fetching resources
   */ ;
    _proto2.getResourceTimeout = function getResourceTimeout() {
        return this.resourceTimeout;
    } /**
    * @return {string} the User Agent string used for initialisation calls and analytic calls (analytic calls require CORS requests)
    */ ;
    _proto2.getUserAgent = function getUserAgent() {
        return this.userAgent;
    } /**
   * @return {string} the unique initialisation token used to identify a session
   */ ;
    _proto2.getToken = function getToken() {
        return this.token;
    } /**
    * @return {boolean} whether to use CORS for analytics (defaults to `false`)
    */ ;
    _proto2.getAllowCorsForAnalytics = function getAllowCorsForAnalytics() {
        return this.allowCorsForAnalytics;
    } /**
    * @return {boolean} whether the SDK modifies all tracking beacons as necessary to use the HTTPS protocol
    */ ;
    _proto2.getApplyEncryptedTracking = function getApplyEncryptedTracking() {
        return this.useHttps;
    } /**
   * @return {number} the maximum consecutive ad break tolerance
   */ ;
    _proto2.getConsecutiveBreakTolerance = function getConsecutiveBreakTolerance() {
        return this.consecutiveBreakTolerance;
    } /**
    * Sets whether to allow CORS
    * @param {boolean} allowCorsForAnalytics The default value is `false`
    */ ;
    _proto2.setAllowCorsForAnalytics = function setAllowCorsForAnalytics(allowCorsForAnalytics) {
        this.allowCorsForAnalytics = allowCorsForAnalytics;
    } /**
    * Describes whether the SDK should modify all tracking beacons as necessary to use the HTTPS protocol.
    * @param {boolean} useHttps The default value is `false`.
    */ ;
    _proto2.setApplyEncryptedTracking = function setApplyEncryptedTracking(useHttps) {
        this.useHttps = useHttps;
    } /**
   * Sets the maximum distance, in milliseconds, between consecutive ad breaks for them to be considered "back to
   * back".  In this case, the SDK will adjust the start position of the subsequent ad break to match the end position
   * of the preceding ad break.
   *
   * The maximum value used is the segment length of the current stream's content.
   *
   * @param {number} consecutiveBreakTolerance the max consecutive ad breaks tolerance.  Default value is 0
   */ ;
    _proto2.setConsecutiveBreakTolerance = function setConsecutiveBreakTolerance(consecutiveBreakTolerance) {
        this.consecutiveBreakTolerance = consecutiveBreakTolerance;
    } /**
   * Sets the custom HTTP headers to be used when sending requests
   * @param {Map} customHttpHeaders
   */ ;
    _proto2.setCustomHttpHeaders = function setCustomHttpHeaders(customHttpHeaders) {
        if (customHttpHeaders) for(var _iterator7 = _createForOfIteratorHelperLoose(customHttpHeaders), _step7; !(_step7 = _iterator7()).done;){
            var _step7$value = _step7.value, key = _step7$value[0];
            if (key.toUpperCase() === "USER-AGENT") {
                _YoLog.YoLog.w("SessionProperties: 'User-Agent' ignored");
                customHttpHeaders["delete"](key);
            }
        }
        else customHttpHeaders = new Map();
        this.customHttpHeaders = customHttpHeaders;
    } /**
    * Sets whether the SDK should fire timeline beacons for adverts that have finished
    * playing out. The SDK will only do this if it receives beacon data for the historical advert
    * while still playing back the ad break in which that advert was defined.
    * A client may choose to disable this feature to prevent analytic beacons being counted
    * as fraudulent by Viewability logic embedded with or used by the client.
    * @param {boolean} fire whether the SDK should fire timeline beacons. The default value is `true`.
    */ ;
    _proto2.setFireHistoricalBeacons = function setFireHistoricalBeacons(fire) {
        this.fireHistoricalBeacons = fire;
    } /**
    * Sets whether to prefetch nonlinear resources defined in the VAST for this advert.
    * Prefetching resources allows the application to use or display the resource as soon
    * as the advert starts without the application having to fetch it first.
    * If the fetch is successful then resource is available from the NonLinearCreative
    * associated with the Advert.
    * @param {boolean} prefetch whether to prefetch nonlinear resources. The default value is `false`.
    */ ;
    _proto2.setPrefetchResources = function setPrefetchResources(prefetch) {
        this.prefetchResources = prefetch;
    } /**
    * Sets the timeout to use when attempting to establish an HTTP connection for session initialisation and CSM
    * polling.  This setting represents the timeout value for the entire request.
    * @param {number} requestTimeout the request timeout. The default value is 5000ms.
    */ ;
    _proto2.setRequestTimeout = function setRequestTimeout(requestTimeout) {
        this.requestTimeout = requestTimeout;
    } /**
   * Sets the timeout to use when executing an HTTP request for firing analytics beacons and fetching resources.
   * This setting represents the timeout value for the entire request.
   * @param {number} resourceTimeout the resource timeout. The default value is 5000ms.
   */ ;
    _proto2.setResourceTimeout = function setResourceTimeout(resourceTimeout) {
        this.resourceTimeout = resourceTimeout;
    } /**
   * @param {string} token the unique initialisation token used to identify a session
   */ ;
    _proto2.setToken = function setToken(token) {
        this.token = token;
    } /**
   * Sets the user agent to use when making tracking / analytic calls.
   * @param {string} userAgent the user agent. The default value is an empty String.
   */ ;
    _proto2.setUserAgent = function setUserAgent(userAgent) {
        this.userAgent = userAgent;
    };
    _proto2.toString = function toString() {
        return "Session Properties:\n  allowCorsForAnalytics: " + this.allowCorsForAnalytics + "\n" + "  applyEncryptedTracking: " + this.useHttps + "\n" + "  consecutiveBreakTolerance: " + this.consecutiveBreakTolerance + "\n" + "  customHttpHeaders: " + (0, _CollectionUtils.mapToString)(this.customHttpHeaders) + "\n" + "  eventCategories: " + this.eventCategories + "\n" + "  fireHistoricalBeacons: " + this.fireHistoricalBeacons + "\n" + "  prefetchResources: " + this.prefetchResources + "\n" + "  requestTimeout: " + this.requestTimeout + "\n" + "  resourceTimeout: " + this.resourceTimeout + "\n" + "  userAgent: " + this.userAgent + "\n" + "  token: " + this.token;
    };
    return SessionProperties;
}();

},{"69b3a3178da8650d":"5j00o","59b4e2395812c2a9":"kknG8","1a976bb0ba791707":"5jCzE","36b39b01677628fa":"8JE54","a927645a8ed28887":"9KS65","fc2be71405a10d7f":"7uXt7","2014fce9833c4d":"fbiP9","5eed4d40dd499218":"cPeeN","fc0494e87687a88d":"40OIt","decd12c8cf150665":"2wJyf","59cc23dfa00fdeff":"4Kn9B","6d12b9d4dc7f9dfa":"2pu2E","402bc9433cd37f79":"8raP1","55cdb77caa238ee6":"h21pj","9d94eb916f7f41c8":"cZC7f","cc4651636e807af8":"f3eUj","917eab0ec99b1680":"8IvwS","46bc32753a8d6b0a":"1qBrg","4eb0b5a8c1e8f2fa":"bs9by"}],"kknG8":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.ReportsManager = exports.ReportingParams = void 0;
var _ConversionUtils = require("47b0968488b88396");
var _TrackingReport = require("3e089321785ef51a");
var _YoLog = require("cafe7f481e36555f");
var _HttpUtils = require("cf8ce8c65ec4baa1");
var _StringUtils = require("68d9f2a72eb33878");
var _HttpConnection = require("7c28616031ae623f");
var _CallbackHelper = require("3f84c4017c85638b");
var _TrackingError = require("646ba4a8880dbc57");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
var ReportsManager = exports.ReportsManager = /*#__PURE__*/ function() {
    function ReportsManager(properties, addTrackingError) {
        /** @private */ this.properties = properties;
        /** @private */ this.suppress = false;
        /** @private */ this.observers = [];
        /** @private */ this.addTrackingError = addTrackingError;
    }
    var _proto = ReportsManager.prototype;
    _proto.addAnalyticObserver = function addAnalyticObserver(listener) {
        if (!listener) _YoLog.YoLog.e("addAnalyticObserver: listener was null");
        else this.observers.push(listener);
    };
    _proto.applyEncryptedTracking = function applyEncryptedTracking(url) {
        if (this.properties.getApplyEncryptedTracking()) url = url.replace("http:", "https:");
        return url;
    };
    _proto.fire = function fire(report, params) {
        var _this = this;
        var opts = {
            method: "GET"
        };
        if (!this.properties.getAllowCorsForAnalytics()) opts.mode = "no-cors";
        else if (!(0, _StringUtils.isNullOrEmpty)(this.properties.getUserAgent())) opts.headers = (0, _HttpUtils.createHeaders)(this.properties.getUserAgent());
        var _loop = function _loop() {
            var url = _step.value;
            _this.performMacroSubstitutionForUrl(url, params);
            _this.applyEncryptedTracking(url);
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_REPORTS, "Firing report url: " + url);
            _HttpConnection.HttpConnection.get(url, opts, _this.properties.getResourceTimeout()).then(function(response) {
                if (!response.ok && response.status !== 0) {
                    var trackingError = new _TrackingError.TrackingError(url, response.status, report.trackingEvent, report.getAdBreakIdentifier(), report.getMediaIdentifier());
                    _this.addTrackingError(trackingError);
                }
            });
        };
        for(var _iterator = _createForOfIteratorHelperLoose(report.getTrackingUrls()), _step; !(_step = _iterator()).done;)_loop();
    };
    _proto.fireBeacon = function fireBeacon(report, params) {
        if (report && report.getTrackingUrls().length > 0 && !this.shouldSuppress(report.event)) try {
            this.fire(report, params);
        } catch (e) {
            _YoLog.YoLog.e("Unable to fire tracking URLs for report: " + e);
            throw e;
        }
    };
    _proto.fireBeacons = function fireBeacons(reports, params) {
        var trackingUrls = [];
        for(var _iterator2 = _createForOfIteratorHelperLoose(reports), _step2; !(_step2 = _iterator2()).done;){
            var report = _step2.value;
            for(var _iterator3 = _createForOfIteratorHelperLoose(report.getTrackingUrls()), _step3; !(_step3 = _iterator3()).done;){
                var trackingUrl = _step3.value;
                trackingUrls.push(trackingUrl);
            }
        }
        this.fireBeacon(new _TrackingReport.TrackingReport("", trackingUrls), params);
    };
    _proto.performMacroSubstitutionForUrl = function performMacroSubstitutionForUrl(url, params) {
        var assetUri = "";
        var timeStamp = (0, _ConversionUtils.millisToTimestamp)(Date.now());
        var timeStr = (0, _ConversionUtils.millisToTimeString)(params.getPlayhead());
        var advertTimeStr = params.getAdvertStart() === -1 ? "-1" : (0, _ConversionUtils.millisToTimeString)(params.getAdvertStart());
        assetUri = encodeURIComponent(params.getAssetUri());
        timeStamp = encodeURIComponent(timeStamp);
        timeStr = encodeURIComponent(timeStr);
        advertTimeStr = encodeURIComponent(advertTimeStr);
        var rnd = 10000000 + Math.round(Math.random() * 100000000);
        url = url.replace("[ASSETURI]", assetUri).replace("%5BASSETURI%5D", assetUri).replace("[CACHEBUSTING]", rnd).replace("%5BCACHEBUSTING%5D", rnd).replace("[TIMESTAMP]", timeStamp).replace("%5BTIMESTAMP%5D", timeStamp).replace("[CONTENTPLAYHEAD]", timeStr).replace("%5BCONTENTPLAYHEAD%5D", timeStr).replace("[MEDIAPLAYHEAD]", timeStr).replace("%5BMEDIAPLAYHEAD%5D", timeStr).replace("[ADPLAYHEAD]", advertTimeStr).replace("%5BADPLAYHEAD%5D", advertTimeStr);
        // Replace any client-specified macros
        for(var _iterator4 = _createForOfIteratorHelperLoose(params.getMacroSubstitutions()), _step4; !(_step4 = _iterator4()).done;){
            var _step4$value = _step4.value, key = _step4$value[0], value = _step4$value[1];
            url = url.replace("[" + key + "]", value).replace("%5B" + key + "%5D", value);
        }
        // Replace any unknown macros
        url = url.replace(/\[(.*?)]/g, "-1");
        url = url.replace(/%5B(.*)%5D/g, "-1");
        return url;
    };
    _proto.raiseAdBreakEarlyReturn = function raiseAdBreakEarlyReturn(adBreak, session) {
        _YoLog.YoLog.trace("earlyreturn");
        for(var _iterator5 = _createForOfIteratorHelperLoose(this.observers), _step5; !(_step5 = _iterator5()).done;){
            var observer = _step5.value;
            (0, _CallbackHelper.raiseCallback)(observer, observer.onAdvertBreakEarlyReturn, adBreak, session);
        }
    };
    _proto.raiseAdBreakCallback = function raiseAdBreakCallback(event, adbreak, session) {
        if (event === "start") for(var _iterator6 = _createForOfIteratorHelperLoose(this.observers), _step6; !(_step6 = _iterator6()).done;){
            var observer = _step6.value;
            (0, _CallbackHelper.raiseCallback)(observer, observer.onAdvertBreakStart, adbreak, session);
        }
        else if (event === "end") for(var _iterator7 = _createForOfIteratorHelperLoose(this.observers), _step7; !(_step7 = _iterator7()).done;){
            var _observer = _step7.value;
            (0, _CallbackHelper.raiseCallback)(_observer, _observer.onAdvertBreakEnd, session);
        }
    };
    _proto.raiseAdvertCallback = function raiseAdvertCallback(event, advert, session) {
        if (event === "start") for(var _iterator8 = _createForOfIteratorHelperLoose(this.observers), _step8; !(_step8 = _iterator8()).done;){
            var observer = _step8.value;
            (0, _CallbackHelper.raiseCallback)(observer, observer.onAdvertStart, advert, session);
        }
        else if (event === "end") for(var _iterator9 = _createForOfIteratorHelperLoose(this.observers), _step9; !(_step9 = _iterator9()).done;){
            var _observer2 = _step9.value;
            (0, _CallbackHelper.raiseCallback)(_observer2, _observer2.onAdvertEnd, session);
        }
    };
    _proto.raiseAnalyticUpdateCallback = function raiseAnalyticUpdateCallback(session) {
        if (!this.suppress) for(var _iterator10 = _createForOfIteratorHelperLoose(this.observers), _step10; !(_step10 = _iterator10()).done;){
            var observer = _step10.value;
            (0, _CallbackHelper.raiseCallback)(observer, observer.onAnalyticUpdate, session);
        }
    };
    _proto.raiseSessionErrorCallback = function raiseSessionErrorCallback(errorCode, session) {
        for(var _iterator11 = _createForOfIteratorHelperLoose(this.observers), _step11; !(_step11 = _iterator11()).done;){
            var observer = _step11.value;
            (0, _CallbackHelper.raiseCallback)(observer, observer.onSessionError, errorCode, session);
        }
    };
    _proto.raiseTrackingCallback = function raiseTrackingCallback(event, session) {
        if (!this.shouldSuppress(event)) for(var _iterator12 = _createForOfIteratorHelperLoose(this.observers), _step12; !(_step12 = _iterator12()).done;){
            var observer = _step12.value;
            (0, _CallbackHelper.raiseCallback)(observer, observer.onTrackingEvent, event, session);
        }
    };
    _proto.raiseTrackingErrorCallback = function raiseTrackingErrorCallback(trackingError, session) {
        for(var _iterator13 = _createForOfIteratorHelperLoose(this.observers), _step13; !(_step13 = _iterator13()).done;){
            var observer = _step13.value;
            (0, _CallbackHelper.raiseCallback)(observer, observer.onTrackingError, trackingError, session);
        }
    };
    _proto.removeAnalyticObserver = function removeAnalyticObserver(listener) {
        this.observers.splice(this.observers.indexOf(listener));
    };
    _proto.reportsSuppressed = function reportsSuppressed() {
        return this.suppress;
    };
    _proto.shouldSuppress = function shouldSuppress(event) {
        var category = _TrackingReport.TrackingReport.categoryForEvent(event);
        return (this.properties.getExcludedCategories() & category) === 0 && this.suppress;
    };
    _proto.suppressReports = function suppressReports(suppress) {
        if (this.suppress !== suppress) {
            this.suppress = suppress;
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_REPORTS, suppress ? "Suppress reports" : "Unsuppress reports");
        }
    };
    return ReportsManager;
}();
var ReportingParams = exports.ReportingParams = /*#__PURE__*/ function() {
    function ReportingParams(playhead, advertStart, assetUri, macroSubstitutions) {
        /** @private */ this.playhead = playhead;
        /** @private */ this.advertStart = advertStart && advertStart >= 0 ? playhead - advertStart : -1;
        /** @private */ this.assetUri = assetUri ? assetUri : "";
        /** @private */ this.macroSubstitutions = macroSubstitutions ? macroSubstitutions : new Map();
    }
    var _proto2 = ReportingParams.prototype;
    _proto2.getAdvertStart = function getAdvertStart() {
        return this.advertStart;
    };
    _proto2.getAssetUri = function getAssetUri() {
        return this.assetUri;
    };
    _proto2.getMacroSubstitutions = function getMacroSubstitutions() {
        return this.macroSubstitutions;
    };
    _proto2.getPlayhead = function getPlayhead() {
        return this.playhead;
    };
    return ReportingParams;
}();

},{"47b0968488b88396":"8owmX","3e089321785ef51a":"fbiP9","cafe7f481e36555f":"9KS65","cf8ce8c65ec4baa1":"2wJyf","68d9f2a72eb33878":"7uXt7","7c28616031ae623f":"6cS9V","3f84c4017c85638b":"40OIt","646ba4a8880dbc57":"1qBrg"}],"8owmX":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.millisToTimeString = millisToTimeString;
exports.millisToTimestamp = millisToTimestamp;
exports.pdtToMillis = pdtToMillis;
exports.stringToIntegerNumber = stringToIntegerNumber;
exports.timeStringToMillis = timeStringToMillis;
/*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ function pdtToMillis(time, error) {
    if (!time || time.length === 0 || time.indexOf("T") === -1) return error;
    // Check whether no timezone is specified:
    // i. No '+' or '-' chars after the 'T'
    // ii. Final character is an integer
    //
    // If check passes, append a 'Z' to specify UTC
    var checkStr = time.substring(time.indexOf("T"), time.length - 1);
    if (checkStr.indexOf("+") === -1 && checkStr.indexOf("-") === -1 && Number.isInteger(Number.parseInt(time.charAt(time.length - 1)))) time = time + "Z";
    var millis = Date.parse(time);
    return Number.isNaN(millis) ? error : millis;
}
function timeStringToMillis(time, error) {
    var err = error !== undefined ? error : -1;
    if (!(typeof time === "string" && time.length > 0)) return err;
    var components = time.split(":");
    if (components.length !== 3) return err;
    var hours = parseInt(components[0]);
    var minutes = parseInt(components[1]);
    if (Number.isNaN(hours) || Number.isNaN(minutes)) return err;
    var seconds = 0;
    var milliseconds = 0;
    var secondsMs = components[2].split(".");
    if (secondsMs.length !== 2) seconds = parseInt(components[2]);
    else {
        seconds = parseInt(secondsMs[0]);
        milliseconds = parseInt(secondsMs[1]);
    }
    if (Number.isNaN(seconds) || Number.isNaN(milliseconds)) return err;
    if (hours > 23 || minutes > 59 || seconds > 59) return err;
    return hours * 3600000 + minutes * 60000 + seconds * 1000 + milliseconds;
}
function millisToTimestamp(millis) {
    return new Date(millis).toISOString();
}
function millisToTimeString(millis) {
    var second = Math.floor(millis / 1000 % 60);
    var minute = Math.floor(millis / 60000 % 60);
    var hour = Math.floor(millis / 3600000 % 24);
    millis = Math.round(millis % 1000);
    return "" + (hour < 10 ? 0 : "") + hour + ":" + (minute < 10 ? 0 : "") + minute + ":" + (second < 10 ? 0 : "") + second + "." + (millis < 10 ? "00" : millis < 100 ? "0" : "") + millis;
}
function stringToIntegerNumber(value, error) {
    var num = Number.parseInt(value);
    return Number.isInteger(num) ? num : error;
}

},{}],"fbiP9":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.TrackingReport = void 0;
var _Constant = require("e1e922e99a765deb");
var _YoLog = require("9d5b8b2127770bc4");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
var TrackingReport = exports.TrackingReport = /*#__PURE__*/ function() {
    TrackingReport.categoryForEvent = function categoryForEvent(event) {
        if (TrackingReport.isValidAdBreakEvent(event)) return _Constant.CAT_AD_BREAK_EVENTS;
        else if (TrackingReport.isTimelineEvent(event)) return _Constant.CAT_TIMELINE_EVENTS;
        return 0;
    };
    TrackingReport.isValidPlayerOperationEvent = function isValidPlayerOperationEvent(event) {
        return _Constant.PLAYER_OPERATION_EVENTS.indexOf(event) !== -1;
    };
    TrackingReport.isValidCompanionEvent = function isValidCompanionEvent(event) {
        return _Constant.COMPANION_EVENTS.indexOf(event) !== -1;
    };
    TrackingReport.isValidInteractiveEvent = function isValidInteractiveEvent(event) {
        return _Constant.INTERACTIVE_EVENTS.indexOf(event) !== -1;
    };
    TrackingReport.isValidLinearEvent = function isValidLinearEvent(event) {
        return _Constant.LINEAR_EVENTS.indexOf(event) !== -1;
    };
    TrackingReport.isValidNonLinearEvent = function isValidNonLinearEvent(event) {
        return _Constant.NON_LINEAR_EVENTS.indexOf(event) !== -1;
    };
    TrackingReport.isValidVerificationEvent = function isValidVerificationEvent(event) {
        return _Constant.VERIFICATION_EVENTS.indexOf(event) !== -1;
    };
    TrackingReport.isTimelineEvent = function isTimelineEvent(event) {
        return _Constant.TIMELINE_EVENTS.indexOf(event) !== -1;
    };
    TrackingReport.isValidAdBreakEvent = function isValidAdBreakEvent(event) {
        return _Constant.AD_BREAK_EVENTS.indexOf(event) !== -1;
    };
    TrackingReport.isValidVisibleEvent = function isValidVisibleEvent(event) {
        return _Constant.VISIBLE_EVENTS.indexOf(event) !== -1;
    };
    function TrackingReport(trackingEvent, trackingUrls, adBreakIdentifier, mediaIdentifier) {
        this.trackingEvent = trackingEvent;
        this.trackingUrls = JSON.parse(JSON.stringify(trackingUrls ? trackingUrls : []));
        this.adBreakIdentifier = adBreakIdentifier || "";
        this.mediaIdentifier = mediaIdentifier || "";
    }
    var _proto = TrackingReport.prototype;
    _proto.copy = function copy() {
        return new TrackingReport(this.trackingEvent, this.trackingUrls, this.adBreakIdentifier, this.mediaIdentifier);
    };
    _proto.addTrackingUrl = function addTrackingUrl(url) {
        if (!url) _YoLog.YoLog.e("addTrackingUrl: url was null");
        else this.trackingUrls.push(url);
    };
    _proto.getAdBreakIdentifier = function getAdBreakIdentifier() {
        return this.adBreakIdentifier;
    };
    _proto.getEventType = function getEventType() {
        return this.trackingEvent;
    };
    _proto.getMediaIdentifier = function getMediaIdentifier() {
        return this.mediaIdentifier;
    };
    _proto.getTrackingUrls = function getTrackingUrls() {
        return Object.assign([], this.trackingUrls);
    };
    _proto.removeTrackingUrls = function removeTrackingUrls() {
        this.trackingUrls = [];
    };
    _proto.toString = function toString() {
        var s = "";
        s += "Event:";
        s += this.trackingEvent;
        for(var _iterator = _createForOfIteratorHelperLoose(this.trackingUrls), _step; !(_step = _iterator()).done;){
            var trackingUrl = _step.value;
            s += "\n - Url:";
            s += trackingUrl;
        }
        return s;
    };
    return TrackingReport;
}();

},{"e1e922e99a765deb":"5j00o","9d5b8b2127770bc4":"9KS65"}],"40OIt":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.isValidCallbackImplementation = isValidCallbackImplementation;
exports.raiseCallback = raiseCallback;
var _YoLog = require("81021be267ebcc38");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
} /*
 * COPYRIGHT 2022,2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
//
// raiseCallback helper - safely calls a callback and handles any exception that may be encountered.
//
// Arguments:
//   owner: the owner of the function.  Without it, calls to 'this' will fail.  It is expected to be a valid object
//   but can be null if it is an anonymous function
//
//   func: the function name (without parentheses and arguments).
//
//   args: any argument that the function requires.  Can be null, undefined or left out completely
//
// Returns:
//   the result of the function call
//
// Example usages:
//   raiseCallback(observer, observer.callbackFunction, arg1, arg2, arg3);
//   raiseCallback(observer, observer.callbackFunction);
//   let result = raiseCallback(observer, observer.callbackFunction, arg1, arg2);
//
function raiseCallback(owner, func) {
    // Bind the function to its owner as it no longer has a context and calls to 'this' would fail.
    if (owner) func = func.bind(owner);
    var ret = null;
    try {
        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)args[_key - 2] = arguments[_key];
        ret = func.apply(void 0, args);
    } catch (e) {
        var f = func.toString();
        var reg = /function ([^\(]*)/;
        var name = reg.exec(f);
        // The regex is not expected to fail but let's not take chances
        if (name && name.length > 0) _YoLog.YoLog.e("Exception thrown from callback function " + name[1] + ": " + e);
        else _YoLog.YoLog.e("Exception thrown from callback function.");
    }
    return ret;
}
// Checks whether the passed object conforms sufficiently to fulfil the functionality of an interface of the specified
// type
function isValidCallbackImplementation(implementation, type) {
    if (!implementation) {
        _YoLog.YoLog.e(type.name + " has not been implemented");
        return false;
    }
    var success = true;
    var defaultImpl = new type();
    var propertyNames = Object.getOwnPropertyNames(type.prototype);
    // implementation could be a class instance that doesn't provide an implementation of all required functions, or it
    // could be a duck-typed object
    for(var _iterator = _createForOfIteratorHelperLoose(propertyNames), _step; !(_step = _iterator()).done;){
        var p = _step.value;
        // Ignore the constructor - a duck-typed object won't have one
        if (p === "constructor") continue;
        var implementedFunc = implementation[p];
        if (!implementedFunc) {
            _YoLog.YoLog.e(type.name + " does not implement " + p);
            success = false;
        } else if (implementedFunc.toString() === defaultImpl[p].toString()) {
            _YoLog.YoLog.e(type.name + " does not provide an override for " + p);
            success = false;
        }
    }
    return success;
}

},{"81021be267ebcc38":"9KS65"}],"1qBrg":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.TrackingError = void 0;
var _ConversionUtils = require("aeb260cd8319183a");
var _SessionError2 = require("a352361cdbb6acf1");
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
/**
 * An object containing details of any tracking errors that get reported.
 *
 * @hideconstructor
 */ var TrackingError = exports.TrackingError = /*#__PURE__*/ function(_SessionError) {
    _inheritsLoose(TrackingError, _SessionError);
    function TrackingError(url, errorCode, event, adBreakId, mediaId) {
        var _this;
        _this = _SessionError.call(this, (0, _ConversionUtils.millisToTimestamp)(Date.now())) || this;
        _this.adBreakIdentifier = adBreakId;
        _this.url = url;
        _this.errorCode = errorCode;
        _this.event = event;
        _this.mediaIdentifier = mediaId || "";
        return _this;
    }
    /**
   * @returns {string} the break identifier of the AdBreak, if defined.
   * May be an empty string
   */ var _proto = TrackingError.prototype;
    _proto.getAdBreakIdentifier = function getAdBreakIdentifier() {
        return this.adBreakIdentifier;
    } /**
   * @returns {string} the media identifier, if defined.
   * May be an empty string
   */ ;
    _proto.getMediaIdentifier = function getMediaIdentifier() {
        return this.mediaIdentifier;
    } /**
   * @returns {string} tracking URL without macro substitutions.
   * May be an empty string or malformed URL.
   */ ;
    _proto.getUrl = function getUrl() {
        return this.url;
    } /**
   * @returns {number} the error code result of the request. Valid error codes are:
   * - An HTTP status code not in the 200 range.
   * - -1: failed to establish an HTTP connection.
   * - -2: failed to complete connection or read the HTTP response before a timeout occurred.
   * - -3: the request URL is malformed.
   */ ;
    _proto.getErrorCode = function getErrorCode() {
        return this.errorCode;
    } /**
   * @returns {string} tracking event name ('firstQuartile', etc.).
   */ ;
    _proto.getEvent = function getEvent() {
        return this.event;
    };
    return TrackingError;
}(_SessionError2.SessionError);

},{"aeb260cd8319183a":"8owmX","a352361cdbb6acf1":"jhKFg"}],"jhKFg":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.SessionError = void 0;
/*
 * COPYRIGHT 2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ var SessionError = exports.SessionError = /*#__PURE__*/ function() {
    function SessionError(utcTimestamp) {
        this.utcTimestamp = utcTimestamp;
    }
    /**
   * @return {string} the error as a Json string
   */ var _proto = SessionError.prototype;
    _proto.toJsonString = function toJsonString() {
        return JSON.stringify(this);
    } /**
   * @returns {string} the time at which the error occurred, in ISO-8601 UTC. e.g. "2023-01-29T18:46:19Z".
   */ ;
    _proto.getUtcTimestamp = function getUtcTimestamp() {
        return this.utcTimestamp;
    };
    return SessionError;
}();

},{}],"5jCzE":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.AnalyticBroker = void 0;
var _PlaybackEventHandler2 = require("a2d299f7b3efe44f");
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
var AnalyticBroker = exports.AnalyticBroker = /*#__PURE__*/ function(_PlaybackEventHandler) {
    _inheritsLoose(AnalyticBroker, _PlaybackEventHandler);
    function AnalyticBroker() {
        return _PlaybackEventHandler.apply(this, arguments) || this;
    }
    var _proto = AnalyticBroker.prototype;
    _proto.addParsingError = function addParsingError(_parsingError) {
        throw new Error("Function must be overridden");
    };
    _proto.clearParsingErrors = function clearParsingErrors() {
        throw new Error("Function must be overridden");
    };
    _proto.fireTrackingReport = function fireTrackingReport(_report) {
        throw new Error("Function must be overridden");
    };
    _proto.fireTrackingReportForCreative = function fireTrackingReportForCreative(_report, _creative) {
        throw new Error("Function must be overridden");
    };
    _proto.fireTrackingReportForIcon = function fireTrackingReportForIcon(_report, _icon) {
        throw new Error("Function must be overridden");
    };
    _proto.raiseTrackingCallbackForCreative = function raiseTrackingCallbackForCreative(_event, _creative) {
        throw new Error("Function must be overridden");
    };
    _proto.getSessionProperties = function getSessionProperties() {
        throw new Error("Function must be overridden");
    };
    _proto.normaliseAdBreakStart = function normaliseAdBreakStart(_start, _position) {
        throw new Error("Function must be overridden");
    };
    return AnalyticBroker;
}(_PlaybackEventHandler2.PlaybackEventHandler);

},{"a2d299f7b3efe44f":"cPeeN"}],"cPeeN":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.ViewSize = exports.PlayerEvent = exports.PlaybackEventHandler = void 0;
var _PlaybackPolicy2 = require("ee67bd259495aeb9");
var _TimedMetadata = require("5d37f0257ca54607");
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// JsDoc/TS imports
/**
 * Enumeration of possible player events:
 * @category Enumerations
 * @enum {number}
 */ var PlayerEvent = exports.PlayerEvent = Object.freeze({
    /** Indicates that playback started. A client must send the `STOP` event when playback stops. */ START: 0,
    /** Indicates that playback stopped and the stream will no longer be played */ STOP: 1,
    /** Indicates that playback paused. A client must send the `RESUME` event when playback resumes. */ PAUSE: 2,
    /** Indicates that playback resumed after pausing */ RESUME: 3,
    /** Indicates that playback stalled as a result of buffering. A client must send the `CONTINUE` event when playback stops buffering. */ STALL: 4,
    /** Indicates that playback continued after stalling */ CONTINUE: 5,
    /** Indicates that the user rewound the advert */ ADVERT_REWIND: 6,
    /** Indicates that the user pressed the skip button for a skippable advert */ ADVERT_SKIP: 7,
    /** Indicates that playback seeked to a new position */ SEEK: 8,
    /** Indicates that playback is ready but not yet started */ PLAYBACK_READY: 9
});
/**
 * Enumeration of possible viewport sizes for the video screen:
 * @category Enumerations
 * @enum {number}
 */ var ViewSize = exports.ViewSize = Object.freeze({
    /** Indicates that the viewport was collapsed */ COLLAPSED: 0,
    /** Indicates that the viewport was expanded */ EXPANDED: 1
});
/**
 * PlaybackEventHandler declares a set of callback methods that allow clients to provide information
 * about the state of playback to the SDK.
 *
 * It is implemented by the Session-derived instance and clients <b>must</b> call each method at the
 * appropriate time so that the Session can signal analytics on behalf of the app.
 * @hideconstructor
 */ var PlaybackEventHandler = exports.PlaybackEventHandler = /*#__PURE__*/ function(_PlaybackPolicy) {
    _inheritsLoose(PlaybackEventHandler, _PlaybackPolicy);
    function PlaybackEventHandler() {
        return _PlaybackPolicy.apply(this, arguments) || this;
    }
    var _proto = PlaybackEventHandler.prototype;
    /** Indicates that a playback event occurred, for example playback started, stopped, paused.
   * volume are fired by the framework.
   @param {PlayerEvent} event the event, defined by the enum PlayerEvent
   @param {number} playhead the playhead position when the event occurred, in milliseconds
   @see {@link PlayerEvent}
   */ _proto.onPlayerEvent = function onPlayerEvent(event, playhead) {
        throw new Error("Function must be overridden");
    } /** Indicates that a playback position update occurred. Clients should call this method at a regular
   * cadence, for example every 200ms, to enable accurate analytics and timing in the SDK.
   @param {number} playhead the playhead position when the event occurred, in milliseconds
   */ ;
    _proto.onPlayheadUpdate = function onPlayheadUpdate(playhead) {
        throw new Error("Function must be overridden");
    } /** Indicates that timed metadata was collected from the stream. During playback of a linear stream
   * clients must call this method on receiving timed metadata events from the player - as a result
   * of ID3 tags (HLS) or EMSG (DASH).
   @param {TimedMetadata} metadata a timed metadata object representing the data from the stream
   @see {@link TimedMetadata}
   */ ;
    _proto.onTimedMetadata = function onTimedMetadata(metadata) {
        throw new Error("Function must be overridden");
    } /** Indicates that the player viewport size changed.
   @param {ViewSize} size The new player viewport size.
   @see {@link ViewSize}
   */ ;
    _proto.onViewSizeChange = function onViewSizeChange(size) {
        throw new Error("Function must be overridden");
    } /** Indicates that playback volume was muted or unmuted. Any tracking events associated with
   * volume are fired by the framework.
   @param {boolean} muted true if the volume was muted, false otherwise.
   */ ;
    _proto.onVolumeChange = function onVolumeChange(muted) {
        throw new Error("Function must be overridden");
    };
    return PlaybackEventHandler;
}(_PlaybackPolicy2.PlaybackPolicy);

},{"ee67bd259495aeb9":"lIDzX","5d37f0257ca54607":"50n6I"}],"lIDzX":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.PlaybackPolicy = void 0;
var _XmlValidation2 = require("93968fd4190e4abd");
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2021 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
/**
 * PlaybackPolicy declares a set of methods that provide playback policy decisions to the app.
 *
 * It is implemented by the Session-derived instance, which delegates calls to a policy adapter - if one
 * is attached. This allows the business logic of playback policy to be implemented in a single place.
 * @hideconstructor
 */ var PlaybackPolicy = exports.PlaybackPolicy = /*#__PURE__*/ function(_XmlValidation) {
    _inheritsLoose(PlaybackPolicy, _XmlValidation);
    function PlaybackPolicy() {
        return _XmlValidation.apply(this, arguments) || this;
    }
    var _proto = PlaybackPolicy.prototype;
    /** Returns to the client whether playback can stop.
   * If a custom implemented playback policy handler is not set on the session, a default value of
   * `true` is returned.
   * 
   * @return {boolean} true if playback can stop, false otherwise.
   */ _proto.canStop = function canStop() {
        throw new Error("Function must be overridden");
    } /** Returns to the client whether playback can pause.
   * If a custom implemented playback policy handler is not set on the session, a default value of
   * `false` for Live,
   * `true` for other playback modes
   *  is returned.
   * 
   * @return {boolean} true if playback can pause, false otherwise.
   */ ;
    _proto.canPause = function canPause() {
        throw new Error("Function must be overridden");
    } /** Returns to the client whether playback can skip.
   * If a custom implemented playback policy handler is not set on the session, a default value of
   * `-1` for Live and `0` for other playback modes is returned.
   * 
   * @return {number} delay in seconds before the advert can be skipped, or -1 otherwise.
   */ ;
    _proto.canSkip = function canSkip() {
        throw new Error("Function must be overridden");
    } /** Returns to the client the playhead position that the user can seek to.
   * If a custom implemented playback policy handler is not set on the session,
   * the current playhead position is returned for Live and the seek position is returned for other playback modes.
   * 
   * @param {number} position the playhead position, in milliseconds, that the user wishes to seek to
   * @return {number} the actual playhead position, in milliseconds, that the user can seek to, based on the implemented policy.
   */ ;
    _proto.willSeekTo = function willSeekTo(position) {
        throw new Error("Function must be overridden");
    } /** Returns to the client whether volume can be muted.
   * If a custom implemented playback policy handler is not set on the session, a default value of
   * `true` is returned.
   * 
   * @param {boolean} mute The intended volume change: muted or unmuted
   * @return {boolean} true if volume can be muted, false otherwise.
   */ ;
    _proto.canChangeVolume = function canChangeVolume(mute) {
        throw new Error("Function must be overridden");
    } /** Returns to the client whether full screen mode can change.
   * If a custom implemented playback policy handler is not set on the session, a default value of
   * `true` is returned.
   * 
   * @param {boolean} fullScreen The intended resize mode
   * @return {boolean} true if full screen mode can change, false otherwise.
   */ ;
    _proto.canResize = function canResize(fullScreen) {
        throw new Error("Function must be overridden");
    } /** Returns to the client whether the currently-displayed linear creative can be resized.
   * Note that this method is not applicable to nonlinear creative.
   * If a custom implemented playback policy handler is not set on the session, a default value of
   * `true` is returned.
   * 
   * @param {boolean} expand whether to expand the creative or collapse it
   * @return {boolean} true if the creative can be resized, false otherwise.
   */ ;
    _proto.canResizeCreative = function canResizeCreative(expand) {
        throw new Error("Function must be overridden");
    } /** Returns to the client whether the user can click-through.
   * If a custom implemented playback policy handler is not set on the session, a default value of
   * `true` is returned.
   *
   * @param {string} url The click-through Url.
   * @return {boolean} true if the user can click through, false otherwise.
   */ ;
    _proto.canClickThrough = function canClickThrough(url) {
        throw new Error("Function must be overridden");
    };
    return PlaybackPolicy;
}(_XmlValidation2.XmlValidation);

},{"93968fd4190e4abd":"6US9y"}],"50n6I":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.TypeWithinSegment = exports.TimedMetadata = void 0;
var _YoLog = require("e01443f88d796e79");
/*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ /**
 * Encapsulation of a timed metadata payload.
 * @hideconstructor
 */ var TimedMetadata = exports.TimedMetadata = /*#__PURE__*/ function() {
    function TimedMetadata(mediaId, segmentNumber, segmentCount, type, offset, playhead) {
        /** @private */ this.mediaId = TimedMetadata.decodeString(mediaId);
        /** @private */ this.offset = offset;
        /** @private */ this.segmentCount = segmentCount;
        /** @private */ this.segmentNumber = segmentNumber;
        /** @private */ this.playhead = playhead;
        /** @private */ this.timestamp = Date.now();
        /** @private */ this.typeWithinSegment = type;
    }
    /**
   * Factory method to create an instance of TimedMetadata
   * @param {string} ymid the YMID metadata frame ID (media Id)
   * @param {string} yseq the YSEQ metadata frame ID (sequence)
   * @param {string} ytyp the YTYP metadata frame ID (type within segment)
   * @param {number} ydur the YDUR metadata frame ID (offset from beginning of segment/fragment)
   * @param {number} playhead the playhead position at which this metadata is defined (in milliseconds)
   *
   * @return {TimedMetadata} a newly created metadata object
   */ TimedMetadata.createFromMetadata = function createFromMetadata(ymid, yseq, ytyp, ydur, playhead) {
        if (!ymid) {
            _YoLog.YoLog.e("Failed to interpret ymid");
            return null;
        }
        ytyp = TimedMetadata.decodeString(ytyp);
        var type = TypeWithinSegment.getForKey(ytyp);
        if (type === null || type === undefined) {
            _YoLog.YoLog.e("Failed to interpret ytyp");
            return null;
        }
        var seqElem = TimedMetadata.decodeString(yseq).split(":");
        if (seqElem.length !== 2) {
            _YoLog.YoLog.e("Failed to interpret yseq");
            return null;
        }
        var seqNum = parseInt(seqElem[0]);
        var seqCount = parseInt(seqElem[1]);
        if (isNaN(seqNum) || seqNum === 0 || isNaN(seqCount) || seqCount === 0) {
            _YoLog.YoLog.e("Failed to interpret yseq");
            return null;
        }
        var f = parseFloat(this.decodeString(ydur));
        var offset = Number.isNaN(f) ? 0 : Math.round(f * 1000);
        if (playhead < 0) {
            _YoLog.YoLog.w("Invalid playhead provided:" + playhead);
            return null;
        }
        return new TimedMetadata(ymid, seqNum, seqCount, type, offset, playhead);
    };
    TimedMetadata.decodeString = function decodeString(data) {
        return data && data.length > 0 && data[0] === 0x03 ? data.substring(1) : data;
    } /**
   * @return {string} the mediaId of the timed metadata
   */ ;
    var _proto = TimedMetadata.prototype;
    _proto.getMediaId = function getMediaId() {
        return this.mediaId;
    } /**
   * @return {number} the value of the metadata offset in seconds
   */ ;
    _proto.getOffset = function getOffset() {
        return this.offset;
    } /**
   * @return {number} the playhead position of the timed metadata, in milliseconds
   */ ;
    _proto.getPlayhead = function getPlayhead() {
        return this.playhead;
    } /**
   * @return {number} the number of segments making up the advert
   */ ;
    _proto.getSegmentCount = function getSegmentCount() {
        return this.segmentCount;
    } /**
   * @return {number} the segment number to which this timed metadata belongs 
   */ ;
    _proto.getSegmentNumber = function getSegmentNumber() {
        return this.segmentNumber;
    };
    _proto.getTimestamp = function getTimestamp() {
        return this.timestamp;
    } /**
   * @return {string} the position of the timed metadata within the segment: 'S' (start), 'M' (mid) or 'E' (end)
   */ ;
    _proto.getTypeWithinSegment = function getTypeWithinSegment() {
        return this.typeWithinSegment;
    } /**
   * @param {TimedMetadata} previous the timed metadata under test
   * @return {boolean} true if the metadata under test is a duplicate. For this to be true, mediaId, segment
   * number, type within segment and offset must be equal.
   */ ;
    _proto.isDuplicate = function isDuplicate(previous) {
        return previous ? this.mediaId === previous.mediaId && this.segmentNumber === previous.segmentNumber && this.segmentCount === previous.segmentCount && this.typeWithinSegment === previous.typeWithinSegment && this.offset === previous.offset : false;
    };
    _proto.isFirstInSequence = function isFirstInSequence() {
        return this.isFirstInSegment() && this.segmentNumber === 1;
    };
    _proto.isFirstInSegment = function isFirstInSegment() {
        return this.typeWithinSegment === TypeWithinSegment.START;
    };
    _proto.isInSequence = function isInSequence(previous) {
        if (!previous) return true;
        if (this.mediaId !== previous.mediaId) return this.isFirstInSequence();
        var segmentDelta = this.segmentNumber - previous.segmentNumber;
        if (segmentDelta === 0) return this.typeWithinSegment.isInSequence(previous.typeWithinSegment) || this.typeWithinSegment.isEqualMidType(previous.typeWithinSegment) && this.offset > previous.offset;
        return segmentDelta > 0;
    };
    _proto.isLastInSegment = function isLastInSegment() {
        return this.typeWithinSegment === TypeWithinSegment.END;
    };
    _proto.isLastInSequence = function isLastInSequence() {
        return this.isLastInSegment() && this.isLastSegment();
    };
    _proto.isLastSegment = function isLastSegment() {
        return this.segmentNumber === this.segmentCount;
    };
    _proto.toString = function toString() {
        return "Metadata [ @" + this.playhead + " / " + this.mediaId + " / " + this.segmentNumber + ":" + this.segmentCount + " / " + this.typeWithinSegment.key + " : " + this.offset + " ]";
    };
    return TimedMetadata;
}();
var TypeWithinSegment = exports.TypeWithinSegment = /*#__PURE__*/ function() {
    function TypeWithinSegment(key, order) {
        this.key = key;
        this.order = order;
    }
    TypeWithinSegment.getForKey = function getForKey(key) {
        if (!TypeWithinSegment.initialised) {
            var END = TypeWithinSegment.END;
            var MID = TypeWithinSegment.MID;
            var START = TypeWithinSegment.START;
            TypeWithinSegment.KEY_MAP.set(END.key, END);
            TypeWithinSegment.KEY_MAP.set(MID.key, MID);
            TypeWithinSegment.KEY_MAP.set(START.key, START);
            TypeWithinSegment.initialised = true;
        }
        return TypeWithinSegment.KEY_MAP.get(key);
    };
    var _proto2 = TypeWithinSegment.prototype;
    _proto2.isEqualMidType = function isEqualMidType(other) {
        if (!other) return false;
        return this.order === 1 && other.order === 1;
    };
    _proto2.isInSequence = function isInSequence(other) {
        if (!other) return true;
        return this.order > other.order;
    };
    return TypeWithinSegment;
}();
/** End type **/ TypeWithinSegment.END = new TypeWithinSegment("E", 2);
/** Mid type **/ TypeWithinSegment.MID = new TypeWithinSegment("M", 1);
/** Start type **/ TypeWithinSegment.START = new TypeWithinSegment("S", 0);
TypeWithinSegment.KEY_MAP = new Map();
TypeWithinSegment.initialised = false;

},{"e01443f88d796e79":"9KS65"}],"4Kn9B":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.DefaultPlaybackPolicyHandler = void 0;
var _PlaybackPolicyHandler = require("9150b419b97fd845");
var _Session = require("8acecf48d1e53d3d");
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// DefaultPlaybackPolicyHandler is a default implementation of the PlaybackPolicyHandler if a customer
// implemented policy handler is not provided.
var DefaultPlaybackPolicyHandler = exports.DefaultPlaybackPolicyHandler = /*#__PURE__*/ function(_PlaybackPolicyHandle) {
    _inheritsLoose(DefaultPlaybackPolicyHandler, _PlaybackPolicyHandle);
    function DefaultPlaybackPolicyHandler(playbackMode) {
        var _this;
        _this = _PlaybackPolicyHandle.call(this) || this;
        _this.playbackMode = playbackMode;
        return _this;
    }
    var _proto = DefaultPlaybackPolicyHandler.prototype;
    _proto.canStop = function canStop(_playhead, _timeline) {
        this.playbackMode, _Session.PlaybackMode.LIVE, _Session.PlaybackMode.DVRLIVE, _Session.PlaybackMode.VOD;
        return true;
    };
    _proto.canPause = function canPause(_playhead, _timeline) {
        switch(this.playbackMode){
            case _Session.PlaybackMode.LIVE:
                return false;
            case _Session.PlaybackMode.DVRLIVE:
            case _Session.PlaybackMode.VOD:
            default:
                return true;
        }
    };
    _proto.canSkip = function canSkip(_playhead, _timeline, _duration) {
        switch(this.playbackMode){
            case _Session.PlaybackMode.LIVE:
                return -1;
            case _Session.PlaybackMode.DVRLIVE:
                return 0;
            case _Session.PlaybackMode.VOD:
                return 0;
            default:
                return 0;
        }
    };
    _proto.willSeekTo = function willSeekTo(position, _timeline, playhead) {
        switch(this.playbackMode){
            case _Session.PlaybackMode.LIVE:
                return playhead;
            case _Session.PlaybackMode.DVRLIVE:
                return position;
            case _Session.PlaybackMode.VOD:
            default:
                return position;
        }
    };
    _proto.canChangeVolume = function canChangeVolume(_mute, _playhead, _timeline) {
        this.playbackMode, _Session.PlaybackMode.LIVE, _Session.PlaybackMode.DVRLIVE, _Session.PlaybackMode.VOD;
        return true;
    };
    _proto.canResize = function canResize(_fullScreen, _playhead, _timeline) {
        this.playbackMode, _Session.PlaybackMode.LIVE, _Session.PlaybackMode.DVRLIVE, _Session.PlaybackMode.VOD;
        return true;
    };
    _proto.canResizeCreative = function canResizeCreative(_expand, _playhead, _timeline) {
        this.playbackMode, _Session.PlaybackMode.LIVE, _Session.PlaybackMode.DVRLIVE, _Session.PlaybackMode.VOD;
        return true;
    };
    _proto.canClickThrough = function canClickThrough(_url, _playhead, _timeline) {
        this.playbackMode, _Session.PlaybackMode.LIVE, _Session.PlaybackMode.DVRLIVE, _Session.PlaybackMode.VOD;
        return true;
    };
    _proto.setPlaybackMode = function setPlaybackMode(mode) {
        this.playbackMode = mode;
    };
    _proto.didSkip = function didSkip(_from, _to, _timeline) {
    // This is intentionally left empty as no action is taken for default handler
    };
    _proto.didSeek = function didSeek(_from, _to, _timeline) {
    // This is intentionally left empty as no action is taken for default handler
    };
    return DefaultPlaybackPolicyHandler;
}(_PlaybackPolicyHandler.PlaybackPolicyHandler);

},{"9150b419b97fd845":"f3eUj","8acecf48d1e53d3d":"62muZ"}],"f3eUj":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.PlaybackPolicyHandler = void 0;
var _Session = require("5f144d70c542da99");
/*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ // JsDoc imports
/**
 * PlaybackPolicyHandler declares a set of methods that provide playback policy decisions to the app.
 *
 * It is implemented by a policy adapter; policy calls to PlaybackPolicy on the Session-derived instance
 * are delegated to this adapter.
 * @hideconstructor
 */ var PlaybackPolicyHandler = exports.PlaybackPolicyHandler = /*#__PURE__*/ function() {
    function PlaybackPolicyHandler() {}
    var _proto = PlaybackPolicyHandler.prototype;
    /** Returns to the client whether playback can stop.
   * @param {number} playhead The current playhead position, in milliseconds
   * @param {Array} timeline The stream timeline represented as an array of AdBreak objects
   * @return {boolean} true if playback can stop, false otherwise.
   */ _proto.canStop = function canStop(playhead, timeline) {
        throw new Error("Must be overridden");
    } /** Returns to the client whether playback can pause.
   * @param {number} playhead The current playhead position, in milliseconds
   * @param {Array} timeline The stream timeline represented as an array of AdBreak objects
   * @return {boolean} true if playback can pause, false otherwise.
   */ ;
    _proto.canPause = function canPause(playhead, timeline) {
        throw new Error("Must be overridden");
    } /** Returns to the client whether playback can skip.
   * @param {number} playhead The current playhead position, in milliseconds
   * @param {Array} timeline The stream timeline represented as an array of AdBreak objects
   * @param {number} duration The non-linear stream duration in milliseconds, or zero if the stream is live
   * @return {number} delay in seconds before the advert can be skipped, or -1 otherwise.
   */ ;
    _proto.canSkip = function canSkip(playhead, timeline, duration) {
        throw new Error("Must be overridden");
    } /** Returns to the client the playhead position that the user can seek to.
   * @param {number} position the playhead position in milliseconds that the user wishes to seek to
   * @param {Array} timeline The stream timeline represented as an array of AdBreak objects
   * @param {number} playhead the playhead position in milliseconds that the user wishes to seek from
   * @return {number} the actual playhead position that the user can seek to, based on the implemented policy.
   */ ;
    _proto.willSeekTo = function willSeekTo(position, timeline, playhead) {
        throw new Error("Must be overridden");
    } /** Returns to the client whether volume can be muted.
   * @param {boolean} mute The intended volume change: muted or unmuted
   * @param {number} playhead The current playhead position, in milliseconds
   * @param {Array} timeline The stream timeline represented as an array of AdBreak objects
   * @return {boolean} true if volume can be muted, false otherwise.
   */ ;
    _proto.canChangeVolume = function canChangeVolume(mute, playhead, timeline) {
        throw new Error("Must be overridden");
    } /** Returns to the client whether full screen mode can change.
   * @param {boolean} fullScreen The target full screen mode
   * @param {number} playhead The current playhead position, in milliseconds
   * @param {Array} timeline The stream timeline represented as an array of AdBreak objects
   * @return {boolean} true if the player can go full screen, false otherwise.
   */ ;
    _proto.canResize = function canResize(fullScreen, playhead, timeline) {
        throw new Error("Must be overridden");
    } /** Returns to the client whether the currently-displayed linear creative can be expanded.
   * Note that this method is not applicable to nonlinear creative.
   * 
   * @param {boolean} expand whether to expand the creative or collapse it
   * @param {number} playhead The current playhead position, in milliseconds
   * @param {Array} timeline The stream timeline represented as an array of AdBreak objects
   * @return {boolean} true if the linear creative can be expanded, false otherwise.
   */ ;
    _proto.canResizeCreative = function canResizeCreative(expand, playhead, timeline) {
        throw new Error("Must be overridden");
    } /** Returns to the client whether the user can click-through.
   * @param {string} url The click-through Url.
   * @param {number} playhead The current playhead position, in milliseconds
   * @param {Array} timeline The stream timeline represented as an array of AdBreak objects
   * @return {boolean} true if the user can click through, false otherwise.
   */ ;
    _proto.canClickThrough = function canClickThrough(url, playhead, timeline) {
        throw new Error("Must be overridden");
    } /** Sets the playback mode that the stream is running in. The policy handler implementation may
   * use this to modify the policy for specific requests, for example allowing pause in
   * Video-on-Demand but not live playback.
   * @param {PlaybackMode} mode the stream playback mode
   */ ;
    _proto.setPlaybackMode = function setPlaybackMode(mode) {
        throw new Error("Must be overridden");
    } /** Indicates that playback was skipped.
   * @param {number} from the playhead position in milliseconds prior to skipping
   * @param {number} to the playhead position in milliseconds after to skipping
   * @param {Array} timeline The stream timeline represented as an array of AdBreak objects
   */ ;
    _proto.didSkip = function didSkip(from, to, timeline) {
        throw new Error("Must be overridden");
    } /** Indicates that playback seeked.
   * @param {number} from the playhead position in milliseconds prior to seeking
   * @param {number} to the playhead position in milliseconds after to seeking
   * @param {Array} timeline The stream timeline represented as an array of AdBreak objects
   */ ;
    _proto.didSeek = function didSeek(from, to, timeline) {
        throw new Error("Must be overridden");
    };
    return PlaybackPolicyHandler;
}();

},{"5f144d70c542da99":"62muZ"}],"2pu2E":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.copyMap = copyMap;
exports.getKeyFromValue = getKeyFromValue;
exports.mapToString = mapToString;
exports.objectToMap = objectToMap;
var _YoLog = require("9156f5bbf55ee1af");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
} /*
 * COPYRIGHT 2020,2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
function copyMap(m) {
    var map = new Map();
    for(var _iterator = _createForOfIteratorHelperLoose(m), _step; !(_step = _iterator()).done;){
        var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
        map.set(key, value);
    }
    return map;
}
function objectToMap(o) {
    var m = new Map();
    if (o) for(var v in o)m.set(v, o[v]);
    return m;
}
function mapToString(m) {
    if (!m) return "{}";
    return "{" + Array.from(m, function(_ref) {
        var name = _ref[0], value = _ref[1];
        return name + ": " + value;
    }).join(", ") + "}";
}
function getKeyFromValue(value, obj) {
    if (!obj) {
        _YoLog.YoLog.e("getKeyFromValue: obj is null");
        return null;
    }
    for(var _i = 0, _Object$entries = Object.entries(obj); _i < _Object$entries.length; _i++){
        var _Object$entries$_i = _Object$entries[_i], k = _Object$entries$_i[0], v = _Object$entries$_i[1];
        if (value === v) return k;
    }
    return null;
}

},{"9156f5bbf55ee1af":"9KS65"}],"8raP1":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.AnalyticEventObserver = void 0;
var _Advert = require("c60ccb3ce1fdcaae");
var _AdBreak = require("100a0de852648fcb");
var _Session = require("4157a57e3dc172fd");
var _TrackingError = require("8ea1f5ce34465800");
/*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ // JsDoc imports
/**
 * AnalyticEventObserver is the analytics observing interface to the SDK; implementers that are
 * registered with a concrete subclass of Session will receive callbacks on the methods detailed
 * below when the specified events occur.
 * @see {@link Session}.addAnalyticObserver()
 * @hideconstructor
 */ var AnalyticEventObserver = exports.AnalyticEventObserver = /*#__PURE__*/ function() {
    function AnalyticEventObserver() {}
    var _proto = AnalyticEventObserver.prototype;
    /**
   * Called when an ad break starts
   * @param {AdBreak} adBreak the ad break that has started
   * @param {Session} session the Session that triggered the event
   */ _proto.onAdvertBreakStart = function onAdvertBreakStart(adBreak, session) {
        throw new Error("Function must be overridden");
    } /**
   * Called when an ad break ends
   * @param {Session} session the Session that triggered the event
   */ ;
    _proto.onAdvertBreakEnd = function onAdvertBreakEnd(session) {
        throw new Error("Function must be overridden");
    } /**
   * Called when an ad break returns early
   * @param {AdBreak} adBreak the ad break that has returned
   * @param {Session} session the Session that triggered the event
   */ ;
    _proto.onAdvertBreakEarlyReturn = function onAdvertBreakEarlyReturn(adBreak, session) {
        throw new Error("Function must be overridden");
    } /**
   * Called when playback of an advert ends
   * @param {Session} session the Session that triggered the event
   */ ;
    _proto.onAdvertEnd = function onAdvertEnd(session) {
        throw new Error("Function must be overridden");
    } /**
   * Called when playback of an advert starts
   * @param {Advert} advert the advert that has started
   * @param {Session} session the Session that triggered the event
   */ ;
    _proto.onAdvertStart = function onAdvertStart(advert, session) {
        throw new Error("Function must be overridden");
    } /**
   * Indicates that a VMAP payload was received and processed from the Central Streaming Manager during playback
   * of a stream in respect of upcoming adverts. A client can read the ad break update from the Session.
   * @see {@link Session}.getAdBreaks()
   * @param {Session} session the Session that triggered the event
   */ ;
    _proto.onAnalyticUpdate = function onAnalyticUpdate(session) {
        throw new Error("Function must be overridden");
    } /**
   * Called when a tracking URL is called against the specified Advert.
   *
   * Possible events are:
   * - `loaded`, `start`, `firstQuartile`, `midpoint`, `thirdQuartile`, `complete`
   * - `pause`, `resume`, `rewind`, `skip`, `playerExpand`, `playerCollapse`, `mute`, `unmute`
   * - `ClickTracking`, `acceptInvitation`
   *
   * @param {string} type the tracking type
   * @param {Session} session the `Session` that triggered the event
   */ ;
    _proto.onTrackingEvent = function onTrackingEvent(type, session) {
        throw new Error("Function must be overridden");
    } /**
   * Called when a session reports an error
   * @param {SessionErrorCode} errorCode the error code associated with the event
   * @param {Session} session the Session that triggered the event
   */ ;
    _proto.onSessionError = function onSessionError(errorCode, session) {
        throw new Error("Function must be overridden");
    } /**
   * Called when a session reports a tracking error
   * @param {TrackingError} trackingError the error object associated with the event
   * @param {Session} session the Session that triggered the event
   */ ;
    _proto.onTrackingError = function onTrackingError(trackingError, session) {
        throw new Error("Function must be overridden");
    };
    return AnalyticEventObserver;
}();

},{"c60ccb3ce1fdcaae":"h21pj","100a0de852648fcb":"8JE54","4157a57e3dc172fd":"62muZ","8ea1f5ce34465800":"1qBrg"}],"cZC7f":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.LinearCreative = void 0;
var _Creative2 = require("5863def8ae7bb932");
var _ConversionUtils = require("1a5553b4b12d8464");
var _VideoClicks = require("7208122c4beef4d9");
var _YoLog = require("90a189948196c9f5");
var _TrackingReport = require("8eb74c8f0d11f66b");
var _CreativeUtils = require("2077a8cbcc1267e");
var _StringUtils = require("1a01ef441d7e20e1");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
/**
 * Represents a linear creative object.
 *
 * Encapsulates the data from the `<Linear>` element of a VAST document and represents the actual
 * video content of an advert.<br/>
 * The creative may contain one or more industry icons that can be overlaid on top of the video
 * to provide some extended functionality for the advert.
 *
 * <b>NOTE:</b> The class implements CreativeEventHandler so that it can raise `ClickTracking` and analytic
 * events on behalf of a client. It supports the following event strings:
 * - `customClick`
 * 
 *  @hideconstructor
  * @see {@link Creative}, which this class extends
*/ var LinearCreative = exports.LinearCreative = /*#__PURE__*/ function(_Creative) {
    _inheritsLoose(LinearCreative, _Creative);
    function LinearCreative(creativeData, videoClicks, interactiveCreative, broker) {
        var _this;
        _this = _Creative.call(this, creativeData) || this;
        /** @private */ _this.duration = (0, _ConversionUtils.timeStringToMillis)(creativeData.duration, 0);
        /** @private */ _this.trackingMap = creativeData.trackingMap ? creativeData.trackingMap : new Map();
        /** @private */ _this.videoClicks = videoClicks ? videoClicks : new _VideoClicks.VideoClicks("", null, null);
        /** @private */ _this.icons = creativeData.icons;
        /** @private */ _this.assetUri = creativeData.currentAssetUri ? creativeData.currentAssetUri : "";
        /** @private */ _this.interactiveCreative = interactiveCreative;
        /** @private */ _this.skipOffset = creativeData.skipOffset;
        /** @private */ _this.broker = broker;
        return _this;
    }
    var _proto = LinearCreative.prototype;
    _proto.getAssetUri = function getAssetUri() {
        return this.assetUri;
    } /**
   * @return {string} the clickthrough URL of the linear creative portion of this Advert as a `string`
   */ ;
    _proto.getClickThroughUrl = function getClickThroughUrl() {
        return this.videoClicks.getClickThroughUrl();
    };
    _proto.getClickTrackingUrls = function getClickTrackingUrls() {
        return this.videoClicks.getClickTrackingUrls();
    } /**
   * @return {string[]} a string array of custom click URLs associated with the LinearCreative, which may be empty
   */ ;
    _proto.getCustomClickUrls = function getCustomClickUrls() {
        return this.videoClicks.getCustomClicks();
    };
    _proto.getDuration = function getDuration() {
        return this.duration;
    };
    _proto.getIndustryIcons = function getIndustryIcons() {
        return Object.assign([], this.icons);
    };
    _proto.getInteractiveCreative = function getInteractiveCreative() {
        return this.interactiveCreative;
    };
    _proto.getSkipOffset = function getSkipOffset() {
        if (!this.skipOffset || this.skipOffset === "") return -1;
        if (this.skipOffset.indexOf("%") !== -1) {
            var val = parseFloat(this.skipOffset.substring(0, this.skipOffset.length - 1));
            if (val) return Math.round(val * this.duration / 100.0);
            else {
                _YoLog.YoLog.w("Invalid skipoffset string: " + this.skipOffset);
                return -1;
            }
        } else return (0, _ConversionUtils.timeStringToMillis)(this.skipOffset, -1);
    };
    _proto.getTrackingMap = function getTrackingMap() {
        return this.trackingMap;
    };
    _proto.getTrackingReport = function getTrackingReport(type) {
        if (!this.trackingMap.has(type)) return null;
        return this.trackingMap.get(type);
    };
    _proto.initialiseInteractiveCreative = function initialiseInteractiveCreative(nonlinearCreatives) {
        if (this.interactiveCreative) this.interactiveCreative.initialise(this.getAdParameters(), this.duration, nonlinearCreatives);
    };
    _proto.isNonLinear = function isNonLinear() {
        return false;
    };
    _proto.isValid = function isValid() {
        return this.duration > 0;
    };
    _proto.onClickThrough = function onClickThrough() {
        var urls = this.videoClicks.getClickTrackingUrls();
        if (urls.length > 0) {
            var report = (0, _CreativeUtils.getClickTrackingReport)(urls, "ClickTracking");
            this.broker.fireTrackingReportForCreative(report, this);
        }
        // SDK-811: required for OMID
        this.broker.raiseTrackingCallbackForCreative("ClickTracking", this);
    };
    _proto.onTrackingEvent = function onTrackingEvent(event) {
        if (event === "customClick") {
            var customClicks = this.videoClicks.getCustomClicks();
            if (customClicks.length) {
                var report = new _TrackingReport.TrackingReport(event, customClicks);
                this.broker.fireTrackingReportForCreative(report, this);
            }
        } else {
            if (_TrackingReport.TrackingReport.isValidPlayerOperationEvent(event)) {
                _YoLog.YoLog.w("Use PlaybackEventHandler functions to signal event " + event);
                return;
            }
            if (_TrackingReport.TrackingReport.isTimelineEvent(event)) {
                _YoLog.YoLog.w("Invalid event: " + event + ". Timeline events are signalled by position updates");
                return;
            }
            var _report = this.trackingMap.get(event);
            if (_report) this.broker.fireTrackingReportForCreative(_report, this);
        }
    };
    _proto.setDuration = function setDuration(duration) {
        this.duration = duration;
    };
    _proto.toString = function toString() {
        var s = "";
        if (this.trackingMap.size > 0) {
            s += "\n ** Tracking events - ";
            for(var _iterator = _createForOfIteratorHelperLoose(this.trackingMap), _step; !(_step = _iterator()).done;){
                var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
                s += (0, _StringUtils.toIndentedString)("\n " + key + ":" + value);
            }
        }
        var iconString = "";
        if (this.icons.length > 0) {
            iconString += "\n  ** Industry Icon(s) - ";
            for(var _iterator2 = _createForOfIteratorHelperLoose(this.icons), _step2; !(_step2 = _iterator2()).done;){
                var icon = _step2.value;
                iconString += icon;
            }
        }
        var linearString = "\n--- Linear Creative:\n - assetUri:";
        linearString += this.assetUri;
        if (this.interactiveCreative) linearString += this.interactiveCreative;
        linearString += _Creative.prototype.toString.call(this);
        if (!(0, _StringUtils.isNullOrEmpty)(this.skipOffset)) {
            linearString += "\n - SkipOffset:";
            linearString += this.skipOffset;
        }
        linearString += s;
        linearString += (0, _StringUtils.toIndentedString)(this.videoClicks);
        linearString += iconString;
        return linearString;
    };
    return LinearCreative;
}(_Creative2.Creative);

},{"5863def8ae7bb932":"fZ00L","1a5553b4b12d8464":"8owmX","7208122c4beef4d9":"bOBcw","90a189948196c9f5":"9KS65","8eb74c8f0d11f66b":"fbiP9","2077a8cbcc1267e":"92ZM9","1a01ef441d7e20e1":"7uXt7"}],"fZ00L":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.Creative = void 0;
var _StringUtils = require("29e82c845fc5a980");
var _CreativeEventHandler2 = require("edb485d439ac49b8");
var _XmlNode = require("fa3bd6d39ce2f80a");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// Imports for jsdoc
/**
* Represents a creative object.
*
* Encapsulates the data from the `<Creative>` element of a VAST document and is the base class for three types:
* - `Linear` - the creative that represents the linear portion of an advert i.e. the actual video content.
* - `NonLinear` - the creative that is usually a graphic that overlays a small portion of the advert's video and is normally clickable.
* - `Companion` - the creative that is normally presented outside the video player.
* 
*  @hideconstructor
* @see {@link CreativeEventHandler}, which this class implements
*/ var Creative = exports.Creative = /*#__PURE__*/ function(_CreativeEventHandler) {
    _inheritsLoose(Creative, _CreativeEventHandler);
    function Creative(creativeData) {
        var _this;
        _this = _CreativeEventHandler.call(this) || this;
        /** @private */ _this.advertId = creativeData.advertId ? creativeData.advertId : "";
        /** @private */ _this.creativeId = creativeData.id ? creativeData.id : "";
        /** @private */ _this.universalAdIds = creativeData.universalAdIds;
        /** @private */ _this.sequence = creativeData.sequence;
        /** @private */ _this.adParameters = creativeData.adParameters;
        /** @private */ _this.extensions = null;
        /** @private */ _this.nonLinear = false;
        return _this;
    }
    var _proto = Creative.prototype;
    _proto.postParse = function postParse(extensions) {
        this.extensions = extensions;
        if (this.companionExtensions) for(var _iterator = _createForOfIteratorHelperLoose(this.companionExtensions.getChildren()), _step; !(_step = _iterator()).done;){
            var ce = _step.value;
            this.extensions.addChild(ce);
        }
    } /**
   * @return {string} the value of AdID of this Creative, as a `string`
   */ ;
    _proto.getAdvertIdentifier = function getAdvertIdentifier() {
        return this.advertId;
    } /**
   * @return {string} the value of adParameters of this Creative, as a `string`, which may be null.
   */ ;
    _proto.getAdParameters = function getAdParameters() {
        return this.adParameters;
    } /**
   * @return {XmlNode[]} the extensions for this Creative as an array of {@link XmlNode} objects or null if
   * there are no extensions.
   */ ;
    _proto.getExtensions = function getExtensions() {
        return this.extensions;
    } /**
   * @return {string} the identifier of this Creative, as a `string`
   */ ;
    _proto.getCreativeIdentifier = function getCreativeIdentifier() {
        return this.creativeId;
    } /**
   * @return {number} the sequence number of this Creative
   */ ;
    _proto.getSequence = function getSequence() {
        return this.sequence;
    } /**
   * @return {string[]} a string array of universal ad ids of this Creative
   */ ;
    _proto.getUniversalAdIds = function getUniversalAdIds() {
        return this.universalAdIds;
    };
    _proto.isNonLinear = function isNonLinear() {
        return this.nonLinear;
    };
    _proto.setNonLinear = function setNonLinear(nonLinear) {
        this.nonLinear = nonLinear;
    };
    _proto.setVisible = function setVisible(_visible) {
    // No-op
    };
    _proto.toString = function toString() {
        var s = "";
        s += "\n - Id:" + this.creativeId + " AdId:" + this.advertId + " Sequence:" + this.sequence;
        if (this.adParameters) {
            s += "\n - AdParameters:";
            s += "\n" + (0, _StringUtils.toIndentedString)(this.adParameters);
        }
        if (this.universalAdIds) {
            s += "\n - UniversalAdIds:";
            for(var _iterator2 = _createForOfIteratorHelperLoose(this.universalAdIds), _step2; !(_step2 = _iterator2()).done;){
                var uai = _step2.value;
                s += "\n" + (0, _StringUtils.toIndentedString)(uai);
            }
        }
        if (this.extensions) {
            s += "\n - CreativeExtensions:";
            s += "\n" + (0, _StringUtils.toIndentedString)(this.extensions);
        }
        return s;
    };
    return Creative;
}(_CreativeEventHandler2.CreativeEventHandler);

},{"29e82c845fc5a980":"7uXt7","edb485d439ac49b8":"jBmxg","fa3bd6d39ce2f80a":"hUwGK"}],"jBmxg":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.CreativeEventHandler = void 0;
var _XmlValidation2 = require("b2e5f62e53bc7ea7");
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
/** CreativeEventHandler declares a set of methods that allow clients to provide event information to
 * a creative, industry icon or interactive creative.
 *
 * It is implemented by LinearCreative, NonLinearCreative, CompanionCreative, IndustryIcon and InteractiveCreative.
 * Clients <b>must</b> call each method at the appropriate time so that the SDK can signal analytics on behalf of the app.
 * @hideconstructor
 */ var CreativeEventHandler = exports.CreativeEventHandler = /*#__PURE__*/ function(_XmlValidation) {
    _inheritsLoose(CreativeEventHandler, _XmlValidation);
    function CreativeEventHandler() {
        return _XmlValidation.apply(this, arguments) || this;
    }
    var _proto = CreativeEventHandler.prototype;
    /**
   * Indicates that the user clicked on the element. If a clicktracking event is defined in the VAST
   * document for the Creative then the SDK will fire that tracking beacon.
   */ _proto.onClickThrough = function onClickThrough() {
        throw new Error("Function must be overridden");
    } /** Indicates that a tracking event occurred for the element.
   *
   * If the event is defined in the `<Tracking>` element for the Creative then the SDK will fire that tracking beacon.<br/>
   * For a list of supported events, please refer to the Creative that implements this protocol.
   *
   * @param {string} event The tracking event name, or a tracking URL.
   */ ;
    _proto.onTrackingEvent = function onTrackingEvent(event) {
        throw new Error("Function must be overridden");
    } /** Defines whether the Creative is being presented to the user.
   * 
   * Tracking events are signalled for a creative only when it is visible. For a list of
   * supported events, please refer to the User Guide.
   * 
   * This method does not apply to Linear Creative, which are always visible.
   * @param {boolean} visible Describes whether the Creative is visible.
   */ ;
    _proto.setVisible = function setVisible(visible) {
        throw new Error("Function must be overridden");
    };
    return CreativeEventHandler;
}(_XmlValidation2.XmlValidation);

},{"b2e5f62e53bc7ea7":"6US9y"}],"hUwGK":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.XmlNode = void 0;
var _StringUtils = require("91d1557dcb9b37b");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
} /*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
/**
 * Represents an XML node.
 *
 * Encapsulates the data of an XML node: its attributes, inner text and children.
 */ var XmlNode = exports.XmlNode = /*#__PURE__*/ function() {
    function XmlNode(name, attributes) {
        /** @private */ this.name = name;
        /** @private */ this.attributes = attributes ? attributes : new Map();
        /** @private */ this.text = "";
        /** @private */ this.children = [];
    }
    XmlNode.attributeToString = function attributeToString(key, value) {
        return " " + key + '="' + value + '"';
    } /**
   * Returns the attributes of this node
   * @return {Map} this node's attributes
   */ ;
    var _proto = XmlNode.prototype;
    _proto.getAttributes = function getAttributes() {
        return this.attributes;
    } /**
   * Returns the value of an attribute in this node
   * @param name the attribute name
   * @return {string} the attribute value
   */ ;
    _proto.getAttribute = function getAttribute(name) {
        return this.attributes.get(name);
    } /**
   * Returns an unmodifiable list of this node's children
   * @return {XmlNode[]} this node's children
   */ ;
    _proto.getChildren = function getChildren() {
        return this.children;
    } /**
   * Returns the inner text of this node or null if there is none
   * @return {string} this node's inner text
   */ ;
    _proto.getInnerText = function getInnerText() {
        return this.text;
    } /**
   * Returns the element name of this node
   * @return {string} this node's name
   */ ;
    _proto.getName = function getName() {
        return this.name;
    };
    _proto.addChild = function addChild(child) {
        this.children.push(child);
    };
    _proto.setInnerText = function setInnerText(text) {
        this.text = text;
    };
    _proto.toString = function toString() {
        // Create a start tag
        var s = "<";
        s += this.name;
        // Add any attributes
        for(var _iterator = _createForOfIteratorHelperLoose(this.attributes), _step; !(_step = _iterator()).done;){
            var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
            s += XmlNode.attributeToString(key, value);
        }
        if (this.children.length === 0 && (0, _StringUtils.isNullOrEmpty)(this.text)) // Close start tag
        s += "/>";
        else {
            s += ">";
            if (!(0, _StringUtils.isNullOrEmpty)(this.text)) s += this.text;
            // Add any children
            for(var _iterator2 = _createForOfIteratorHelperLoose(this.children), _step2; !(_step2 = _iterator2()).done;){
                var c = _step2.value;
                s += (0, _StringUtils.toIndentedString)("\n" + c);
            }
            // Close tag on a newline only if the body isn't a simple tag
            if (!(0, _StringUtils.isNullOrEmpty)(this.text) && this.children.length === 0) {
                s += "</";
                s += this.name;
                s += ">";
            } else s += (0, _StringUtils.toUnindentedString)("\n</" + this.name + ">");
        }
        return s;
    };
    return XmlNode;
}();

},{"91d1557dcb9b37b":"7uXt7"}],"bOBcw":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.VideoClicks = void 0;
var _StringUtils = require("42ce32bc40ebfe41");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
} /*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
var VideoClicks = exports.VideoClicks = /*#__PURE__*/ function() {
    function VideoClicks(clickThroughUrl, clickTrackingUrls, customClicks) {
        /** @private */ this.clickThroughUrl = clickThroughUrl ? clickThroughUrl : "";
        /** @private */ this.clickTrackingUrls = clickTrackingUrls ? clickTrackingUrls : [];
        /** @private */ this.customClicks = customClicks ? customClicks : [];
    }
    var _proto = VideoClicks.prototype;
    _proto.getClickThroughUrl = function getClickThroughUrl() {
        return this.clickThroughUrl;
    };
    _proto.getClickTrackingUrls = function getClickTrackingUrls() {
        return this.clickTrackingUrls;
    };
    _proto.getCustomClicks = function getCustomClicks() {
        return this.customClicks;
    };
    _proto.toString = function toString() {
        var s = "";
        if (!(0, _StringUtils.isNullOrEmpty)(this.clickThroughUrl)) {
            s += "\n* Click-through Url: ";
            s += this.clickThroughUrl;
        }
        if (this.clickTrackingUrls.length > 0) for(var _iterator = _createForOfIteratorHelperLoose(this.clickTrackingUrls), _step; !(_step = _iterator()).done;){
            var ctu = _step.value;
            s += "\n* Click tracking Url: ";
            s += ctu;
        }
        if (this.customClicks.length > 0) for(var _iterator2 = _createForOfIteratorHelperLoose(this.customClicks), _step2; !(_step2 = _iterator2()).done;){
            var cc = _step2.value;
            s += "\n* Custom click Url: ";
            s += cc;
        }
        return s;
    };
    return VideoClicks;
}();

},{"42ce32bc40ebfe41":"7uXt7"}],"92ZM9":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.getClickTrackingReport = getClickTrackingReport;
exports.isValidSize = isValidSize;
exports.prefetch = prefetch;
var _StringUtils = require("d1a2df7799665305");
var _TrackingReport = require("918948812ab3bb6e");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
} /*
 * COPYRIGHT 2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
function getClickTrackingReport(urls, id) {
    return urls.length > 0 ? new _TrackingReport.TrackingReport(id, urls) : null;
}
function isValidSize(props) {
    if (!props) return false;
    var width = null;
    var height = null;
    for(var _iterator = _createForOfIteratorHelperLoose(props), _step; !(_step = _iterator()).done;){
        var prop = _step.value;
        var name = prop.getName();
        var value = prop.getValue();
        if (name === "width" && !(0, _StringUtils.isNullOrEmpty)(value)) width = prop;
        else if (name === "height" && !(0, _StringUtils.isNullOrEmpty)(value)) height = prop;
    }
    return width && height ? true : false;
}
function prefetch(resources, timeout) {
    for(var _iterator2 = _createForOfIteratorHelperLoose(resources), _step2; !(_step2 = _iterator2()).done;){
        var _step2$value = _step2.value, value = _step2$value[1];
        value.prefetch(timeout);
    }
}

},{"d1a2df7799665305":"7uXt7","918948812ab3bb6e":"fbiP9"}],"8IvwS":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.ParsingError = void 0;
var _StringUtils = require("16f087aa051e19f3");
var _ConversionUtils = require("87fce669ad22bbab");
var _SessionError2 = require("39ff35a938197b52");
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
/**
 * An object containing details of any parsing errors that get reported
 *
 * @hideconstructor
 */ var ParsingError = exports.ParsingError = /*#__PURE__*/ function(_SessionError) {
    _inheritsLoose(ParsingError, _SessionError);
    function ParsingError(breakId, message, errorDetail) {
        var _this;
        _this = _SessionError.call(this, (0, _ConversionUtils.millisToTimestamp)(Date.now())) || this;
        _this.message = message;
        var _errorDetail = (0, _StringUtils.isNullOrEmpty)(errorDetail) ? message : errorDetail;
        _errorDetail = _errorDetail + (!(0, _StringUtils.isNullOrEmpty)(breakId) ? " (breakId: " + breakId + ")" : "");
        _this.errorDetail = _errorDetail;
        return _this;
    }
    /**
   * @return {string} a descriptive message of the parsing error.
   */ var _proto = ParsingError.prototype;
    _proto.getMessage = function getMessage() {
        return this.message;
    } /**
   * @return {string} a detailed description of the error.
   */ ;
    _proto.getErrorDetail = function getErrorDetail() {
        return this.errorDetail;
    };
    return ParsingError;
}(_SessionError2.SessionError);
ParsingError.Message = Object.freeze({
    BAD_XML: "XML is not well-formed",
    NO_VMAP: "Document is not VMAP",
    INCORRECT_VAST_VERSION: "Incorrect VAST version",
    INVALID_DURATION: "Invalid duration",
    INVALID_START_TIME: "Invalid start time",
    EMPTY_ADVERT_AND_TRACKING: "No adverts or tracking",
    INVALID_MEDIAID: "Yospace media id not found",
    MISSING_CREATIVE: "Missing Linear Creative",
    INVALID_TRACKING_URL: "Invalid tracking URL"
});

},{"16f087aa051e19f3":"7uXt7","87fce669ad22bbab":"8owmX","39ff35a938197b52":"jhKFg"}],"bs9by":[function(require,module,exports) {
module.exports = JSON.parse('{"name":"@yospace/admanagement-sdk","version":"3.6.7","description":"Yospace AdManagement SDK","homepage":"https://yospace.com","main":"lib/index.js","types":"types/index.d.ts","private":false,"dependencies":{"sax":"1.2.4"},"devDependencies":{"@babel/core":"^7.22.9","@babel/plugin-transform-modules-commonjs":"^7.22.5","@babel/preset-env":"^7.22.9","babel-jest":"^29.6.2","babel-loader":"^9.1.3","babel-plugin-transform-es2015-modules-simple-commonjs":"^0.3.0","documentation":"^13.2.5","jest":"^29.6.2","jest-jasmine2":"^29.6.2","jest-junit":"^16.0.0","jest-sonar-reporter":"^2.0.0","jsdoc":"^4.0.2","jshint":"^2.13.6","msw":"^2.0.4","node-fetch":"^3.3.2","nodemon":"^3.0.1","npm-check-updates":"^16.10.17","nwb":"^0.25.2","process":"0.11.10","sinon":"^15.2.0","stream-browserify":"3.0.0","typescript":"5.1.x","webpack":"^5.88.2","webpack-cli":"^5.1.4","ws":"^8.13.0"},"scripts":{"build":"webpack","build-es5":"webpack --config webpack.config-es5.js","build-unminified":"webpack --config webpack.config-unminified.js","build:npm":"nwb build --no-demo","doc":"documentation build src/** -f html -o Documentation/html --theme src-docs/apidoctemplate","lint":"jshint --config .jshintrc ./src/ || true","test":"jest --coverage --forceExit --bail","testUnit":"jest --coverage --forceExit -t UNIT","testStateMachine":"jest --coverage --forceExit -t STATE_MACHINE","testIntegration":"jest --coverage --forceExit --bail -t INTEGRATION","tsdefs":"npx -p typescript tsc src/index.js --stripInternal --declaration --allowJs --emitDeclarationOnly --outDir types","tsdefsHosting":"npx -p typescript tsc src/index.js --stripInternal --declaration --allowJs --emitDeclarationOnly --outDir types-${npm_package_version}"},"author":{"name":"Yospace Technologies Ltd","email":"sdk-team@yospace.com"},"license":"SEE LICENSE IN LICENCE","files":["lib/","docs/","types/"]}');

},{}],"lj3Py":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.CompanionCreative = void 0;
var _Creative2 = require("2ee842654e1fb7bb");
var _VideoClicks = require("9b140ae492663f54");
var _CreativeUtils = require("9677532b03846d9f");
var _YoLog = require("51731f03a3ab07aa");
var _StringUtils = require("6f5434081353e90f");
var _Resource = require("a89d3a54a2eaebf");
var _VASTProperty = require("a9ec264afc4e400c");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// Imports needed by jsdoc
/**
 * Represents a companion creative object.
 *
 * Encapsulates the data from the `<Companion>` element of a VAST document.<br/>
 * It is usually a creative that is displayed outside of the video player's rendering view.
 *
 * <b>NOTE:</b> A Companion may contain one or more resources and/or tracking events. In the case that it contains only tracking events,
*               the Companion can be obtained from its parent advert by requesting Companions with ResourceType.Unknown.<br/>
 * <b>NOTE:</b> The class implements CreativeEventHandler so that it can raise `CompanionClickTracking` events on behalf of a client.
 * 
 * @hideconstructor
 * @see {@link Creative}, which this class extends
 */ var CompanionCreative = exports.CompanionCreative = /*#__PURE__*/ function(_Creative) {
    _inheritsLoose(CompanionCreative, _Creative);
    function CompanionCreative(creativeData, videoClicks, resources, tracking, broker) {
        var _this;
        _this = _Creative.call(this, creativeData) || this;
        /** @private */ _this.resources = new Map();
        /** @private */ _this.visible = false;
        /** @private */ _this.properties = creativeData.properties ? creativeData.properties : [];
        /** @private */ _this.altText = creativeData.altText;
        /** @private */ _this.trackingMap = tracking ? tracking : new Map();
        /** @private */ _this.videoClicks = videoClicks ? videoClicks : new _VideoClicks.VideoClicks();
        /** @private */ _this.broker = broker;
        /** @private */ _this.companionExtensions = creativeData.companionExtensions;
        for(var _iterator = _createForOfIteratorHelperLoose(resources), _step; !(_step = _iterator()).done;){
            var res = _step.value;
            _this.resources.set(res.getResourceType(), res);
        }
        return _this;
    }
    /**
   * @return {string} the alternative text as a `string`
   */ var _proto = CompanionCreative.prototype;
    _proto.getAltText = function getAltText() {
        return this.altText;
    } /**
   * @return {string} the clickthrough URL as a `string`
   */ ;
    _proto.getClickThroughUrl = function getClickThroughUrl() {
        return this.videoClicks.getClickThroughUrl();
    };
    _proto.getClickTrackingUrls = function getClickTrackingUrls() {
        return this.videoClicks.getClickTrackingUrls();
    } /** Returns the properties for the companion creative. The properties are represented as YOVASTProperty objects. Possible properties are:
   * 
   * - id
   * - width
   * - height
   * - assetWidth
   * - assetHeight
   * - expandedWidth
   * - expandedHeight
   * - adSlotId
   * - pxratio
   * - apiFramework
   * - renderingMode
   * 
   * @return {VASTProperty[]} an array of {@link VASTProperty} objects for the Companion Ad.
   */ ;
    _proto.getProperties = function getProperties() {
        return Object.assign([], this.properties);
    } /**
   * Returns a named property for the companion creative if it exists. Possible properties are:
   *
   * - id
   * - width
   * - height
   * - assetWidth
   * - assetHeight
   * - expandedWidth
   * - expandedHeight
   * - adSlotId
   * - pxratio
   * - apiFramework
   * - renderingMode
   *
   * @param {string} name the name of the property as a `string`
   * @return {VASTProperty} a {@link VASTProperty} object or null if not found
   */ ;
    _proto.getProperty = function getProperty(name) {
        for(var _iterator2 = _createForOfIteratorHelperLoose(this.properties), _step2; !(_step2 = _iterator2()).done;){
            var prop = _step2.value;
            if (prop.getName() === name) return prop;
        }
        return null;
    } /**
   * Returns the resource of the requested type.
   * @param {ResourceType} type the requested resource type
   * @return {Resource} the {@link Resource} of the type specified or null if not found
   */ ;
    _proto.getResource = function getResource(type) {
        if (!this.resources.has(type)) return null;
        return this.resources.get(type);
    } /**
   * Returns the resources for the companion creative. Each entry contains an array of resources keyed on the resource type.<br/>
   * The three resource types are optional elements; the dictionary will contain between one and three entries.
   * 
   * @return {Resource[]} an `array` of {@link Resource} objects for the companion.
   */ ;
    _proto.getResources = function getResources() {
        return this.resources;
    };
    _proto.getTrackingMap = function getTrackingMap() {
        return this.trackingMap;
    };
    _proto.isValid = function isValid() {
        return (0, _CreativeUtils.isValidSize)(this.properties) && this.resources.size > 0 || this.trackingMap.size > 0;
    } /**
   * Defines whether the Companion Ad is active and is to be displayed. Tracking events are
   * fired only for creatives that are visible.
   * @return {boolean} true if this creative is to be displayed
   */ ;
    _proto.isVisible = function isVisible() {
        return this.visible;
    };
    _proto.onClickThrough = function onClickThrough() {
        if (!this.isVisible()) {
            _YoLog.YoLog.w("Companion is not visible");
            return;
        }
        var urls = this.videoClicks.getClickTrackingUrls();
        var report = (0, _CreativeUtils.getClickTrackingReport)(urls, "CompanionClickTracking");
        if (report) this.broker.fireTrackingReportForCreative(report, this);
    };
    _proto.onTrackingEvent = function onTrackingEvent(_event) {
    // NoOp
    };
    _proto.prefetchResources = function prefetchResources(timeout) {
        (0, _CreativeUtils.prefetch)(this.resources, timeout);
    } /**
   * Defines whether the Companion Creative is being presented to the user.
   * @param {boolean} visible the visibility flag
   */ ;
    _proto.setVisible = function setVisible(visible) {
        if (this.visible !== visible) {
            this.visible = visible;
            if (visible) {
                var event = "creativeView";
                var report = this.trackingMap.get(event);
                if (report) this.broker.fireTrackingReportForCreative(report, this);
            }
        }
    };
    _proto.toString = function toString() {
        var nlcString = "\n--- Companion ---\n";
        for(var _iterator3 = _createForOfIteratorHelperLoose(this.properties), _step3; !(_step3 = _iterator3()).done;){
            var prop = _step3.value;
            nlcString += "\n" + (0, _StringUtils.toIndentedString)(prop);
        }
        nlcString += (0, _StringUtils.toIndentedString)("\nAlt Text: " + this.altText);
        nlcString += (0, _StringUtils.toIndentedString)(this.videoClicks);
        for(var _iterator4 = _createForOfIteratorHelperLoose(this.resources), _step4; !(_step4 = _iterator4()).done;){
            var _step4$value = _step4.value, key = _step4$value[0], value = _step4$value[1];
            nlcString += (0, _StringUtils.toIndentedString)(key + ":" + value);
        }
        nlcString += _Creative.prototype.toString.call(this);
        return nlcString;
    };
    return CompanionCreative;
}(_Creative2.Creative);

},{"2ee842654e1fb7bb":"fZ00L","9b140ae492663f54":"bOBcw","9677532b03846d9f":"92ZM9","51731f03a3ab07aa":"9KS65","6f5434081353e90f":"7uXt7","a89d3a54a2eaebf":"3iyI3","a9ec264afc4e400c":"kiVVI"}],"kiVVI":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.VASTProperty = void 0;
var _StringUtils = require("4d075a2de9fd1ebe");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
} /*
 * COPYRIGHT 2020-2021 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
/**
 * Represents a VAST property of an element in a VAST document.
 *
 * It is used by several Core objects as a container for the object's name-value pairs.<br/>
 * For a list of possible properties refer to the containing class.
 * 
 * @hideconstructor
 */ var VASTProperty = exports.VASTProperty = /*#__PURE__*/ function() {
    function VASTProperty(name, value, attributeKey, attributeValue) {
        /** @private */ this.name = name;
        /** @private */ this.value = value ? value : "";
        /** @private */ this.attributes = new Map();
        if (attributeKey && attributeValue) this.addAttribute(attributeKey, attributeValue);
    }
    var _proto = VASTProperty.prototype;
    _proto.addAttribute = function addAttribute(key, value) {
        this.attributes.set(key, value);
    } /**
   * @return {string} the name of the VASTProperty
   */ ;
    _proto.getName = function getName() {
        return this.name;
    } /**
   * @return {string} the value of the VASTProperty
   */ ;
    _proto.getValue = function getValue() {
        return this.value;
    } /**
   * @return {Map} a Map of attributes of this VASTProperty as name-value pairs
   */ ;
    _proto.getAttributes = function getAttributes() {
        return this.attributes;
    };
    _proto.setValue = function setValue(value) {
        this.value = value;
    };
    _proto.toString = function toString() {
        var s = "";
        s += "Property Name: ";
        s += this.name;
        if (!(0, _StringUtils.isNullOrEmpty)(this.value)) {
            s += ", Value: ";
            s += this.value;
        }
        if (this.attributes.size > 0) {
            s += ", Attributes:{";
            for(var _iterator = _createForOfIteratorHelperLoose(this.attributes), _step; !(_step = _iterator()).done;){
                var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
                s += key + ":" + value + " ";
            }
            s += "}";
        }
        return s;
    };
    return VASTProperty;
}();

},{"4d075a2de9fd1ebe":"7uXt7"}],"boy2w":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.NonLinearAds = void 0;
var _StringUtils = require("99433be2a0d9c8b3");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
} /*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
var NonLinearAds = exports.NonLinearAds = /*#__PURE__*/ function() {
    function NonLinearAds(trackingMap, nonLinearCreatives) {
        /** @private */ this.trackingMap = trackingMap ? trackingMap : new Map();
        /** @private */ this.nonLinearCreatives = nonLinearCreatives ? nonLinearCreatives : [];
    }
    var _proto = NonLinearAds.prototype;
    _proto.allNonLinearsAreInactive = function allNonLinearsAreInactive() {
        for(var _iterator = _createForOfIteratorHelperLoose(this.nonLinearCreatives), _step; !(_step = _iterator()).done;){
            var nlc = _step.value;
            if (nlc.isVisible()) return false;
        }
        return true;
    };
    _proto.containsCreative = function containsCreative(creative) {
        return this.nonLinearCreatives.indexOf(creative) !== -1;
    };
    _proto.getNonLinearCreatives = function getNonLinearCreatives() {
        return Object.assign([], this.nonLinearCreatives);
    };
    _proto.getNonLinearCreativesByType = function getNonLinearCreativesByType(type) {
        var arr = [];
        for(var _iterator2 = _createForOfIteratorHelperLoose(this.nonLinearCreatives), _step2; !(_step2 = _iterator2()).done;){
            var nlc = _step2.value;
            if (nlc.getResource(type)) arr.push(nlc);
        }
        return arr;
    };
    _proto.getTrackingMap = function getTrackingMap() {
        return this.trackingMap;
    };
    _proto.getTrackingReport = function getTrackingReport(type) {
        if (this.allNonLinearsAreInactive()) return undefined;
        return this.trackingMap.get(type);
    };
    _proto.postParse = function postParse() {
        // provide a reference to tracking to allow nonlinear creatives to request
        // autonomously to the AnalyticBroker
        for(var _iterator3 = _createForOfIteratorHelperLoose(this.nonLinearCreatives), _step3; !(_step3 = _iterator3()).done;){
            var nlc = _step3.value;
            nlc.setTrackingReports(this.trackingMap);
        }
    };
    _proto.prefetchResources = function prefetchResources(timeout) {
        for(var _iterator4 = _createForOfIteratorHelperLoose(this.nonLinearCreatives), _step4; !(_step4 = _iterator4()).done;){
            var nlc = _step4.value;
            nlc.prefetchResources(timeout);
        }
    };
    _proto.toString = function toString() {
        if (this.nonLinearCreatives.length > 0) {
            var s = "\n--- NonLinear Ads:";
            if (this.trackingMap.size > 0) {
                s += "\n  ** Tracking events - ";
                for(var _iterator5 = _createForOfIteratorHelperLoose(this.trackingMap), _step5; !(_step5 = _iterator5()).done;){
                    var _step5$value = _step5.value, key = _step5$value[0], value = _step5$value[1];
                    s += (0, _StringUtils.toIndentedString)("\n " + key + ":" + value);
                }
            }
            for(var _iterator6 = _createForOfIteratorHelperLoose(this.nonLinearCreatives), _step6; !(_step6 = _iterator6()).done;){
                var nlc = _step6.value;
                s += (0, _StringUtils.toIndentedString)(nlc);
            }
            return s;
        }
        return "";
    };
    return NonLinearAds;
}();

},{"99433be2a0d9c8b3":"7uXt7"}],"gTmyD":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.ViewableEvent = exports.AdvertEventHandler = void 0;
var _XmlValidation2 = require("4ef5a3c899b92691");
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
/**
 * Enumeration of possible viewable events:
 * @enum {number}
 * @category Enumerations
 */ var ViewableEvent = exports.ViewableEvent = Object.freeze({
    /** Indicates that an advert is viewable */ VIEWABLE: 0,
    /** Indicates that an advert is not viewable */ NOT_VIEWABLE: 1,
    /** Indicates that the viewable state of an ad is undetermined */ VIEW_UNDETERMINED: 2
});
/**
 * AdvertEventHandler declares a set of methods that allow clients to provide event information to an advert.
 *
 * It is implemented by Advert and clients <b>must</b> call each method at the appropriate time so that
 * the SDK can signal analytics on behalf of the app.
 * @hideconstructor
 */ var AdvertEventHandler = exports.AdvertEventHandler = /*#__PURE__*/ function(_XmlValidation) {
    _inheritsLoose(AdvertEventHandler, _XmlValidation);
    function AdvertEventHandler() {
        return _XmlValidation.apply(this, arguments) || this;
    }
    var _proto = AdvertEventHandler.prototype;
    /** Indicates that a viewable event occurred for a linear advert.
   * Clients should call this method in order to fire the appropriate Viewable beacon.
   * @param {ViewableEvent} event the event, defined by the enum ViewableEvent.
   * @see {@link ViewableEvent}
   */ _proto.onViewableEvent = function onViewableEvent(event) {
        throw new Error("Function must be overridden");
    } /** Indicates that an error occurred that is in the domain of the player / app. The SDK fires beacons for any `<Error>` URLs
   * defined for the advert.<br/>
   * @param {number} [errorCode] (optional) the error code value that should be used in the ERRORCODE macro substitution.
   * If 0 or no value is supplied then no substitution is made.
   */ ;
    _proto.onErrorEvent = function onErrorEvent(errorCode) {
        throw new Error("Function must be overridden");
    } /** Indicates that an impression event occurred for a non-linear advert.
   * Clients should call this method in order to fire impression beacons associated with the advert.
   *
   * <b>NOTE:</b> Clients should call this method only for adverts in a non-linear ad break. Calling this method
   * on a linear advert has no effect.
   */ ;
    _proto.onImpressionEvent = function onImpressionEvent() {
        throw new Error("Function must be overridden");
    };
    return AdvertEventHandler;
}(_XmlValidation2.XmlValidation);

},{"4ef5a3c899b92691":"6US9y"}],"153sX":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.AdVerification = void 0;
var _Event = require("b508ce5691844ef5");
var _YoLog = require("ef00b3ff06e74ca9");
var _StringUtils = require("ec6478d940360fe8");
var _VerificationEventHandler = require("ee4e6d7a21c917cc");
var _Resource = require("afe22fda64192e76");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// JsDoc/Typescript imports
/**
 * Represents an ad verification object.
 *
 * Encapsulates the data from the `<AdVerification>` element of a VAST document: its
 * attributes, parameters and resources.
 * Through {@link VerificationEventHandler} it supports the ability for a client app to signal verification events.
 * 
 * @hideconstructor
 * @see {@link VerificationEventHandler}, which this class implements
 */ var AdVerification = exports.AdVerification = /*#__PURE__*/ function(_VerificationEventHan) {
    _inheritsLoose(AdVerification, _VerificationEventHan);
    function AdVerification(advertData) {
        var _this;
        _this = _VerificationEventHan.call(this) || this;
        /** @private */ _this.vendor = advertData.verificationVendor;
        /** @private */ _this.resources = advertData.verificationResources;
        /** @private */ _this.verificationEvents = advertData.verificationEvents;
        /** @private */ _this.parameters = advertData.verificationParameters;
        /** @private */ _this.listeners = [];
        /** @private */ _this.broker = null;
        return _this;
    }
    var _proto = AdVerification.prototype;
    _proto.getAdVerificationEvents = function getAdVerificationEvents() {
        return this.verificationEvents;
    } /**
   * @return {string} the VerificationParameters as a `string`
   */ ;
    _proto.getParameters = function getParameters() {
        return this.parameters;
    } /** Returns the resources for the ad verification object. The resources are represented as YOVASTProperty objects.
   *
   * Each resource will be either an ExecutableResource or JavaScriptResource as defined by the VAST specification.
   * An ExecutableResource contains up to two attributes in the VASTProperty object: apiFramework and type.
   *
   * A JavaScriptResource contains up tp two attributes in the VASTProperty object: apiFramework and browserOptional.
   * 
   * @return {Resource} an array of `Resource` objects associated with the AdVerification
   */ ;
    _proto.getResources = function getResources() {
        return Object.assign([], this.resources);
    } /**
   * @return {string} the vendor of the AdVerification as a `string`
   */ ;
    _proto.getVendor = function getVendor() {
        return this.vendor;
    };
    _proto.isValid = function isValid() {
        return this.vendor && this.resources && this.resources.length > 0 ? true : false;
    };
    _proto.onVerificationEvent = function onVerificationEvent(event, reason) {
        if (this.listeners.length === 0) {
            _YoLog.YoLog.w("No event listeners - can't signal VerificationEvent");
            return;
        }
        var isInteger = Number.isInteger(reason);
        if (reason && !isInteger) // reason is optional so only warn if present
        _YoLog.YoLog.w("onVerificationEvent: reason should be an integer.");
        var report = this.verificationEvents.get(event);
        if (report) {
            if (isInteger && reason) for(var _iterator = _createForOfIteratorHelperLoose(this.listeners), _step; !(_step = _iterator()).done;){
                var cb = _step.value;
                cb(new _Event.Event(reason));
            }
            this.broker.fireTrackingReport(report);
        }
    };
    _proto.postParse = function postParse(broker, callback) {
        this.broker = broker;
        if (!callback) _YoLog.YoLog.e("postParse: callback was null");
        else this.listeners.push(callback);
    };
    _proto.toString = function toString() {
        var s = "";
        if (this.verificationEvents.size > 0) {
            s += "\n - Verification events:";
            for(var _iterator2 = _createForOfIteratorHelperLoose(this.verificationEvents), _step2; !(_step2 = _iterator2()).done;){
                var _step2$value = _step2.value, key = _step2$value[0], value = _step2$value[1];
                s += "\n " + key + "=" + value;
            }
        }
        var adVerificationStr = "\n--- Ad Verification:\n - Vendor:";
        adVerificationStr += this.vendor;
        adVerificationStr += "\n - Resources:";
        for(var _iterator3 = _createForOfIteratorHelperLoose(this.resources), _step3; !(_step3 = _iterator3()).done;){
            var resource = _step3.value;
            adVerificationStr += "\n" + (0, _StringUtils.toIndentedString)(resource);
        }
        adVerificationStr += s;
        adVerificationStr += "\n - VerificationParameters:";
        adVerificationStr += this.parameters;
        return adVerificationStr;
    };
    return AdVerification;
}(_VerificationEventHandler.VerificationEventHandler);

},{"b508ce5691844ef5":"kKDLv","ef00b3ff06e74ca9":"9KS65","ec6478d940360fe8":"7uXt7","ee4e6d7a21c917cc":"eGK0f","afe22fda64192e76":"3iyI3"}],"kKDLv":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.Event = void 0;
/*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ var Event = exports.Event = /*#__PURE__*/ function() {
    function Event(payload, source) {
        /** @private */ this.payload = payload;
        /** @private */ this.source = source ? source : null;
    }
    var _proto = Event.prototype;
    _proto.getPayload = function getPayload() {
        return this.payload;
    };
    _proto.getSource = function getSource() {
        return this.source;
    };
    return Event;
}();

},{}],"eGK0f":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.VerificationEventHandler = void 0;
var _XmlValidation2 = require("2b422fa3c7766bce");
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
/**
 * VerificationEventHandler declares a set of methods that allow clients to provide event information
 * to an ad verification object.
 *
 * It is implemented by AdVerification and clients <b>must</b> call each method at the appropriate time so that
 * the SDK can signal analytics on behalf of the app.
 *
 * <b>Note:</b> passing reason as string to onVerificationEvent is deprecated.  Use an integer instead
 * @hideconstructor
 */ var VerificationEventHandler = exports.VerificationEventHandler = /*#__PURE__*/ function(_XmlValidation) {
    _inheritsLoose(VerificationEventHandler, _XmlValidation);
    function VerificationEventHandler() {
        return _XmlValidation.apply(this, arguments) || this;
    }
    var _proto = VerificationEventHandler.prototype;
    /** Indicates that a verification event occurred.
   * Clients should call this method in order to signal a verification event to the SDK.
   * @param {string} event the verification event
   * @param {number} [reason] (optional) the verification reason. If 0 or no value is supplied then no substitution is made.
   */ _proto.onVerificationEvent = function onVerificationEvent(event, reason) {
        throw new Error("Function must be overridden");
    };
    return VerificationEventHandler;
}(_XmlValidation2.XmlValidation);

},{"2b422fa3c7766bce":"6US9y"}],"dVAhT":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.AdvertWrapper = void 0;
var _XmlValidation2 = require("22c6999ab711dca3");
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2021 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// JSDoc/Typescript imports
/**
* Encapsulates an advert's wrapper data, parsed from the Yospace extension data of a VAST document.
*
* An advert wrapper may contain a child wrapper, representing a the next level of advert wrapper data that
* contributed to the final advert.
* 
* @hideconstructor
*/ var AdvertWrapper = exports.AdvertWrapper = /*#__PURE__*/ function(_XmlValidation) {
    _inheritsLoose(AdvertWrapper, _XmlValidation);
    function AdvertWrapper(id, creativeId, adSystem) {
        var _this;
        _this = _XmlValidation.call(this) || this;
        /** @private */ _this.identifier = id;
        /** @private */ _this.creativeIdentifier = creativeId;
        /** @private */ _this.adSystem = adSystem;
        /** @private */ _this.child = null;
        return _this;
    }
    /**
   * @return {string} the advert wrapper's adSystem.
   */ var _proto = AdvertWrapper.prototype;
    _proto.getAdSystem = function getAdSystem() {
        return this.adSystem;
    } /**
   * @return {string} the advert's wrapper's creative identifier.
   */ ;
    _proto.getCreativeIdentifier = function getCreativeIdentifier() {
        return this.creativeIdentifier;
    } /**
   * @return {string} the advert wrapper identifier.
   */ ;
    _proto.getIdentifier = function getIdentifier() {
        return this.identifier;
    } /**
   * @return {AdvertWrapper} the advert wrapper's child, which may be null.
   */ ;
    _proto.getLineage = function getLineage() {
        return this.child;
    };
    _proto.isValid = function isValid() {
        var child = this;
        do {
            if (!child.identifier || child.identifier === "") return false;
            child = child.getLineage();
        }while (child);
        return true;
    };
    _proto.setChild = function setChild(child) {
        this.child = child;
    };
    return AdvertWrapper;
}(_XmlValidation2.XmlValidation);

},{"22c6999ab711dca3":"6US9y"}],"heno1":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.IndustryIcon = void 0;
var _VideoClicks = require("c2701b2e0f9cb606");
var _StringUtils = require("9c238dc4a57fd86d");
var _CreativeEventHandler2 = require("adde490377eb105b");
var _TrackingReport = require("1b8ed5926734c376");
var _IconClickFallbackImage = require("2980c8244ef3076d");
var _Resource = require("ef4f26be0710f068");
var _VASTProperty = require("2205737fa39ee5fa");
var _CreativeUtils = require("e234e93332c6b962");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// JsDoc/Typescript imports
/**
 * Represents an industry icon object.
 *
 * Encapsulates the data from the `<Icon>` element of a VAST document.<br/>
 * It is a graphic that overlays a small portion of the advert's video and is sometimes clickable.
 *
 * <b>NOTE:</b> The class implements CreativeEventHandler so that it can raise `IconClickTracking` events on behalf of a client.
 *
 * @hideconstructor
 * @see {@link CreativeEventHandler}, which this class implements
 */ var IndustryIcon = exports.IndustryIcon = /*#__PURE__*/ function(_CreativeEventHandler) {
    _inheritsLoose(IndustryIcon, _CreativeEventHandler);
    function IndustryIcon(properties, resources, videoClicks, clickFallbackImages, broker) {
        var _this;
        _this = _CreativeEventHandler.call(this) || this;
        /** @private */ _this.resources = new Map();
        /** @private */ _this.visible = false;
        /** @private */ _this.properties = properties ? properties : [];
        /** @private */ _this.videoClicks = videoClicks ? videoClicks : new _VideoClicks.VideoClicks();
        /** @private */ _this.clickFallbackImages = clickFallbackImages ? clickFallbackImages : [];
        /** @private */ _this.broker = broker;
        for(var _iterator = _createForOfIteratorHelperLoose(resources), _step; !(_step = _iterator()).done;){
            var res = _step.value;
            _this.resources.set(res.getResourceType(), res);
        }
        return _this;
    }
    /**
   * Returns the click fallback images for the industry icon
   * @return {IconClickFallbackImage[]} an array of {@link IconClickFallbackImage} objects
   */ var _proto = IndustryIcon.prototype;
    _proto.getClickFallbackImages = function getClickFallbackImages() {
        return Object.assign([], this.clickFallbackImages);
    };
    _proto.getClickThroughUrl = function getClickThroughUrl() {
        return this.videoClicks.getClickThroughUrl();
    };
    _proto.getClickTrackingUrls = function getClickTrackingUrls() {
        return this.videoClicks.getClickTrackingUrls();
    } /**
   * @return {boolean} true if the industry icon is visible
   */ ;
    _proto.isVisible = function isVisible() {
        return this.visible;
    };
    _proto.getViewTrackingUrls = function getViewTrackingUrls() {
        return this.videoClicks.getCustomClicks();
    } /**
   * Returns the properties for the industry icon. The properties are represented as VASTProperty objects. Possible properties are:
   * - program
   * - width
   * - height
   * - xPosition
   * - yPosition
   * - offset
   * - duration
   * - apiFramework
   * - altText
   * - hoverText
   *
   * @return {VASTProperty[]} an array of {@link VASTProperty} objects for the industry icon
   */ ;
    _proto.getProperties = function getProperties() {
        return Object.assign([], this.properties);
    } /**
   * Returns a named property for the industry icon if it exists. Possible properties are
   * - program
   * - width
   * - height
   * - xPosition
   * - yPosition
   * - offset
   * - duration
   * - apiFramework
   * - altText
   * - hoverText
   *
   * @param {string} name the name of the property
   * @return {VASTProperty} a {@link VASTProperty} object or null if not found
   */ ;
    _proto.getProperty = function getProperty(name) {
        for(var _iterator2 = _createForOfIteratorHelperLoose(this.properties), _step2; !(_step2 = _iterator2()).done;){
            var prop = _step2.value;
            if (prop.getName() === name) return prop;
        }
    } /**
   * Returns the resource of the requested type.
   *
   * @param {ResourceType} type the resource type
   * @return {Resource} the {@link Resource} of the type specified, or null if not found
   */ ;
    _proto.getResource = function getResource(type) {
        return this.resources.get(type);
    } /**
   * Returns the resources for the industry icon. Each entry contains an array of resources keyed on the resource type.<br/>
   * The three resource types are optional elements; the dictionary will contain between one and three entries.
    * @return {Resource[]} an array of {@link Resource} objects for this industry icon
   */ ;
    _proto.getResources = function getResources() {
        return this.resources;
    };
    _proto.isValid = function isValid() {
        var program = null;
        var width = null;
        var height = null;
        var xPos = null;
        var yPos = null;
        for(var _iterator3 = _createForOfIteratorHelperLoose(this.properties), _step3; !(_step3 = _iterator3()).done;){
            var prop = _step3.value;
            var value = prop.getValue();
            if (!(0, _StringUtils.isNullOrEmpty)(value)) {
                if (prop.getName() === "program") program = prop;
                if (prop.getName() === "width") width = prop;
                if (prop.getName() === "height") height = prop;
                if (prop.getName() === "xPosition") xPos = prop;
                if (prop.getName() === "yPosition") yPos = prop;
            }
        }
        return width !== null && height !== null && program !== null && xPos !== null && yPos !== null && this.resources.size > 0;
    };
    _proto.onClickThrough = function onClickThrough() {
        if (this.isVisible()) {
            var urls = this.videoClicks.getClickTrackingUrls();
            if (urls.length > 0) {
                var report = (0, _CreativeUtils.getClickTrackingReport)(urls, "IconClickTracking");
                if (report) this.broker.fireTrackingReportForIcon(report, this);
            }
        }
    };
    _proto.onTrackingEvent = function onTrackingEvent(_event) {
    // No op
    } /**
   * Defines whether the Industry Icon is being presented to the user.
   * @param {boolean} visible the visibility flag
   */ ;
    _proto.setVisible = function setVisible(visible) {
        if (this.visible !== visible) {
            this.visible = visible;
            if (this.visible) {
                if (this.videoClicks.getCustomClicks().length > 0) {
                    var report = new _TrackingReport.TrackingReport("IconViewTracking", this.videoClicks.getCustomClicks());
                    if (report) this.broker.fireTrackingReportForIcon(report, this);
                }
            }
        }
    };
    _proto.toString = function toString() {
        var s = "";
        s += this.videoClicks.toString();
        if (this.properties.length > 0) s += "\nIcon Properties: ";
        for(var _iterator4 = _createForOfIteratorHelperLoose(this.properties), _step4; !(_step4 = _iterator4()).done;){
            var prop = _step4.value;
            s += "\n" + (0, _StringUtils.toIndentedString)(prop);
        }
        if (this.resources.length > 0) s += "\nIcon Resource(s): ";
        for(var _iterator5 = _createForOfIteratorHelperLoose(this.resources), _step5; !(_step5 = _iterator5()).done;){
            var _step5$value = _step5.value, key = _step5$value[0], value = _step5$value[1];
            s += (0, _StringUtils.toIndentedString)(key + ":" + value);
        }
        if (this.clickFallbackImages.length > 0) s += "\nIcon Click Fallback Images: ";
        for(var _iterator6 = _createForOfIteratorHelperLoose(this.clickFallbackImages), _step6; !(_step6 = _iterator6()).done;){
            var cfi = _step6.value;
            s += "\n" + (0, _StringUtils.toIndentedString)(cfi);
        }
        return s;
    };
    return IndustryIcon;
}(_CreativeEventHandler2.CreativeEventHandler);

},{"c2701b2e0f9cb606":"bOBcw","9c238dc4a57fd86d":"7uXt7","adde490377eb105b":"jBmxg","1b8ed5926734c376":"fbiP9","2980c8244ef3076d":"cg5iB","ef4f26be0710f068":"3iyI3","2205737fa39ee5fa":"kiVVI","e234e93332c6b962":"92ZM9"}],"cg5iB":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.IconClickFallbackImage = void 0;
var _CreativeUtils = require("66f45393dedbb06a");
var _XmlValidation2 = require("e2afae12d0433228");
var _StringUtils = require("7ecf2735659e9be");
var _Resource = require("19ca467912f08815");
var _VASTProperty = require("86637d66059214e9");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// JsDoc/Typescript imports
/**
 * Represents an icon click fallback image object.
 *
 * Encapsulates the data from the `<IconClickFallbackImage>` element of a VAST document.<br/>
 * It is a graphic that is used when a target platform does not support HTML rendering: the information
 * is provided as an image instead.
 * 
 *  @hideconstructor
 */ var IconClickFallbackImage = exports.IconClickFallbackImage = /*#__PURE__*/ function(_XmlValidation) {
    _inheritsLoose(IconClickFallbackImage, _XmlValidation);
    function IconClickFallbackImage(properties, altText, resource) {
        var _this;
        _this = _XmlValidation.call(this) || this;
        /** @private */ _this.properties = properties ? properties : [];
        /** @private */ _this.altText = altText;
        /** @private */ _this.resource = resource;
        return _this;
    }
    /**
   * @return {string} the alternative text of the image, as a `string`
   */ var _proto = IconClickFallbackImage.prototype;
    _proto.getAltText = function getAltText() {
        return this.altText;
    } /**
   * Returns the properties for the iconclick fallback image. The properties are represented as YOVASTProperty objects.
   * Possible properties are:
   * - width
   * - height
   * 
   * @return {VASTProperty[]} an array of {@link VASTProperty} objects for the image
   */ ;
    _proto.getProperties = function getProperties() {
        return Object.assign([], this.properties);
    } /**
   * Returns a named property for the iconclick fallback image if it exists. Possible properties are:
   * - width
   * - height
   * 
   * @param {string} name the name of the property
   * @return {VASTProperty} a {@link VASTProperty} object or null if not found
   */ ;
    _proto.getProperty = function getProperty(name) {
        for(var _iterator = _createForOfIteratorHelperLoose(this.properties), _step; !(_step = _iterator()).done;){
            var prop = _step.value;
            if (prop.getName() === name) return prop;
        }
        return null;
    } /**
   * @return {Resource} the {@link Resource} of the image
   */ ;
    _proto.getResource = function getResource() {
        return this.resource;
    };
    _proto.isValid = function isValid() {
        return (0, _CreativeUtils.isValidSize)(this.properties) && (!(0, _StringUtils.isNullOrEmpty)(this.altText) || this.resource) ? true : false;
    };
    return IconClickFallbackImage;
}(_XmlValidation2.XmlValidation);

},{"66f45393dedbb06a":"92ZM9","e2afae12d0433228":"6US9y","7ecf2735659e9be":"7uXt7","19ca467912f08815":"3iyI3","86637d66059214e9":"kiVVI"}],"Ir4VY":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.InteractiveCreative = void 0;
var _StringUtils = require("68a930feba9551f2");
var _TrackingReport = require("589181e5b2112c78");
var _CreativeEventHandler2 = require("ccbfe438b03dd032");
var _NonLinearCreative = require("1387f34a460ec3ce");
var _VASTProperty = require("7868a30d78826293");
var _YoLog = require("65a65127496cae80");
var _HttpUtils = require("6b414f4658d40376");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// JsDoc/Typescript imports
/**
 * Represents an interactive creative object.
 *
 * Encapsulates the data from the `<InteractiveCreativeFile>` element of a VAST document.<br/>
 * It is used to provide a more interactive experience using additional creative functionality by making
 * use of a vendor's interactive APIs.
 *
 * <b>NOTE:</b> The class implements CreativeEventHandler so that it can raise analytic events on behalf
 * of a client application. It supports firing of customer tracker URLs for Interactive creative of type SIMID.
 * 
 *  @hideconstructor
 * @see {@link CreativeEventHandler}, which this class implements
 */ var InteractiveCreative = exports.InteractiveCreative = /*#__PURE__*/ function(_CreativeEventHandler) {
    _inheritsLoose(InteractiveCreative, _CreativeEventHandler);
    function InteractiveCreative(source, properties, broker, tracking) {
        var _this;
        _this = _CreativeEventHandler.call(this) || this;
        /** @private */ _this.source = source;
        /** @private */ _this.properties = properties ? properties : [];
        /** @private */ _this.broker = broker;
        /** @private */ _this.adParameters = null;
        /** @private */ _this.advertDuration = 0;
        /** @private */ _this.tracking = null;
        /** @private */ _this.offset = 0;
        /** @private */ _this.visible = false;
        /** @private */ _this.nonLinearCreatives = [];
        if (_this.isSIMID()) _this.tracking = tracking;
        return _this;
    }
    /**
   * @return {string} the ad parameters for the interactive creative, which may be null.
   */ var _proto = InteractiveCreative.prototype;
    _proto.getAdParameters = function getAdParameters() {
        return this.adParameters;
    } /**
   * @return {number} the duration of the advert media for the interactive creative, in milliseconds.
   */ ;
    _proto.getAdvertDuration = function getAdvertDuration() {
        return this.advertDuration;
    } /**
   * 
   * @returns {NonLinearCreative[]} an array of {@link NonLinearCreative} objects associated with the interactive creative.
   *                                A {@link NonLinearCreative} is related if its `apiFramework` property
   *                                is the same as the interactive creative.
   */ ;
    _proto.getNonLinearCreatives = function getNonLinearCreatives() {
        return this.nonLinearCreatives;
    } /**
   * Returns the properties for the interactive creative. The properties are represented as {VASTProperty} objects.
   * 
   * Possible properties are:
   * - type
   * - apiFramework
   * - variableDuration
   * 
   * @return {VASTProperty[]} an array of {@link VASTProperty} objects for the interactive creative
   */ ;
    _proto.getProperties = function getProperties() {
        return Object.assign([], this.properties);
    } /**
   * Returns the VAST property with the given name
   * 
   * Possible properties are:
   * - type
   * - apiFramework
   * - variableDuration
   * 
   * @param {string} name the name of the property
   * @return {VASTProperty} a {@link VASTProperty} object or null if not found
   */ ;
    _proto.getProperty = function getProperty(name) {
        for(var _iterator = _createForOfIteratorHelperLoose(this.properties), _step; !(_step = _iterator()).done;){
            var prop = _step.value;
            if (prop.getName() === name) return prop;
        }
        return null;
    } /**
   * @return {string} the source URL for the interactive creative
   */ ;
    _proto.getSource = function getSource() {
        return this.source;
    };
    _proto.getTracking = function getTracking() {
        return this.tracking;
    };
    _proto.initialise = function initialise(adParameters, advertDuration, nonlinears) {
        this.adParameters = adParameters;
        this.advertDuration = advertDuration;
        this.nonLinearCreatives = [];
        var prop = this.getProperty("apiFramework");
        if (prop) {
            var propValue = prop.getValue();
            for(var _iterator2 = _createForOfIteratorHelperLoose(nonlinears), _step2; !(_step2 = _iterator2()).done;){
                var nlc = _step2.value;
                var nlcProp = nlc.getProperty("apiFramework");
                if (nlcProp && nlcProp.getValue() === propValue) this.nonLinearCreatives.push(nlc);
            }
        }
    };
    _proto.isSIMID = function isSIMID() {
        for(var _iterator3 = _createForOfIteratorHelperLoose(this.properties), _step3; !(_step3 = _iterator3()).done;){
            var prop = _step3.value;
            if (prop.getName() === "apiFramework" && prop.getValue() === "SIMID") return true;
        }
        return false;
    };
    _proto.isValid = function isValid() {
        return !(0, _StringUtils.isNullOrEmpty)(this.source);
    } /**
   * @return {boolean} true if the interactive creative is active and is to be displayed. Tracking events are fired only when the interactive creative is visible.
   */ ;
    _proto.isVisible = function isVisible() {
        return this.visible;
    };
    _proto.onClickThrough = function onClickThrough() {
    // No op
    };
    _proto.onTrackingEvent = function onTrackingEvent(url) {
        if (!this.isVisible()) {
            _YoLog.YoLog.w("Warning: InteractiveCreative is not visible");
            return;
        }
        if (!(0, _HttpUtils.getUrl)(url)) {
            _YoLog.YoLog.w("Invalid custom tracker URL");
            return;
        }
        // custom trackers are fired at the discretion of the client application,
        // but only for a SIMID implementation
        if (this.isSIMID()) this.broker.fireTrackingReport(new _TrackingReport.TrackingReport("custom", [
            url
        ]));
    };
    _proto.setTracking = function setTracking(report) {
        this.tracking = report;
    } /**
   * Defines whether the Interactive Creative is being presented to the user.
   * @param {boolean} visible the visibility flag
   */ ;
    _proto.setVisible = function setVisible(visible) {
        if (this.visible !== visible) {
            this.visible = visible;
            if (this.visible && this.isSIMID() && this.tracking) // fire SIMID beacons
            this.broker.fireTrackingReport(this.tracking);
        }
    };
    _proto.toString = function toString() {
        var ret = "InteractiveCreative source: " + this.source;
        if (this.properties.length > 0) {
            ret += "\nProperties:";
            for(var _iterator4 = _createForOfIteratorHelperLoose(this.properties), _step4; !(_step4 = _iterator4()).done;){
                var prop = _step4.value;
                ret += (0, _StringUtils.toIndentedString)(prop);
            }
        }
        if (this.tracking) {
            ret += "\nTracking event:";
            ret += (0, _StringUtils.toIndentedString)("\n " + this.tracking);
        }
        return ret;
    };
    return InteractiveCreative;
}(_CreativeEventHandler2.CreativeEventHandler);

},{"68a930feba9551f2":"7uXt7","589181e5b2112c78":"fbiP9","ccbfe438b03dd032":"jBmxg","1387f34a460ec3ce":"1lIbj","7868a30d78826293":"kiVVI","65a65127496cae80":"9KS65","6b414f4658d40376":"2wJyf"}],"1lIbj":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.NonLinearCreative = void 0;
var _Creative2 = require("200b96377e055641");
var _VideoClicks = require("a1ac8c5e8e283470");
var _CreativeUtils = require("3523dde0b1d67850");
var _StringUtils = require("ffc1de25b87928df");
var _YoLog = require("3513a7f278fe319c");
var _TrackingReport = require("eb6c1e503d0e1a26");
var _VASTProperty = require("53ae24ce9d262462");
var _Resource = require("50318461e4d41748");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// JsDoc/Typescript imports
/**
 * Represents a non-linear creative object.
 *
 * Encapsulates the data from the `<NonLinear>` element of a VAST document.<br/>
 * It is usually a graphic that overlays a small portion of the advert's video and is normally clickable.
 *
 * <b>NOTE:</b> The class implements CreativeEventHandler so that it can signal tracking events on behalf of
 * a client.  Tracking events are signalled only when the creative is visible.
 * 
 * <b>NOTE:</b> Refer to the User Guide for details of the supported tracking events for this creative.
 * 
 *  @hideconstructor
 * @see {@link Creative}, which this class extends
 */ var NonLinearCreative = exports.NonLinearCreative = /*#__PURE__*/ function(_Creative) {
    _inheritsLoose(NonLinearCreative, _Creative);
    function NonLinearCreative(creativeData, videoClicks, resources, broker) {
        var _this;
        _this = _Creative.call(this, creativeData) || this;
        /** @private */ _this.resources = new Map();
        /** @private */ _this.visible = false;
        /** @private */ _this.videoClicks = videoClicks ? videoClicks : new _VideoClicks.VideoClicks("", null, null);
        /** @private */ _this.properties = creativeData.properties ? creativeData.properties : [];
        /** @private */ _this.broker = broker;
        /** @private */ _this.trackingMap = new Map();
        if (resources) for(var _iterator = _createForOfIteratorHelperLoose(resources), _step; !(_step = _iterator()).done;){
            var res = _step.value;
            _this.resources.set(res.getResourceType(), res);
        }
        return _this;
    }
    var _proto = NonLinearCreative.prototype;
    _proto.getApiFramework = function getApiFramework() {
        var prop = this.getProperty("apiFramework");
        return prop ? prop.getValue() : null;
    } /**
   * @return {string} the clickthrough URL as a `string`
   */ ;
    _proto.getClickThroughUrl = function getClickThroughUrl() {
        return this.videoClicks.getClickThroughUrl();
    };
    _proto.getClickTrackingUrls = function getClickTrackingUrls() {
        return this.videoClicks.getClickTrackingUrls();
    } /** Returns the properties for the nonlinear creative. The properties are represented as YOVASTProperty objects. Possible properties are:
   * 
   * - width
   * - height
   * - expandedWidth
   * - expandedHeight
   * - minimumSuggestedDuration
   * - pxratio
   * - scalable
   * - maintainAspect
   * - apiFramework
   * 
   * @return {VASTProperty[]} an array of {@link VASTProperty} objects for the non-linear creative
   */ ;
    _proto.getProperties = function getProperties() {
        return Object.assign([], this.properties);
    } /**
   * Returns a named property for the nonlinear creative if it exists. Possible properties are:
   * 
   * - width
   * - height
   * - expandedWidth
   * - expandedHeight
   * - minimumSuggestedDuration
   * - pxratio
   * - scalable
   * - maintainAspect
   * - apiFramework
   * 
   * @param {string} name the name of the property
   * @return {VASTProperty} a {@link VASTProperty} object or null if not found
   */ ;
    _proto.getProperty = function getProperty(name) {
        for(var _iterator2 = _createForOfIteratorHelperLoose(this.properties), _step2; !(_step2 = _iterator2()).done;){
            var prop = _step2.value;
            if (prop.getName() === name) return prop;
        }
        return null;
    } /**
   * Returns the resource of the requested type.
   * @param {ResourceType} type the resource type
   * @return {Resource} a {@link Resource} of the type specified, or null if not found
   */ ;
    _proto.getResource = function getResource(type) {
        return this.resources.get(type);
    } /**
   * Returns the resources for the nonlinear creative. Each entry contains an array of resources keyed on the resource type.<br/>
   * The three resource types are optional elements; the dictionary will contain between one and three entries.
   * @return {Resource[]} an array of {@link Resource} objects for this non-linear creative
   */ ;
    _proto.getResources = function getResources() {
        return this.resources;
    };
    _proto.getTrackingReports = function getTrackingReports() {
        return this.trackingMap;
    };
    _proto.isValid = function isValid() {
        return (0, _CreativeUtils.isValidSize)(this.properties) && this.resources.size > 0;
    } /**
   * Defines whether the nonlinear creative is active and is to be displayed. Tracking events are
   * fired only for creatives that are visible.
   * @return {boolean} true if this creative is to be displayed
   */ ;
    _proto.isVisible = function isVisible() {
        return this.visible;
    };
    _proto.onClickThrough = function onClickThrough() {
        if (!this.visible) {
            _YoLog.YoLog.w("Nonlinear creative is not visible");
            return;
        }
        var urls = this.videoClicks.getClickTrackingUrls();
        if (urls.length > 0) {
            var report = (0, _CreativeUtils.getClickTrackingReport)(urls, "NonLinearClickTracking");
            if (report) this.broker.fireTrackingReportForCreative(report, this);
        }
    };
    _proto.onTrackingEvent = function onTrackingEvent(event) {
        if (!this.visible) {
            _YoLog.YoLog.w("Nonlinear creative is not visible");
            return;
        }
        if (_TrackingReport.TrackingReport.isValidVisibleEvent(event)) {
            _YoLog.YoLog.w("Use method setVisible() to signal event: " + event);
            return;
        }
        if (_TrackingReport.TrackingReport.isValidPlayerOperationEvent(event) && !this.isNonLinear) {
            _YoLog.YoLog.w("Use PlaybackEventHandler functions to signal event: " + event);
            return;
        }
        if (!_TrackingReport.TrackingReport.isValidNonLinearEvent(event)) {
            _YoLog.YoLog.w("Invalid tracking event: " + event);
            return;
        }
        var report = this.trackingMap.get(event);
        if (report) this.broker.fireTrackingReportForCreative(report, this);
        // SDK-811: Required for OMID
        if (event === "acceptInvitation") this.broker.raiseTrackingCallbackForCreative(event, this);
    };
    _proto.prefetchResources = function prefetchResources(timeout) {
        (0, _CreativeUtils.prefetch)(this.resources, timeout);
    };
    _proto.setTrackingReports = function setTrackingReports(trackingMap) {
        this.trackingMap = trackingMap;
    } /**
   * Defines whether the NonLinear Creative is being presented to the user.
   * @param {boolean} visible the visibility flag
   */ ;
    _proto.setVisible = function setVisible(visible) {
        if (this.visible !== visible) {
            this.visible = visible;
            var report = null;
            if (visible) report = this.trackingMap.get("creativeView");
            else report = this.trackingMap.get("close");
            if (report) this.broker.fireTrackingReportForCreative(report, this);
        }
    };
    _proto.toString = function toString() {
        var nlcString = "\n--- NonLinear Creative:";
        nlcString += (0, _StringUtils.toIndentedString)(this.videoClicks);
        if (this.properties.length > 0) nlcString += "\n - NonLinear Properties: ";
        for(var _iterator3 = _createForOfIteratorHelperLoose(this.properties), _step3; !(_step3 = _iterator3()).done;){
            var prop = _step3.value;
            nlcString += "\n" + (0, _StringUtils.toIndentedString)(prop);
        }
        if (this.resources.size > 0) nlcString += "\n - NonLinear Resource(s): ";
        for(var _iterator4 = _createForOfIteratorHelperLoose(this.resources), _step4; !(_step4 = _iterator4()).done;){
            var _step4$value = _step4.value, key = _step4$value[0], value = _step4$value[1];
            nlcString += (0, _StringUtils.toIndentedString)(key + ":" + value);
        }
        nlcString += _Creative.prototype.toString.call(this);
        return nlcString;
    };
    return NonLinearCreative;
}(_Creative2.Creative);

},{"200b96377e055641":"fZ00L","a1ac8c5e8e283470":"bOBcw","3523dde0b1d67850":"92ZM9","ffc1de25b87928df":"7uXt7","3513a7f278fe319c":"9KS65","eb6c1e503d0e1a26":"fbiP9","53ae24ce9d262462":"kiVVI","50318461e4d41748":"3iyI3"}],"hoOHl":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.SessionDVRLive = void 0;
var _SessionSeekable2 = require("c2b262d90b136257");
var _DashManifestParser = require("e79bb3b77a4900cc");
var _Event = require("dcec8ccaac75d0db");
var _HlsManifestParser = require("86961c7fdd0c0c7");
var _HttpConnection = require("2ef5672953fe7f39");
var _UrlPoller = require("7d97bf7c868ed0d4");
var _Parser = require("9a1c1bb0eeb0d008");
var _HttpUtils = require("16f19d07f3b2748");
var _StringUtils = require("8715862ec3d9885c");
var _YoLog = require("bb50dbcda72338a5");
var _PlaybackEventHandler = require("8902ec74bbb9b97f");
var _Session = require("9fb10a3ad2190fbd");
var _CallbackHelper = require("d4814c802ddaaad0");
var _Constant = require("964d349c3f5437b");
var _DefaultPlaybackPolicyHandler = require("88cc8ca9cdd29baf");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// JsDoc/Typescript imports
/**
 * Concrete Session implementation representing a single viewing of a single DVR live stream sourced from
 * the Yospace Video Platform via the Central Streaming Manager (CSM)
 * @see {@link Session} base class
 * @hideconstructor
 */ var SessionDVRLive = exports.SessionDVRLive = /*#__PURE__*/ function(_SessionSeekable) {
    _inheritsLoose(SessionDVRLive, _SessionSeekable);
    /**
   * 
   * @param {SessionProperties} properties the properties for the Session
   */ function SessionDVRLive(properties) {
        var _this;
        _this = _SessionSeekable.call(this, properties) || this;
        /** @private */ _this.streamStart = _Session.INVALID_WINDOW;
        /** @private */ _this.manifestData = new Map();
        /** @private */ _this.windowStart = _Session.INVALID_WINDOW;
        /** @private */ _this.windowEnd = _Session.INVALID_WINDOW;
        /** @private */ _this.windowSize = _Session.INVALID_WINDOW;
        /** @private */ _this.pausePoller = null;
        /** @private */ _this.pauseUrl = "";
        /** @private */ _this.targetDuration = _Constant.Constant.DEFAULT_POLLING_DELAY;
        _this.setPlaybackPolicyHandler(new _DefaultPlaybackPolicyHandler.DefaultPlaybackPolicyHandler(_Session.PlaybackMode.DVRLIVE));
        return _this;
    }
    /**
   * @callback sessionCallback 
   * @param {SessionDVRLive} session
   */ /**
   * The factory method for creating a SessionDVRLive instance, when using Direct Initialisation.
   * Constructs and initialises a new SessionDVRLive using the {@link SessionProperties} provided.
   * On completion calls the EventListener provided passing the initialised SessionDVRLive back if
   * a callback was provided.  If a callback was not provided, a Promise is returned instead.
   *
   * @param {string} url The Yospace initialisation URL to the Central Streaming Manager
   * @param {SessionProperties} [properties] (Optional) An initialisation properties object
   * @param {sessionCallback} [callback] (Optional) A completion handler to call after initialisation is finished
   */ SessionDVRLive.create = function create(url, properties, callback) {
        var session = new SessionDVRLive(properties);
        if (callback) session.initialiseFromSession(url).then(function() {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "Session initialised");
        })["catch"](function() {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "Session failed to initialise");
        })["finally"](function() {
            callback(new _Event.Event(session));
        });
        else return session.initialiseFromSession(url);
    };
    var _proto = SessionDVRLive.prototype;
    _proto.initialiseFromSession = function initialiseFromSession(url) {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
            _YoLog.YoLog.trace("sdk init");
            if (!(0, _HttpUtils.getUrl)(url)) {
                _this2.completeWithStatus(_Session.SessionState.FAILED, _Session.MALFORMED_URL);
                reject(_this2);
                return;
            }
            _HttpConnection.HttpConnection.get(url, {
                method: "GET"
            }, _this2.sessionProperties.getRequestTimeout(), _this2.sessionProperties.getCustomHttpHeaders()).then(function(response) {
                if (response.ok) {
                    var contentType = response.headers.get("content-type");
                    if (contentType && contentType.toLowerCase().includes("application/json")) {
                        if (_this2.handleFallbackUrl(response.body)) resolve(_this2);
                        else reject(_this2);
                    } else {
                        var playerUrl = response.url;
                        var payload = _this2.parseManifestResponse(response.body, playerUrl);
                        _this2.setPlaybackUrl(playerUrl);
                        _this2.initialiseFromPayload(payload);
                        if (_this2.getSessionState() !== _Session.SessionState.INITIALISED && _this2.getSessionState() !== _Session.SessionState.NO_ANALYTICS) reject(_this2);
                        if (_this2.getSessionState() === _Session.SessionState.INITIALISED) _this2.initialisePoller();
                        resolve(_this2);
                    }
                } else {
                    if (response.timeout) {
                        _YoLog.YoLog.e("Primary Url request failed: " + url + ", reason: timeout");
                        _this2.completeWithStatus(_Session.SessionState.FAILED, _Session.CONNECTION_TIMEOUT);
                    } else {
                        _YoLog.YoLog.e("Primary Url request failed: " + url + ", status: " + response.status + ", error: " + response.statusText);
                        _this2.completeWithStatus(_Session.SessionState.FAILED, response.status);
                    }
                    reject(_this2);
                }
            });
        });
    } /**
   * @return {number} the duration of the stream
   */ ;
    _proto.getDuration = function getDuration() {
        return this.windowEnd;
    };
    _proto.getPauseUrl = function getPauseUrl() {
        return this.pauseUrl;
    } /**
   * Defines the start point of the DVR Live stream as an epoch time, in seconds. The stream start is the time offset
   * of the first available video segment in the first manifest that is requested by the player.
   * 
   * @return {number} the start point of a DVR Live stream
   */ ;
    _proto.getStreamStart = function getStreamStart() {
        return this.streamStart;
    } /**
   * Returns data from the manifest for the given key. If no key is specified
   * then the entire map is returned.
   * <b>NOTE:</b> Refer to the User Guide for details of the supported data from the manifest.
   * 
   * @param {string} key (Optional) the key
   * @return {Map | number} the requested data, or `undefined` if not present.
   */ ;
    _proto.getManifestData = function getManifestData(key) {
        if (key) return this.manifestData.get(key);
        return this.manifestData;
    } /**
   * Defines the window start of the DVR Live stream, in seconds, as an offset relative to the stream start.
   * The DVR window represents the playable portion of the video stream.
   * 
   * @return {number} the window start point of a DVR Live stream relative to the stream start
   */ ;
    _proto.getWindowStart = function getWindowStart() {
        return this.windowStart;
    } /**
   * Defines the window end of the DVR Live stream, in seconds, as an offset relative to the stream start.
   * The DVR window represents the playable portion of the video stream.
   *
   * @return {number} the window end point of a DVR Live stream relative to the stream start
   */ ;
    _proto.getWindowEnd = function getWindowEnd() {
        return this.windowEnd;
    } /**
   * Defines the window size of a DVR Live stream, in seconds.
   * The DVR window represents the playable portion of the video stream.
   * 
   * @return {number} the window size of a DVR Live stream
   */ ;
    _proto.getWindowSize = function getWindowSize() {
        return this.windowSize;
    };
    _proto.removeExpiredAdBreaks = function removeExpiredAdBreaks() {
        // if streamStart is not valid, remove any adbreaks that have scrolled beyond the playhead,
        // otherwise remove any adbreaks that have scrolled out of the DVR window.
        // NB: nonlinear and display adbreaks don't expire
        var windowThreshold = this.streamStart === _Session.INVALID_WINDOW ? this.getPlayhead() : this.windowStart;
        var ab = this.getAdBreakForPlayhead(this.getPlayhead());
        for(var i = this.linearAdBreaks.length - 1; i >= 0; i--){
            var brk = this.linearAdBreaks[i];
            if (brk.getStart() + brk.getDuration() <= windowThreshold) {
                _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "Removing ad break.  Start: " + brk.getStart() + "; duration: " + brk.getDuration());
                // If the current adbreak has scrolled out of the window, clean it up.
                // This may happen if the playhead has paused inside an adbreak for a long time.
                if (brk === ab) {
                    _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "Removing the current adbreak");
                    // If there is a current advert, mark it inactive
                    var ad = ab.getAdvertFromPlayhead(this.getPlayhead());
                    if (ad) ad.setInactive();
                    this.onAdvertEnd();
                    this.onAdvertBreakEnd();
                }
                this.linearAdBreaks.splice(i, 1);
            }
        }
    } /**
   * Shutdown the current Session and release all resources. After this point the state and behaviour
   * is undefined and unsupported. The Session-derived instance must not be used following this call.
   */ ;
    _proto.shutdown = function shutdown() {
        _SessionSeekable.prototype.shutdown.call(this);
        // Due to JS "Run-to-completion", we don't expect any concurrency issues when shutting down and setting
        // the poller to null
        if (this.analyticPoller) {
            this.analyticPoller.shutdown();
            this.analyticPoller = null;
        }
        if (this.pausePoller) {
            this.pausePoller.shutdown();
            this.pausePoller = null;
        }
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "resources released");
    };
    _proto.getPlaybackMode = function getPlaybackMode() {
        return _Session.PlaybackMode.DVRLIVE;
    };
    _proto.initialisePoller = function initialisePoller() {
        var _this3 = this;
        if (!this.getAnalyticsUrl() || !this.pauseUrl || this.getSessionState() !== _Session.SessionState.INITIALISED) return;
        this.analyticPoller = new _UrlPoller.UrlPoller(this.getAnalyticsUrl(), this.getSessionProperties().getRequestTimeout(), function(response, retry) {
            if (response.status === 400) _this3.onSessionError(_Session.SessionErrorCode.TIMEOUT);
            else if (response.ok) {
                _this3.targetDuration = retry;
                _this3.parseAnalyticPayload(response.body);
            }
        });
        this.pausePoller = new _UrlPoller.UrlPoller(this.pauseUrl, this.getSessionProperties().getRequestTimeout(), null);
    };
    _proto.hasAnalyticUpdateChanged = function hasAnalyticUpdateChanged(vmap) {
        if (this.getLastAnalyticUpdate() && this.getLastAnalyticUpdate().isEqualTo(vmap)) {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, "Content unchanged.  Analytic update not delivered");
            return false;
        }
        return true;
    };
    _proto.adjustForPdtInitial = function adjustForPdtInitial(vmap) {
        if (this.streamStart === _Session.INVALID_WINDOW) {
            var pdtInitial = vmap.getPdtInitial();
            if (pdtInitial !== null) {
                this.streamStart = pdtInitial;
                if (!this.manifestData.get("availabilityStartTime")) this.manifestData.set("availabilityStartTime", new Date(pdtInitial));
            }
        }
    };
    _proto.handlePdtStartEnd = function handlePdtStartEnd(vmap) {
        var windowMoved = false;
        // Handle PDT start/end
        // If either of these are invalid, don't move the window
        var pdtStart = vmap.getPdtStart();
        var pdtEnd = vmap.getPdtEnd();
        if (pdtStart !== null && pdtEnd !== null) {
            var pdtStartTime = pdtStart;
            var pdtEndTime = pdtEnd;
            if (this.streamStart === _Session.INVALID_WINDOW) this.streamStart = pdtStartTime;
            var windowStart = pdtStartTime - this.streamStart;
            var windowEnd = pdtEndTime - this.streamStart;
            if (windowStart !== this.windowStart || windowEnd !== this.windowEnd) {
                windowMoved = true;
                this.windowStart = windowStart;
                this.windowEnd = windowEnd;
                this.windowSize = this.windowEnd - this.windowStart;
            }
        } else _YoLog.YoLog.w("PDT start/end value(s) invalid or missing");
        return windowMoved;
    };
    _proto.updateAdBreaks = function updateAdBreaks(vmap) {
        var adbreaks = vmap.getLinearAdBreaks();
        var nadbreaks = vmap.getNonLinearAdBreaks();
        var dabbreaks = vmap.getDisplayAdBreaks();
        var absize = adbreaks.length;
        var nabsize = nadbreaks.length;
        var dabsize = dabbreaks.length;
        Array.prototype.push.apply(this.linearAdBreaks, adbreaks);
        Array.prototype.push.apply(this.nonLinearAdBreaks, nadbreaks);
        if (this.streamStart === _Session.INVALID_WINDOW) _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, "Received " + absize + " linear, " + nabsize + " nonlinear " + dabsize + " display ad breaks");
        else _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, "Received: " + absize + " linear, " + nabsize + " nonlinear  " + dabsize + " display ad breaks. New window start: " + this.windowStart + ", end: " + this.windowEnd + " (total: " + this.windowSize + ")");
        this.removeExpiredAdBreaks();
    };
    _proto.parseAnalyticPayload = function parseAnalyticPayload(data) {
        var _this4 = this;
        // Clear any errors encountered previously
        this.clearParsingErrors();
        return _Parser.Parser.parse(data, this).then(function(vmap) {
            if (_this4.parsingErrors.length > 0) _this4.getReportsManager().raiseSessionErrorCallback(_Session.SessionErrorCode.PARSING_ERROR, _this4);
            if (!vmap) return null;
            if (!_this4.hasAnalyticUpdateChanged(vmap)) return vmap;
            var earlyReturn = vmap.getEarlyReturn();
            if (earlyReturn && earlyReturn !== -1) _this4.adjustForEarlyReturn(earlyReturn);
            _this4.adjustForPdtInitial(vmap);
            var windowMoved = _this4.handlePdtStartEnd(vmap);
            _this4.updateAdBreaks(vmap);
            // send onAnalyticUpdate() only if mStreamStart is valid and the window has moved,
            // or if there are new ad breaks
            if (_this4.streamStart !== _Session.INVALID_WINDOW && windowMoved || vmap.hasAdBreaks()) {
                _YoLog.YoLog.trace("sdk analytics " + vmap.getLinearAdBreaks().length + " " + vmap.getNonLinearAdBreaks().length + " " + vmap.getDisplayAdBreaks().length + " " + _this4.getDuration());
                // Notify all clients of the new VMAP
                _this4.setLastAnalyticUpdate(vmap);
                _this4.getReportsManager().raiseAnalyticUpdateCallback(_this4);
            }
            return vmap;
        })["catch"](function(err) {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_POLLING, "Analytic Poll completed with unreadable data: " + err);
            if (_this4.parsingErrors.length > 0) _this4.getReportsManager().raiseSessionErrorCallback(_Session.SessionErrorCode.PARSING_ERROR, _this4);
        });
    } /**
   * Sets all adverts inactive in all ad breaks prior to the given playhead position. If the playhead
   * is within an advert then that advert is NOT marked as inactive. This method allows client applications
   * to seek to a position before playback begins.
   *
   * @param playhead the playhead position
   */ ;
    _proto.setAdBreaksInactivePriorTo = function setAdBreaksInactivePriorTo(playhead) {
        for(var _iterator = _createForOfIteratorHelperLoose(this.linearAdBreaks), _step; !(_step = _iterator()).done;){
            var ab = _step.value;
            if (!ab.setAdvertsInactivePriorTo(playhead)) break;
        }
    };
    _proto.setStreamStart = function setStreamStart(val) {
        this.streamStart = val;
    };
    _proto.parseManifestResponse = function parseManifestResponse(response, url) {
        var playlist = response;
        if (_HlsManifestParser.HlsManifestParser.isHlsManifest(playlist)) {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, "Processing HLS master manifest: " + url);
            return _HlsManifestParser.HlsManifestParser.parse(playlist);
        } else {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, "Processing DASH manifest: " + url);
            return _DashManifestParser.DashManifestParser.parse(playlist);
        }
    };
    _proto.initialiseFromPayload = function initialiseFromPayload(payload) {
        if (!payload) {
            _YoLog.YoLog.e("Unable to process master manifest");
            this.completeWithStatus(_Session.SessionState.NO_ANALYTICS, _Session.UNKNOWN_FORMAT);
        } else if ((0, _StringUtils.isNullOrEmpty)(payload.getAnalyticUrl())) {
            _YoLog.YoLog.w("Analytics URL not found in manifest payload");
            this.completeWithStatus(_Session.SessionState.NO_ANALYTICS, 0);
        } else if (!(0, _HttpUtils.getUrl)(payload.getAnalyticUrl())) {
            _YoLog.YoLog.w("Malformed analytics URL in manifest");
            this.completeWithStatus(_Session.SessionState.NO_ANALYTICS, _Session.MALFORMED_URL);
        } else if (!(0, _HttpUtils.getUrl)(payload.getPlaybackUrl())) {
            _YoLog.YoLog.w("Player URL is invalid: " + payload.getPlaybackUrl());
            this.completeWithStatus(_Session.SessionState.NO_ANALYTICS, _Session.MALFORMED_URL);
        } else {
            this.setPlaybackUrl(payload.getPlaybackUrl());
            if ((0, _StringUtils.isNullOrEmpty)(payload.getPauseUrl())) {
                _YoLog.YoLog.e("Pause URL not found in manifest");
                this.completeWithStatus(_Session.SessionState.NO_ANALYTICS, _Session.NO_DVRLIVE);
            } else if (!(0, _HttpUtils.getUrl)(payload.getPauseUrl())) {
                _YoLog.YoLog.w("Malformed pause URL in manifest");
                this.completeWithStatus(_Session.SessionState.NO_ANALYTICS, _Session.NO_DVRLIVE);
            } else {
                // Parsed successfully for analytics
                this.setIdentifier(payload.getSessionIdentifier());
                this.setAnalyticsUrl(payload.getAnalyticUrl());
                this.pauseUrl = payload.getPauseUrl();
                this.manifestData.set("availabilityStartTime", payload.getAvailabilityStartTime());
                this.completeWithStatus(_Session.SessionState.INITIALISED, 0);
                _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "Successful. Url: " + this.getPlaybackUrl());
            }
        }
    };
    _proto.onPlaybackStart = function onPlaybackStart(playhead) {
        if (!this.isNotPlaying()) _YoLog.YoLog.w("Reporting START when start has already been reported");
        else if (this.getSessionState() !== _Session.SessionState.INITIALISED) _YoLog.YoLog.w("Reporting START when session is not initialised");
        else if (this.analyticPoller) {
            _SessionSeekable.prototype.onPlaybackStart.call(this, playhead);
            this.analyticPoller.start();
        }
    };
    _proto.onPlaybackReady = function onPlaybackReady() {
        // Handles any error messages
        _SessionSeekable.prototype.onPlaybackReady.call(this);
        if (this.getSessionState() === _Session.SessionState.INITIALISED && this.playing !== true) {
            if (this.analyticPoller) this.analyticPoller.request();
        }
    };
    _proto.onPlaybackPause = function onPlaybackPause() {
        if (!this.isNotPlaying()) {
            if (this.pausePoller && this.getSessionState() === _Session.SessionState.INITIALISED) this.pausePoller.start();
        }
        _SessionSeekable.prototype.onPlaybackPause.call(this);
    };
    _proto.onPlaybackResume = function onPlaybackResume() {
        if (this.isNotPlaying()) {
            if (this.pausePoller) this.pausePoller.stop();
        }
        _SessionSeekable.prototype.onPlaybackResume.call(this);
    };
    _proto.onPlayerEvent = function onPlayerEvent(event, playhead) {
        // Any non-linear playhead change must set didSeek
        if (event === _PlaybackEventHandler.PlayerEvent.SEEK || event === _PlaybackEventHandler.PlayerEvent.ADVERT_SKIP || event === _PlaybackEventHandler.PlayerEvent.ADVERT_REWIND) this.didSeek = true;
        _SessionSeekable.prototype.onPlayerEvent.call(this, event, playhead);
    };
    _proto.onPlayheadUpdate = function onPlayheadUpdate(playhead) {
        this.handleHeartbeat(playhead);
        _SessionSeekable.prototype.onPlayheadUpdate.call(this, playhead);
    };
    _proto.canPause = function canPause() {
        return this.streamStart !== _Session.INVALID_WINDOW && _SessionSeekable.prototype.canPause.call(this);
    };
    _proto.canSkip = function canSkip() {
        if (this.streamStart === _Session.INVALID_WINDOW) return -1;
        else if (this.policyHandler) {
            var ret = (0, _CallbackHelper.raiseCallback)(this.policyHandler, this.policyHandler.canSkip, this.getPlayhead(), this.linearAdBreaks, this.getDuration());
            if (ret === null) ret = this.defaultPolicyHandler.canSkip(this.getPlayhead(), this.linearAdBreaks, this.getDuration());
            return ret;
        } else return 0;
    };
    _proto.willSeekTo = function willSeekTo(position) {
        return this.streamStart === _Session.INVALID_WINDOW ? this.getPlayhead() : _SessionSeekable.prototype.willSeekTo.call(this, position);
    };
    return SessionDVRLive;
}(_SessionSeekable2.SessionSeekable);

},{"c2b262d90b136257":"6uJDY","e79bb3b77a4900cc":"d1z2P","dcec8ccaac75d0db":"kKDLv","86961c7fdd0c0c7":"1BUXo","2ef5672953fe7f39":"6cS9V","7d97bf7c868ed0d4":"5HX1P","9a1c1bb0eeb0d008":"iG6Z6","16f19d07f3b2748":"2wJyf","8715862ec3d9885c":"7uXt7","bb50dbcda72338a5":"9KS65","8902ec74bbb9b97f":"cPeeN","9fb10a3ad2190fbd":"62muZ","d4814c802ddaaad0":"40OIt","964d349c3f5437b":"5j00o","88cc8ca9cdd29baf":"4Kn9B"}],"6uJDY":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.SessionSeekable = void 0;
var _ReportsManager = require("27c0f4604b1a010f");
var _Session2 = require("718d18714f38b595");
var _Constant = require("b1db4d1468c02260");
var _YoLog = require("fb46fde264ac8903");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// In order to handle jitter in a player while seeking, e.g. the user may seek forward,
// change their mind, attempt to seek back to the same location, and then play; the resulting seek
// will not be exactly zero, and this would mark any playing advert inactive.
// This value determines the value under which the playhead is deemed NOT to have seeked.
// It is set at 2x the Yospace recommended minimum cadence of 250ms.
var ADVERT_START_THRESHOLD = 2 * _Constant.Constant.MAX_CADENCE;
/**
  *  Abstract Session implementation representing any seekable stream
  * @hideconstructor
  */ var SessionSeekable = exports.SessionSeekable = /*#__PURE__*/ function(_Session) {
    _inheritsLoose(SessionSeekable, _Session);
    function SessionSeekable(properties) {
        var _this;
        _this = _Session.call(this, properties) || this;
        _this.didSeek = false;
        _this.duration = 0;
        return _this;
    }
    /**
   * @returns {number} the duration of the stream
   */ var _proto = SessionSeekable.prototype;
    _proto.getDuration = function getDuration() {
        // Default implementation.  Can be overridden in derived classes.
        return this.duration;
    };
    _proto.initialiseFromAnalyticData = function initialiseFromAnalyticData(payload, scheme) {
        this.setPlaybackUrl(scheme + payload.getHostNode() + payload.getHostSuffix());
        this.setDuration(payload.getStreamDuration());
        this.setIdentifier(payload.getSessionIdentifier());
        Array.prototype.push.apply(this.linearAdBreaks, payload.getLinearAdBreaks());
        Array.prototype.push.apply(this.nonLinearAdBreaks, payload.getNonLinearAdBreaks());
        Array.prototype.push.apply(this.displayAdBreaks, payload.getDisplayAdBreaks());
    };
    _proto.mergePlaceholderBreaks = function mergePlaceholderBreaks(vmapResponse) {
        var success = true;
        for(var i = 0; i < this.linearAdBreaks.length; ++i){
            var lab = this.linearAdBreaks[i];
            if (lab.isPlaceholder()) for(var _iterator = _createForOfIteratorHelperLoose(vmapResponse.getLinearAdBreaks()), _step; !(_step = _iterator()).done;){
                var latest = _step.value;
                if (lab.getIdentifier() === latest.getIdentifier() && lab.getStart() === latest.getStart()) {
                    latest.postParse(this);
                    this.linearAdBreaks[i] = latest;
                }
            }
            if (this.linearAdBreaks[i].isPlaceholder()) {
                _YoLog.YoLog.e("Placeholder AdBreak with id " + lab.getIdentifier() + " not found");
                success = false;
            }
        }
        return success;
    };
    _proto.onAdvertBreakStart = function onAdvertBreakStart(adbreak) {
        if (this.getCurrentAdBreak()) return;
        this.clearTrackingErrors();
        this.setCurrentAdBreak(adbreak);
        _YoLog.YoLog.trace("adbreakStart");
        this.getReportsManager().raiseAdBreakCallback("start", this.getCurrentAdBreak(), this);
        if (adbreak && !this.reportsManager.shouldSuppress("breakStart")) {
            var report = adbreak.getTrackingReport("breakStart", true);
            this.getReportsManager().fireBeacon(report, new _ReportsManager.ReportingParams(this.getPlayhead()));
        }
    };
    _proto.onAdvertBreakEnd = function onAdvertBreakEnd() {
        var adbreak = this.getCurrentAdBreak();
        if (adbreak && !this.reportsManager.shouldSuppress("breakEnd")) {
            var report = adbreak.getTrackingReport("breakEnd", true);
            this.getReportsManager().fireBeacon(report, new _ReportsManager.ReportingParams(this.getPlayhead()));
        }
        _YoLog.YoLog.trace("adbreakEnd");
        this.getReportsManager().raiseAdBreakCallback("end", null, this);
        if (this.trackingErrors.length > 0) this.getReportsManager().raiseSessionErrorCallback(_Session2.SessionErrorCode.TRACKING_ERROR, this);
        this.setCurrentAdBreak(null);
    };
    _proto.onAdvertEnd = function onAdvertEnd() {
        var advert = this.getCurrentAdvert();
        if (advert && advert.isActive()) this.signalTimelineTrackingEvents(advert.getStart() + advert.getDuration());
        if (advert) advert.setInactive();
        _YoLog.YoLog.trace("advertEnd");
        this.getReportsManager().raiseAdvertCallback("end", null, this);
        this.setCurrentAdvert(null);
    };
    _proto.onAdvertStart = function onAdvertStart(advert) {
        if (this.getCurrentAdvert()) return;
        this.setCurrentAdvert(advert);
        _Session.prototype.onAdvertStart.call(this, advert);
        if (this.getReportsManager().reportsSuppressed()) // clear the advert tracking map because beacons are not fired for partial adverts
        advert.removeTrackingSchedule();
        _YoLog.YoLog.trace("advertStart");
        this.getReportsManager().raiseAdvertCallback("start", advert, this);
        if (advert && advert.isActive()) {
            // fire impressions
            this.fireImpressionReport();
            // fire any tracking urls at start
            this.signalTimelineTrackingEvents(_Constant.Constant.ADVERT_START_TIMESLOT);
        }
    };
    _proto.handlePostSeek = function handlePostSeek(playhead) {
        var previousPlayhead = this.getLastPlayed();
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "handlePostSeek: " + previousPlayhead + " -> " + playhead);
        // Only if the playhead has sought more than 2 maximum cadences into a new ad, or the playhead sought backwards,
        // then mark the new ad inactive.
        var interval = playhead - previousPlayhead;
        if (interval >= 0 && interval <= ADVERT_START_THRESHOLD) _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "handlePostSeek: ignoring interval " + interval + "ms");
        else if (!this.getCurrentAdBreak()) this.handlePostSeekForContent(playhead);
        else // In a break
        this.handlePostSeekForAdBreak(previousPlayhead, playhead);
    };
    _proto.handlePostSeekForContent = function handlePostSeekForContent(playhead) {
        var ab = this.adBreakForPlayhead(playhead);
        if (ab) {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "handlePostSeek: CONTENT -> BREAK");
            // The playhead has sought into the middle of the ad.  Clear the whole map for this ad
            // (Session does not raise any tracking events at all for any ad which hasn't been played from the start)
            var ad = ab.getAdvertFromPlayhead(playhead);
            if (ad && playhead - ad.getStart() > ADVERT_START_THRESHOLD) ad.setInactive();
        } else _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "handlePostSeek: within content");
    };
    _proto.handlePostSeekForAdBreak = function handlePostSeekForAdBreak(previousPlayhead, playhead) {
        var ab = this.adBreakForPlayhead(playhead);
        if (!ab) {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "handlePostSeek: BREAK -> CONTENT");
            // the playhead has sought out of the end of the ad (in either direction).  Mark the ad inactive
            // (an event has either been played already or else never will be).
            var lastAd = this.getCurrentAdBreak().getAdvertFromPlayhead(previousPlayhead);
            if (lastAd) lastAd.setInactive();
        } else if (ab !== this.getCurrentAdBreak()) {
            // The playhead has sought out of one adbreak straight into another, with no intervening content.
            // This is the same as BREAK/CONTENT followed by CONTENT/BREAK.
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "handlePostSeek: BREAK -> BREAK");
            var _lastAd = this.getCurrentAdBreak().getAdvertFromPlayhead(previousPlayhead);
            if (_lastAd) _lastAd.setInactive();
            var ad = ab.getAdvertFromPlayhead(playhead);
            if (ad && playhead - ad.getStart() > ADVERT_START_THRESHOLD) ad.setInactive();
        } else // ad -> ad?
        this.handlePostSeekForAdvertToAdvert(playhead);
    };
    _proto.handlePostSeekForAdvertToAdvert = function handlePostSeekForAdvertToAdvert(playhead) {
        var ad = this.getCurrentAdBreak().getAdvertFromPlayhead(playhead);
        if (ad) {
            // The playhead has either sought out of the current ad, or sought within it, so
            // mark the current ad inactive.
            this.getCurrentAdvert().setInactive();
            if (ad !== this.getCurrentAdvert()) {
                _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "handlePostSeek: ADVERT -> ADVERT");
                // The playhead has sought out of one ad and into another (in either direction), so
                // mark the new ad inactive
                if (playhead - ad.getStart() > ADVERT_START_THRESHOLD) ad.setInactive();
            } else _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "handlePostSeek: with advert");
        }
    };
    _proto.handleHeartbeat = function handleHeartbeat(playhead) {
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "handleHeartbeat (playhead: " + playhead + ")");
        if (this.didSeek) {
            this.handlePostSeek(playhead);
            this.didSeek = false;
        }
        var previousPlayhead = this.getLastPlayed();
        this.setPlayhead(playhead);
        if (!this.getCurrentAdBreak()) this.handleHeartbeatForContent(previousPlayhead, playhead);
        else // in a break
        this.handleHeartbeatForAdbreak(playhead);
    };
    _proto.handleHeartbeatForContent = function handleHeartbeatForContent(previousPlayhead, playhead) {
        var missed = this.missedOpportunityBreak(previousPlayhead, playhead);
        if (missed) {
            var params = new _ReportsManager.ReportingParams(this.getPlayhead());
            this.getReportsManager().fireBeacon(missed.getTrackingReport("breakStart", true), params);
            this.getReportsManager().fireBeacon(missed.getTrackingReport("breakEnd", true), params);
            if (this.linearAdBreaks.indexOf(missed) !== -1) this.linearAdBreaks.splice(this.linearAdBreaks.indexOf(missed), 1);
        }
        var ab = this.adBreakForPlayhead(playhead);
        if (ab) {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "CONTENT -> BREAK (playhead: " + playhead + ")");
            // content -> adbreak
            this.onAdvertBreakStart(ab);
            // Start the ad which should be playing according to the playhead
            var ad = ab.getAdvertFromPlayhead(playhead);
            if (ad) this.onAdvertStart(ad);
        }
    };
    _proto.handleHeartbeatForAdbreak = function handleHeartbeatForAdbreak(playhead) {
        var ab = this.adBreakForPlayhead(playhead);
        if (!ab) {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "BREAK -> CONTENT");
            // End the ad that was playing
            this.onAdvertEnd();
            this.onAdvertBreakEnd();
        } else if (ab !== this.getCurrentAdBreak()) {
            // Edge case: the playhead is moving from one adbreak straight into another with no intervening content.
            // This is the same as BREAK -> CONTENT followed by CONTENT -> BREAK
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "BREAK -> BREAK");
            this.onAdvertEnd();
            this.onAdvertBreakEnd();
            this.onAdvertBreakStart(ab);
            var ad = ab.getAdvertFromPlayhead(playhead);
            if (ad) this.onAdvertStart(ad);
        } else // Otherwise ad -> ad?
        this.handleHeartbeatForAdvertToAdvert(playhead);
    };
    _proto.handleHeartbeatForAdvertToAdvert = function handleHeartbeatForAdvertToAdvert(playhead) {
        var ad = this.getCurrentAdBreak().getAdvertFromPlayhead(playhead);
        if (ad) {
            if (ad !== this.getCurrentAdvert()) {
                _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "ADVERT -> ADVERT");
                this.onAdvertEnd();
                this.onAdvertStart(ad);
            } else {
                // Fire any quartiles
                var delta = Math.max(playhead - this.getCurrentAdvert().getStart(), 0);
                this.signalTimelineTrackingEvents(delta);
            }
        }
    };
    _proto.adBreakForPlayhead = function adBreakForPlayhead(playhead) {
        for(var _iterator2 = _createForOfIteratorHelperLoose(this.linearAdBreaks), _step2; !(_step2 = _iterator2()).done;){
            var ab = _step2.value;
            if (ab.getStart() <= playhead && playhead < ab.getStart() + ab.getDuration()) return ab;
        }
        return null;
    };
    _proto.missedOpportunityBreak = function missedOpportunityBreak(previousPlayhead, playhead) {
        for(var _iterator3 = _createForOfIteratorHelperLoose(this.linearAdBreaks), _step3; !(_step3 = _iterator3()).done;){
            var ab = _step3.value;
            // playhead at zero, at location or just passed?
            if (ab.getDuration() === 0) {
                var start = ab.getStart();
                if (previousPlayhead <= start && playhead >= start) return ab;
            }
        }
        return null;
    };
    _proto.onPlaybackStart = function onPlaybackStart(playhead) {
        _Session.prototype.onPlaybackStart.call(this, playhead);
        this.handleHeartbeat(playhead);
    };
    _proto.setAdBreaksInactivePriorTo = function setAdBreaksInactivePriorTo(playhead) {
        for(var _iterator4 = _createForOfIteratorHelperLoose(this.linearAdBreaks), _step4; !(_step4 = _iterator4()).done;){
            var ab = _step4.value;
            if (!ab.setAdvertsInactivePriorTo(playhead)) break;
        }
    };
    return SessionSeekable;
}(_Session2.Session);

},{"27c0f4604b1a010f":"kknG8","718d18714f38b595":"62muZ","b1db4d1468c02260":"5j00o","fb46fde264ac8903":"9KS65"}],"d1z2P":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.DashManifestParser = void 0;
var _YoLog = require("aa5ca0ba2956cf6c");
var _PlaylistPayload = require("1cadcbf04cbd0437");
var _sax = _interopRequireDefault(require("b55a3a337d2b9bd"));
var _Constant = require("6b021c798d2dcc5a");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
/*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ var YOJS_LOCATION_PATTERN = "yo.js=([^&]+)";
var JSESS_LOCATION_PATTERN = "/live/(\\d+)/.+?;jsessionid=([^?\\s]+)";
var INTER_SEGMENT_TIMEOUT_DASH = 1600;
var YO_JS = "yo.js";
var DashManifestParser = exports.DashManifestParser = /*#__PURE__*/ function() {
    function DashManifestParser() {
        this.data = new Map();
        this.s = "";
        this.error = null;
        this.onError = this.onError.bind(this);
        this.onText = this.onText.bind(this);
        this.onOpenTag = this.onOpenTag.bind(this);
        this.onCloseTag = this.onCloseTag.bind(this);
        this.onCdata = this.onCdata.bind(this);
    }
    DashManifestParser.parse = function parse(dashBytes) {
        if (!dashBytes || dashBytes.length === 0) {
            _YoLog.YoLog.e("Yospace DASH manifest is empty");
            return null;
        }
        var parser = new DashManifestParser();
        return parser.parse(dashBytes);
    };
    var _proto = DashManifestParser.prototype;
    _proto.parse = function parse(dashBytes) {
        var parser = _sax["default"].parser(true);
        parser.onerror = this.onError;
        parser.ontext = this.onText;
        parser.onopentag = this.onOpenTag;
        parser.onclosetag = this.onCloseTag;
        parser.oncdata = this.onCdata;
        parser.write(dashBytes);
        if (this.error) return null;
        return new _PlaylistPayload.PlaylistPayload(this.data, INTER_SEGMENT_TIMEOUT_DASH);
    };
    _proto.onCdata = function onCdata(data) {
        this.s += data;
    };
    _proto.onError = function onError() {
        this.error = true;
    };
    _proto.onCloseTag = function onCloseTag(tag) {
        if (tag.toUpperCase() === "LOCATION") {
            var location = this.s.trim();
            this.data.set(_Constant.Payload.LOCATION, location);
            var loc = location.split(/\?/);
            try {
                var url = new URL(loc[0]);
                this.data.set(_Constant.Payload.SCHEME, url.protocol.substring(0, url.protocol.length - 1));
                this.data.set(_Constant.Payload.HOSTNODE, url.hostname);
                this.data.set(_Constant.Payload.PORT, url.port);
                this.data.set(_Constant.Payload.QS, loc.length === 2 ? loc[1] : null);
                // parse out the identifiers
                var jsessLocationMatch = loc[0].match(JSESS_LOCATION_PATTERN);
                if (jsessLocationMatch) this.data.set(_Constant.Payload.IDENTIFIER, jsessLocationMatch[2]);
                else if (location.indexOf(YO_JS) !== -1) {
                    var yojsLocationMatch = location.match(YOJS_LOCATION_PATTERN);
                    if (yojsLocationMatch) this.data.set(_Constant.Payload.IDENTIFIER, yojsLocationMatch[1]);
                }
                if (this.data.get(_Constant.Payload.IDENTIFIER) === undefined) this.error = true;
            } catch (e) {
                _YoLog.YoLog.e("Failed to parse Location element: " + e);
                this.error = true;
            }
        }
    };
    _proto.onOpenTag = function onOpenTag(node) {
        this.s = "";
        if (node.name.toUpperCase() === "MPD") {
            this.data.set(_Constant.Payload.ANALYTICURL, node.attributes.analytics);
            this.data.set(_Constant.Payload.PAUSEURL, node.attributes.livePause);
            this.data.set(_Constant.Payload.AVAILABILITYSTART, new Date(node.attributes.availabilityStartTime));
        }
    };
    _proto.onText = function onText(text) {
        this.s = text;
    };
    return DashManifestParser;
}();

},{"aa5ca0ba2956cf6c":"9KS65","1cadcbf04cbd0437":"1ynoa","b55a3a337d2b9bd":"lEjO0","6b021c798d2dcc5a":"5j00o"}],"1ynoa":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.PlaylistPayload = void 0;
var _Constant = require("1c63ce732e6568c2");
/*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ var PlaylistPayload = exports.PlaylistPayload = /*#__PURE__*/ function() {
    function PlaylistPayload(data, interSegmentTimeout) {
        this.sessionIdentifier = data.get(_Constant.Payload.IDENTIFIER);
        this.location = data.get(_Constant.Payload.LOCATION);
        this.analyticUrl = data.get(_Constant.Payload.ANALYTICURL);
        this.pauseUrl = data.get(_Constant.Payload.PAUSEURL);
        this.availabilityStartTime = data.get(_Constant.Payload.AVAILABILITYSTART) || null; // set to `null` for HLS
        this.interSegmentTimeout = interSegmentTimeout;
    }
    var _proto = PlaylistPayload.prototype;
    _proto.getAnalyticUrl = function getAnalyticUrl() {
        return this.analyticUrl;
    };
    _proto.getIntersegmentTimeout = function getIntersegmentTimeout() {
        return this.interSegmentTimeout;
    };
    _proto.getPlaybackUrl = function getPlaybackUrl() {
        return this.location;
    };
    _proto.getPauseUrl = function getPauseUrl() {
        return this.pauseUrl;
    };
    _proto.getSessionIdentifier = function getSessionIdentifier() {
        return this.sessionIdentifier;
    };
    _proto.getAvailabilityStartTime = function getAvailabilityStartTime() {
        return this.availabilityStartTime;
    };
    return PlaylistPayload;
}();

},{"1c63ce732e6568c2":"5j00o"}],"lEjO0":[function(require,module,exports) {
var Buffer = require("cc177bc5143a1e52").Buffer;
(function(sax) {
    sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
    };
    sax.SAXParser = SAXParser;
    sax.SAXStream = SAXStream;
    sax.createStream = createStream;
    // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
    // since that's the earliest that a buffer overrun could occur.  This way, checks are
    // as rare as required, but as often as necessary to ensure never crossing this bound.
    // Furthermore, buffers are only tested at most once per write(), so passing a very
    // large string into write() might have undesirable effects, but this is manageable by
    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
    // edge case, result in creating at most one complete copy of the string passed in.
    // Set to Infinity to have unlimited buffers.
    sax.MAX_BUFFER_LENGTH = 65536;
    var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
    ];
    sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
    ];
    function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) return new SAXParser(strict, opt);
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        // namespaces form a prototype chain.
        // it always points at the current tag,
        // which protos to its parent tag.
        if (parser.opt.xmlns) parser.ns = Object.create(rootNS);
        // mostly just for error reporting
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) parser.position = parser.line = parser.column = 0;
        emit(parser, "onready");
    }
    if (!Object.create) Object.create = function(o) {
        function F() {}
        F.prototype = o;
        var newf = new F();
        return newf;
    };
    if (!Object.keys) Object.keys = function(o) {
        var a = [];
        for(var i in o)if (o.hasOwnProperty(i)) a.push(i);
        return a;
    };
    function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for(var i = 0, l = buffers.length; i < l; i++){
            var len = parser[buffers[i]].length;
            if (len > maxAllowed) // Text/cdata nodes can get big, and since they're buffered,
            // we can get here under normal conditions.
            // Avoid issues by emitting the text node now,
            // so at least it won't get any bigger.
            switch(buffers[i]){
                case "textNode":
                    closeText(parser);
                    break;
                case "cdata":
                    emitNode(parser, "oncdata", parser.cdata);
                    parser.cdata = "";
                    break;
                case "script":
                    emitNode(parser, "onscript", parser.script);
                    parser.script = "";
                    break;
                default:
                    error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
            maxActual = Math.max(maxActual, len);
        }
        // schedule the next check for the earliest possible buffer overrun.
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
        for(var i = 0, l = buffers.length; i < l; i++)parser[buffers[i]] = "";
    }
    function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
            emitNode(parser, "oncdata", parser.cdata);
            parser.cdata = "";
        }
        if (parser.script !== "") {
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
        }
    }
    SAXParser.prototype = {
        end: function() {
            end(this);
        },
        write: write,
        resume: function() {
            this.error = null;
            return this;
        },
        close: function() {
            return this.write(null);
        },
        flush: function() {
            flushBuffers(this);
        }
    };
    var Stream;
    try {
        Stream = require("acedd90de8235ff6").Stream;
    } catch (ex) {
        Stream = function() {};
    }
    var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
    });
    function createStream(strict, opt) {
        return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) return new SAXStream(strict, opt);
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
            me.emit("end");
        };
        this._parser.onerror = function(er) {
            me.emit("error", er);
            // if didn't throw, then means error was handled.
            // go ahead and clear error, so we can write again.
            me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
            Object.defineProperty(me, "on" + ev, {
                get: function() {
                    return me._parser["on" + ev];
                },
                set: function(h) {
                    if (!h) {
                        me.removeAllListeners(ev);
                        me._parser["on" + ev] = h;
                        return h;
                    }
                    me.on(ev, h);
                },
                enumerable: true,
                configurable: false
            });
        });
    }
    SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
            value: SAXStream
        }
    });
    SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
            if (!this._decoder) {
                var SD = require("647847c1fbbe7e6c").StringDecoder;
                this._decoder = new SD("utf8");
            }
            data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
    };
    SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) this.write(chunk);
        this._parser.end();
        return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [
                arguments[0]
            ] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
        };
        return Stream.prototype.on.call(me, ev, handler);
    };
    // this really needs to be replaced with character classes.
    // XML allows all manner of ridiculous numbers and digits.
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = {
        xml: XML_NAMESPACE,
        xmlns: XMLNS_NAMESPACE
    };
    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
    // This implementation works on strings, a single character at a time
    // as such, it cannot ever support astral-plane characters (10000-EFFFF)
    // without a significant breaking change to either this  parser, or the
    // JavaScript language.  Implementation of an emoji-capable xml parser
    // is left as an exercise for the reader.
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
    }
    function isQuote(c) {
        return c === '"' || c === "'";
    }
    function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
    }
    function isMatch(regex, c) {
        return regex.test(c);
    }
    function notMatch(regex, c) {
        return !isMatch(regex, c);
    }
    var S = 0;
    sax.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++ // <script> ... <
    };
    sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
    };
    sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
    };
    Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s = typeof e === "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s;
    });
    for(var s in sax.STATE)sax.STATE[sax.STATE[s]] = s;
    // shorthand
    S = sax.STATE;
    function emit(parser, event, data) {
        parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
    }
    function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
    }
    function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
    }
    function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
    }
    function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) error(parser, "Unexpected end");
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
    }
    function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) throw new Error("bad call to strictFail");
        if (parser.strict) error(parser, message);
    }
    function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = {
            name: parser.tagName,
            attributes: {}
        };
        // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
        if (parser.opt.xmlns) tag.ns = parent.ns;
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
    }
    function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? [
            "",
            name
        ] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        // <x "xmlns"="http://foo">
        if (attribute && name === "xmlns") {
            prefix = "xmlns";
            local = "";
        }
        return {
            prefix: prefix,
            local: local
        };
    }
    function attrib(parser) {
        if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]();
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
            parser.attribName = parser.attribValue = "";
            return;
        }
        if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true);
            var prefix = qn.prefix;
            var local = qn.local;
            if (prefix === "xmlns") {
                // namespace binding attribute. push the binding into scope
                if (local === "xml" && parser.attribValue !== XML_NAMESPACE) strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\n" + "Actual: " + parser.attribValue);
                else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\n" + "Actual: " + parser.attribValue);
                else {
                    var tag = parser.tag;
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    if (tag.ns === parent.ns) tag.ns = Object.create(parent.ns);
                    tag.ns[local] = parser.attribValue;
                }
            }
            // defer onattribute events until all attributes have been seen
            // so any new bindings can take effect. preserve attribute order
            // so deferred events can be emitted in document order
            parser.attribList.push([
                parser.attribName,
                parser.attribValue
            ]);
        } else {
            // in non-xmlns mode, we can emit the event right away
            parser.tag.attributes[parser.attribName] = parser.attribValue;
            emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: parser.attribValue
            });
        }
        parser.attribName = parser.attribValue = "";
    }
    function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
            // emit namespace binding events
            var tag = parser.tag;
            // add namespace info to tag
            var qn = qname(parser.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || "";
            if (tag.prefix && !tag.uri) {
                strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
                tag.uri = qn.prefix;
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns && parent.ns !== tag.ns) Object.keys(tag.ns).forEach(function(p) {
                emitNode(parser, "onopennamespace", {
                    prefix: p,
                    uri: tag.ns[p]
                });
            });
            // handle deferred onattribute events
            // Note: do not apply default ns to attributes:
            //   http://www.w3.org/TR/REC-xml-names/#defaulting
            for(var i = 0, l = parser.attribList.length; i < l; i++){
                var nv = parser.attribList[i];
                var name = nv[0];
                var value = nv[1];
                var qualName = qname(name, true);
                var prefix = qualName.prefix;
                var local = qualName.local;
                var uri = prefix === "" ? "" : tag.ns[prefix] || "";
                var a = {
                    name: name,
                    value: value,
                    prefix: prefix,
                    local: local,
                    uri: uri
                };
                // if there's any attributes with an undefined namespace,
                // then fail on them now.
                if (prefix && prefix !== "xmlns" && !uri) {
                    strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
                    a.uri = prefix;
                }
                parser.tag.attributes[name] = a;
                emitNode(parser, "onattribute", a);
            }
            parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        // process the tag
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
            // special case for <script> in non-strict mode.
            if (!parser.noscript && parser.tagName.toLowerCase() === "script") parser.state = S.SCRIPT;
            else parser.state = S.TEXT;
            parser.tag = null;
            parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
    }
    function closeTag(parser) {
        if (!parser.tagName) {
            strictFail(parser, "Weird empty close tag.");
            parser.textNode += "</>";
            parser.state = S.TEXT;
            return;
        }
        if (parser.script) {
            if (parser.tagName !== "script") {
                parser.script += "</" + parser.tagName + ">";
                parser.tagName = "";
                parser.state = S.SCRIPT;
                return;
            }
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
        }
        // first make sure that the closing tag actually exists.
        // <a><b></c></b></a> will close everything, otherwise.
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) tagName = tagName[parser.looseCase]();
        var closeTo = tagName;
        while(t--){
            var close = parser.tags[t];
            if (close.name !== closeTo) // fail the first time in strict mode
            strictFail(parser, "Unexpected close tag");
            else break;
        }
        // didn't find it.  we already failed for strict, so just abort.
        if (t < 0) {
            strictFail(parser, "Unmatched closing tag: " + parser.tagName);
            parser.textNode += "</" + parser.tagName + ">";
            parser.state = S.TEXT;
            return;
        }
        parser.tagName = tagName;
        var s = parser.tags.length;
        while(s-- > t){
            var tag = parser.tag = parser.tags.pop();
            parser.tagName = parser.tag.name;
            emitNode(parser, "onclosetag", parser.tagName);
            var x = {};
            for(var i in tag.ns)x[i] = tag.ns[i];
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (parser.opt.xmlns && tag.ns !== parent.ns) // remove namespace bindings introduced by tag
            Object.keys(tag.ns).forEach(function(p) {
                var n = tag.ns[p];
                emitNode(parser, "onclosenamespace", {
                    prefix: p,
                    uri: n
                });
            });
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
    }
    function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) return parser.ENTITIES[entity];
        if (parser.ENTITIES[entityLC]) return parser.ENTITIES[entityLC];
        entity = entityLC;
        if (entity.charAt(0) === "#") {
            if (entity.charAt(1) === "x") {
                entity = entity.slice(2);
                num = parseInt(entity, 16);
                numStr = num.toString(16);
            } else {
                entity = entity.slice(1);
                num = parseInt(entity, 10);
                numStr = num.toString(10);
            }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
            strictFail(parser, "Invalid character entity");
            return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
        if (c === "<") {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
            // have to process this as a text node.
            // weird, but happens.
            strictFail(parser, "Non-whitespace before first tag.");
            parser.textNode = c;
            parser.state = S.TEXT;
        }
    }
    function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) result = chunk.charAt(i);
        return result;
    }
    function write(chunk) {
        var parser = this;
        if (this.error) throw this.error;
        if (parser.closed) return error(parser, "Cannot write after close. Assign an onready handler.");
        if (chunk === null) return end(parser);
        if (typeof chunk === "object") chunk = chunk.toString();
        var i = 0;
        var c = "";
        while(true){
            c = charAt(chunk, i++);
            parser.c = c;
            if (!c) break;
            if (parser.trackPosition) {
                parser.position++;
                if (c === "\n") {
                    parser.line++;
                    parser.column = 0;
                } else parser.column++;
            }
            switch(parser.state){
                case S.BEGIN:
                    parser.state = S.BEGIN_WHITESPACE;
                    if (c === "\uFEFF") continue;
                    beginWhiteSpace(parser, c);
                    continue;
                case S.BEGIN_WHITESPACE:
                    beginWhiteSpace(parser, c);
                    continue;
                case S.TEXT:
                    if (parser.sawRoot && !parser.closedRoot) {
                        var starti = i - 1;
                        while(c && c !== "<" && c !== "&"){
                            c = charAt(chunk, i++);
                            if (c && parser.trackPosition) {
                                parser.position++;
                                if (c === "\n") {
                                    parser.line++;
                                    parser.column = 0;
                                } else parser.column++;
                            }
                        }
                        parser.textNode += chunk.substring(starti, i - 1);
                    }
                    if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                        parser.state = S.OPEN_WAKA;
                        parser.startTagPosition = parser.position;
                    } else {
                        if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) strictFail(parser, "Text data outside of root node.");
                        if (c === "&") parser.state = S.TEXT_ENTITY;
                        else parser.textNode += c;
                    }
                    continue;
                case S.SCRIPT:
                    // only non-strict
                    if (c === "<") parser.state = S.SCRIPT_ENDING;
                    else parser.script += c;
                    continue;
                case S.SCRIPT_ENDING:
                    if (c === "/") parser.state = S.CLOSE_TAG;
                    else {
                        parser.script += "<" + c;
                        parser.state = S.SCRIPT;
                    }
                    continue;
                case S.OPEN_WAKA:
                    // either a /, ?, !, or text is coming next.
                    if (c === "!") {
                        parser.state = S.SGML_DECL;
                        parser.sgmlDecl = "";
                    } else if (isWhitespace(c)) ;
                    else if (isMatch(nameStart, c)) {
                        parser.state = S.OPEN_TAG;
                        parser.tagName = c;
                    } else if (c === "/") {
                        parser.state = S.CLOSE_TAG;
                        parser.tagName = "";
                    } else if (c === "?") {
                        parser.state = S.PROC_INST;
                        parser.procInstName = parser.procInstBody = "";
                    } else {
                        strictFail(parser, "Unencoded <");
                        // if there was some whitespace, then add that in.
                        if (parser.startTagPosition + 1 < parser.position) {
                            var pad = parser.position - parser.startTagPosition;
                            c = new Array(pad).join(" ") + c;
                        }
                        parser.textNode += "<" + c;
                        parser.state = S.TEXT;
                    }
                    continue;
                case S.SGML_DECL:
                    if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                        emitNode(parser, "onopencdata");
                        parser.state = S.CDATA;
                        parser.sgmlDecl = "";
                        parser.cdata = "";
                    } else if (parser.sgmlDecl + c === "--") {
                        parser.state = S.COMMENT;
                        parser.comment = "";
                        parser.sgmlDecl = "";
                    } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                        parser.state = S.DOCTYPE;
                        if (parser.doctype || parser.sawRoot) strictFail(parser, "Inappropriately located doctype declaration");
                        parser.doctype = "";
                        parser.sgmlDecl = "";
                    } else if (c === ">") {
                        emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                        parser.sgmlDecl = "";
                        parser.state = S.TEXT;
                    } else if (isQuote(c)) {
                        parser.state = S.SGML_DECL_QUOTED;
                        parser.sgmlDecl += c;
                    } else parser.sgmlDecl += c;
                    continue;
                case S.SGML_DECL_QUOTED:
                    if (c === parser.q) {
                        parser.state = S.SGML_DECL;
                        parser.q = "";
                    }
                    parser.sgmlDecl += c;
                    continue;
                case S.DOCTYPE:
                    if (c === ">") {
                        parser.state = S.TEXT;
                        emitNode(parser, "ondoctype", parser.doctype);
                        parser.doctype = true // just remember that we saw it.
                        ;
                    } else {
                        parser.doctype += c;
                        if (c === "[") parser.state = S.DOCTYPE_DTD;
                        else if (isQuote(c)) {
                            parser.state = S.DOCTYPE_QUOTED;
                            parser.q = c;
                        }
                    }
                    continue;
                case S.DOCTYPE_QUOTED:
                    parser.doctype += c;
                    if (c === parser.q) {
                        parser.q = "";
                        parser.state = S.DOCTYPE;
                    }
                    continue;
                case S.DOCTYPE_DTD:
                    parser.doctype += c;
                    if (c === "]") parser.state = S.DOCTYPE;
                    else if (isQuote(c)) {
                        parser.state = S.DOCTYPE_DTD_QUOTED;
                        parser.q = c;
                    }
                    continue;
                case S.DOCTYPE_DTD_QUOTED:
                    parser.doctype += c;
                    if (c === parser.q) {
                        parser.state = S.DOCTYPE_DTD;
                        parser.q = "";
                    }
                    continue;
                case S.COMMENT:
                    if (c === "-") parser.state = S.COMMENT_ENDING;
                    else parser.comment += c;
                    continue;
                case S.COMMENT_ENDING:
                    if (c === "-") {
                        parser.state = S.COMMENT_ENDED;
                        parser.comment = textopts(parser.opt, parser.comment);
                        if (parser.comment) emitNode(parser, "oncomment", parser.comment);
                        parser.comment = "";
                    } else {
                        parser.comment += "-" + c;
                        parser.state = S.COMMENT;
                    }
                    continue;
                case S.COMMENT_ENDED:
                    if (c !== ">") {
                        strictFail(parser, "Malformed comment");
                        // allow <!-- blah -- bloo --> in non-strict mode,
                        // which is a comment of " blah -- bloo "
                        parser.comment += "--" + c;
                        parser.state = S.COMMENT;
                    } else parser.state = S.TEXT;
                    continue;
                case S.CDATA:
                    if (c === "]") parser.state = S.CDATA_ENDING;
                    else parser.cdata += c;
                    continue;
                case S.CDATA_ENDING:
                    if (c === "]") parser.state = S.CDATA_ENDING_2;
                    else {
                        parser.cdata += "]" + c;
                        parser.state = S.CDATA;
                    }
                    continue;
                case S.CDATA_ENDING_2:
                    if (c === ">") {
                        if (parser.cdata) emitNode(parser, "oncdata", parser.cdata);
                        emitNode(parser, "onclosecdata");
                        parser.cdata = "";
                        parser.state = S.TEXT;
                    } else if (c === "]") parser.cdata += "]";
                    else {
                        parser.cdata += "]]" + c;
                        parser.state = S.CDATA;
                    }
                    continue;
                case S.PROC_INST:
                    if (c === "?") parser.state = S.PROC_INST_ENDING;
                    else if (isWhitespace(c)) parser.state = S.PROC_INST_BODY;
                    else parser.procInstName += c;
                    continue;
                case S.PROC_INST_BODY:
                    if (!parser.procInstBody && isWhitespace(c)) continue;
                    else if (c === "?") parser.state = S.PROC_INST_ENDING;
                    else parser.procInstBody += c;
                    continue;
                case S.PROC_INST_ENDING:
                    if (c === ">") {
                        emitNode(parser, "onprocessinginstruction", {
                            name: parser.procInstName,
                            body: parser.procInstBody
                        });
                        parser.procInstName = parser.procInstBody = "";
                        parser.state = S.TEXT;
                    } else {
                        parser.procInstBody += "?" + c;
                        parser.state = S.PROC_INST_BODY;
                    }
                    continue;
                case S.OPEN_TAG:
                    if (isMatch(nameBody, c)) parser.tagName += c;
                    else {
                        newTag(parser);
                        if (c === ">") openTag(parser);
                        else if (c === "/") parser.state = S.OPEN_TAG_SLASH;
                        else {
                            if (!isWhitespace(c)) strictFail(parser, "Invalid character in tag name");
                            parser.state = S.ATTRIB;
                        }
                    }
                    continue;
                case S.OPEN_TAG_SLASH:
                    if (c === ">") {
                        openTag(parser, true);
                        closeTag(parser);
                    } else {
                        strictFail(parser, "Forward-slash in opening tag not followed by >");
                        parser.state = S.ATTRIB;
                    }
                    continue;
                case S.ATTRIB:
                    // haven't read the attribute name yet.
                    if (isWhitespace(c)) continue;
                    else if (c === ">") openTag(parser);
                    else if (c === "/") parser.state = S.OPEN_TAG_SLASH;
                    else if (isMatch(nameStart, c)) {
                        parser.attribName = c;
                        parser.attribValue = "";
                        parser.state = S.ATTRIB_NAME;
                    } else strictFail(parser, "Invalid attribute name");
                    continue;
                case S.ATTRIB_NAME:
                    if (c === "=") parser.state = S.ATTRIB_VALUE;
                    else if (c === ">") {
                        strictFail(parser, "Attribute without value");
                        parser.attribValue = parser.attribName;
                        attrib(parser);
                        openTag(parser);
                    } else if (isWhitespace(c)) parser.state = S.ATTRIB_NAME_SAW_WHITE;
                    else if (isMatch(nameBody, c)) parser.attribName += c;
                    else strictFail(parser, "Invalid attribute name");
                    continue;
                case S.ATTRIB_NAME_SAW_WHITE:
                    if (c === "=") parser.state = S.ATTRIB_VALUE;
                    else if (isWhitespace(c)) continue;
                    else {
                        strictFail(parser, "Attribute without value");
                        parser.tag.attributes[parser.attribName] = "";
                        parser.attribValue = "";
                        emitNode(parser, "onattribute", {
                            name: parser.attribName,
                            value: ""
                        });
                        parser.attribName = "";
                        if (c === ">") openTag(parser);
                        else if (isMatch(nameStart, c)) {
                            parser.attribName = c;
                            parser.state = S.ATTRIB_NAME;
                        } else {
                            strictFail(parser, "Invalid attribute name");
                            parser.state = S.ATTRIB;
                        }
                    }
                    continue;
                case S.ATTRIB_VALUE:
                    if (isWhitespace(c)) continue;
                    else if (isQuote(c)) {
                        parser.q = c;
                        parser.state = S.ATTRIB_VALUE_QUOTED;
                    } else {
                        strictFail(parser, "Unquoted attribute value");
                        parser.state = S.ATTRIB_VALUE_UNQUOTED;
                        parser.attribValue = c;
                    }
                    continue;
                case S.ATTRIB_VALUE_QUOTED:
                    if (c !== parser.q) {
                        if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                        else parser.attribValue += c;
                        continue;
                    }
                    attrib(parser);
                    parser.q = "";
                    parser.state = S.ATTRIB_VALUE_CLOSED;
                    continue;
                case S.ATTRIB_VALUE_CLOSED:
                    if (isWhitespace(c)) parser.state = S.ATTRIB;
                    else if (c === ">") openTag(parser);
                    else if (c === "/") parser.state = S.OPEN_TAG_SLASH;
                    else if (isMatch(nameStart, c)) {
                        strictFail(parser, "No whitespace between attributes");
                        parser.attribName = c;
                        parser.attribValue = "";
                        parser.state = S.ATTRIB_NAME;
                    } else strictFail(parser, "Invalid attribute name");
                    continue;
                case S.ATTRIB_VALUE_UNQUOTED:
                    if (!isAttribEnd(c)) {
                        if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_U;
                        else parser.attribValue += c;
                        continue;
                    }
                    attrib(parser);
                    if (c === ">") openTag(parser);
                    else parser.state = S.ATTRIB;
                    continue;
                case S.CLOSE_TAG:
                    if (!parser.tagName) {
                        if (isWhitespace(c)) continue;
                        else if (notMatch(nameStart, c)) {
                            if (parser.script) {
                                parser.script += "</" + c;
                                parser.state = S.SCRIPT;
                            } else strictFail(parser, "Invalid tagname in closing tag.");
                        } else parser.tagName = c;
                    } else if (c === ">") closeTag(parser);
                    else if (isMatch(nameBody, c)) parser.tagName += c;
                    else if (parser.script) {
                        parser.script += "</" + parser.tagName;
                        parser.tagName = "";
                        parser.state = S.SCRIPT;
                    } else {
                        if (!isWhitespace(c)) strictFail(parser, "Invalid tagname in closing tag");
                        parser.state = S.CLOSE_TAG_SAW_WHITE;
                    }
                    continue;
                case S.CLOSE_TAG_SAW_WHITE:
                    if (isWhitespace(c)) continue;
                    if (c === ">") closeTag(parser);
                    else strictFail(parser, "Invalid characters in closing tag");
                    continue;
                case S.TEXT_ENTITY:
                case S.ATTRIB_VALUE_ENTITY_Q:
                case S.ATTRIB_VALUE_ENTITY_U:
                    var returnState;
                    var buffer;
                    switch(parser.state){
                        case S.TEXT_ENTITY:
                            returnState = S.TEXT;
                            buffer = "textNode";
                            break;
                        case S.ATTRIB_VALUE_ENTITY_Q:
                            returnState = S.ATTRIB_VALUE_QUOTED;
                            buffer = "attribValue";
                            break;
                        case S.ATTRIB_VALUE_ENTITY_U:
                            returnState = S.ATTRIB_VALUE_UNQUOTED;
                            buffer = "attribValue";
                            break;
                    }
                    if (c === ";") {
                        parser[buffer] += parseEntity(parser);
                        parser.entity = "";
                        parser.state = returnState;
                    } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) parser.entity += c;
                    else {
                        strictFail(parser, "Invalid character in entity name");
                        parser[buffer] += "&" + parser.entity + c;
                        parser.entity = "";
                        parser.state = returnState;
                    }
                    continue;
                default:
                    throw new Error(parser, "Unknown state: " + parser.state);
            }
        } // while
        if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser);
        return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */ /* istanbul ignore next */ if (!String.fromCodePoint) (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        var fromCodePoint = function() {
            var MAX_SIZE = 0x4000;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) return "";
            var result = "";
            while(++index < length){
                var codePoint = Number(arguments[index]);
                if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                codePoint < 0 || // not a valid Unicode code point
                codePoint > 0x10FFFF || // not a valid Unicode code point
                floor(codePoint) !== codePoint // not an integer
                ) throw RangeError("Invalid code point: " + codePoint);
                if (codePoint <= 0xFFFF) codeUnits.push(codePoint);
                else {
                    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                    codePoint -= 0x10000;
                    highSurrogate = (codePoint >> 10) + 0xD800;
                    lowSurrogate = codePoint % 0x400 + 0xDC00;
                    codeUnits.push(highSurrogate, lowSurrogate);
                }
                if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                    result += stringFromCharCode.apply(null, codeUnits);
                    codeUnits.length = 0;
                }
            }
            return result;
        };
        /* istanbul ignore next */ if (Object.defineProperty) Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: true,
            writable: true
        });
        else String.fromCodePoint = fromCodePoint;
    })();
})(exports);

},{"cc177bc5143a1e52":"9BBmc","acedd90de8235ff6":"bdsgY","647847c1fbbe7e6c":"dk5HH"}],"9BBmc":[function(require,module,exports) {
"use strict";

},{}],"bdsgY":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;
var EE = require("96b62835346f84f0").EventEmitter;
var inherits = require("4a6ee9586f51c38d");
inherits(Stream, EE);
Stream.Readable = require("e6206e1f4d20abc7");
Stream.Writable = require("a3f1405f37e1dfb1");
Stream.Duplex = require("6691a72c5fc222fd");
Stream.Transform = require("43a905ce7ec6ac9e");
Stream.PassThrough = require("dd715550d7783885");
Stream.finished = require("d90a3520974ec96e");
Stream.pipeline = require("eb2779cfd287c5c9");
// Backwards-compat with node 0.4.x
Stream.Stream = Stream;
// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.
function Stream() {
    EE.call(this);
}
Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
        if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) source.pause();
        }
    }
    source.on("data", ondata);
    function ondrain() {
        if (source.readable && source.resume) source.resume();
    }
    dest.on("drain", ondrain);
    // If the 'end' option is not supplied, dest.end() will be called when
    // source gets the 'end' or 'close' events.  Only dest.end() once.
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
    }
    function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
    }
    // don't leave dangling pipes when there are errors.
    function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) throw er; // Unhandled stream error in pipe.
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    // remove all the event listeners that were added.
    function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    // Allow for unix-like usage: A.pipe(B).pipe(C)
    return dest;
};

},{"96b62835346f84f0":"aoA0X","4a6ee9586f51c38d":"5bfIJ","e6206e1f4d20abc7":"7B9yT","a3f1405f37e1dfb1":"5ruFN","6691a72c5fc222fd":"4EQB4","43a905ce7ec6ac9e":"4M8aw","dd715550d7783885":"lp9kT","d90a3520974ec96e":"5GCvx","eb2779cfd287c5c9":"gYjP2"}],"aoA0X":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") ReflectOwnKeys = R.ownKeys;
else if (Object.getOwnPropertySymbols) ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
};
else ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
};
function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function EventEmitter() {
    EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;
// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
    if (typeof listener !== "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        defaultMaxListeners = arg;
    }
});
EventEmitter.init = function() {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);
    var doError = type === "error";
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;
    else if (!doError) return false;
    // If there is no 'error' event listener then throw.
    if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) // Note: The comments on the `throw` lines are intentional, they show
        // up in Node's output if this results in an unhandled exception.
        throw er; // Unhandled 'error' event
        // At least give some kind of context to the user
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err; // Unhandled 'error' event
    }
    var handler = events[type];
    if (handler === undefined) return false;
    if (typeof handler === "function") ReflectApply(handler, this, args);
    else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
            target.emit("newListener", type, listener.listener ? listener.listener : listener);
            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [
            listener,
            existing
        ] : [
            existing,
            listener
        ];
        else if (prepend) existing.unshift(listener);
        else existing.push(listener);
        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners " + "added. Use emitter.setMaxListeners() to " + "increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    var state = {
        fired: false,
        wrapFn: undefined,
        target: target,
        type: type,
        listener: listener
    };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = Object.create(null);
        else {
            delete events[type];
            if (events.removeListener) this.emit("removeListener", type, list.listener || listener);
        }
    } else if (typeof list !== "function") {
        position = -1;
        for(i = list.length - 1; i >= 0; i--)if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else spliceOne(list, position);
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== undefined) this.emit("removeListener", type, originalListener || listener);
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this;
    // not listening for removeListener, no need to emit
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);
            else delete events[type];
        }
        return this;
    }
    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for(i = 0; i < keys.length; ++i){
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    listeners = events[type];
    if (typeof listeners === "function") this.removeListener(type, listeners);
    else if (listeners !== undefined) // LIFO order
    for(i = listeners.length - 1; i >= 0; i--)this.removeListener(type, listeners[i]);
    return this;
};
function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === "function") return unwrap ? [
        evlistener.listener || evlistener
    ] : [
        evlistener
    ];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") return emitter.listenerCount(type);
    else return listenerCount.call(emitter, type);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === "function") return 1;
        else if (evlistener !== undefined) return evlistener.length;
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
    var copy = new Array(n);
    for(var i = 0; i < n; ++i)copy[i] = arr[i];
    return copy;
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for(var i = 0; i < ret.length; ++i)ret[i] = arr[i].listener || arr[i];
    return ret;
}
function once(emitter, name) {
    return new Promise(function(resolve, reject) {
        function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
        }
        function resolver() {
            if (typeof emitter.removeListener === "function") emitter.removeListener("error", errorListener);
            resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== "error") addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true
        });
    });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") eventTargetAgnosticAddListener(emitter, "error", handler, flags);
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags.once) emitter.once(name, listener);
        else emitter.on(name, listener);
    } else if (typeof emitter.addEventListener === "function") // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
        // IE does not have builtin `{ once: true }` support so we
        // have to do it manually.
        if (flags.once) emitter.removeEventListener(name, wrapListener);
        listener(arg);
    });
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
}

},{}],"5bfIJ":[function(require,module,exports) {
if (typeof Object.create === "function") // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

},{}],"7B9yT":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var global = arguments[3];
var process = require("896ff8d56553f7a");
"use strict";
module.exports = Readable;
/*<replacement>*/ var Duplex;
/*</replacement>*/ Readable.ReadableState = ReadableState;
/*<replacement>*/ var EE = require("16782d660ac22e0c").EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
};
/*</replacement>*/ /*<replacement>*/ var Stream = require("9a34f23fa53f83f7");
/*</replacement>*/ var Buffer = require("fb95ecaa88342eae").Buffer;
var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/ var debugUtil = require("a4a723b7297c7152");
var debug;
if (debugUtil && debugUtil.debuglog) debug = debugUtil.debuglog("stream");
else debug = function debug() {};
/*</replacement>*/ var BufferList = require("7a14cc1689b8c63e");
var destroyImpl = require("efa8155386cc4283");
var _require = require("994c984d08c7bbf2"), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require("8de60461b822641b").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
require("19affa8ce41f090d")(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = [
    "error",
    "close",
    "destroy",
    "pause",
    "resume"
];
function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}
function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require("f1c95f846e94e4eb");
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true;
    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'end' (and potentially 'finish')
    this.autoDestroy = !!options.autoDestroy;
    // has it been destroyed
    this.destroyed = false;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;
    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!StringDecoder) StringDecoder = require("6392acd10886f115").StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    Duplex = Duplex || require("f1c95f846e94e4eb");
    if (!(this instanceof Readable)) return new Readable(options);
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
}
Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined) return false;
        return this._readableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
    cb(err);
};
// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = "";
            }
            skipChunkCheck = true;
        }
    } else skipChunkCheck = true;
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};
// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) errorOrDestroy(stream, er);
        else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) chunk = _uint8ArrayToBuffer(chunk);
            if (addToFront) {
                if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                else addChunk(stream, state, chunk, true);
            } else if (state.ended) errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            else if (state.destroyed) return false;
            else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                    else maybeReadMore(stream, state);
                } else addChunk(stream, state, chunk, false);
            }
        } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
        }
    }
    // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) er = new ERR_INVALID_ARG_TYPE("chunk", [
        "string",
        "Buffer",
        "Uint8Array"
    ], chunk);
    return er;
}
Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
};
// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = require("6392acd10886f115").StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    // If setEncoding(null), decoder.encoding equals utf8
    this._readableState.encoding = this._readableState.decoder.encoding;
    // Iterate over current buffer to convert already stored Buffers:
    var p = this._readableState.buffer.head;
    var content = "";
    while(p !== null){
        content += decoder.write(p.data);
        p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
};
// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
    else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
}
// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false;
    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
    }
    n = howMuchToRead(n, state);
    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
    }
    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug("need readable", doRead);
    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
    } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    } else {
        state.length -= n;
        state.awaitDrain = 0;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;
        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
};
function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
    else {
        // emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;
        if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
        }
    }
}
// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
    }
    // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
}
// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while(!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)){
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) break;
    }
    state.readingMore = false;
}
// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        // cleanup event handlers once the pipe is broken
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug("false write response, pause", state.awaitDrain);
                state.awaitDrain++;
            }
            src.pause();
        }
    }
    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    // Make sure our error handler is attached before userland ones.
    prependListener(dest, "error", onerror);
    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    // tell the dest that it's being piped to
    dest.emit("pipe", src);
    // start the flow if it hasn't been started already.
    if (!state.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    };
    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;
    // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
    }
    // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++)dests[i].emit("unpipe", this, {
            hasUnpiped: false
        });
        return this;
    }
    // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
        // update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount("readable") > 0;
        // Try start flowing on next tick if stream isn't explicitly paused
        if (state.flowing !== false) this.resume();
    } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) emitReadable(this);
            else if (!state.reading) process.nextTick(nReadingNextTick, this);
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
    return res;
};
Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
    return res;
};
function updateReadableListening(self1) {
    var state = self1._readableState;
    state.readableListening = self1.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;
    else if (self1.listenerCount("data") > 0) self1.resume();
}
function nReadingNextTick(self1) {
    debug("readable nexttick read 0");
    self1.read(0);
}
// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        debug("resume");
        // we flow only if there is no one listening
        // for readable, but we still have to call
        // resume()
        state.flowing = !state.readableListening;
        resume(this, state);
    }
    state.paused = false;
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) stream.read(0);
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
};
function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null);
}
// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    });
    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream)if (this[i] === undefined && typeof stream[i] === "function") this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
        };
    }(i);
    // proxy certain important events.
    for(var n = 0; n < kProxyEvents.length; n++)stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};
if (typeof Symbol === "function") Readable.prototype[Symbol.asyncIterator] = function() {
    if (createReadableStreamAsyncIterator === undefined) createReadableStreamAsyncIterator = require("830c56f840811f05");
    return createReadableStreamAsyncIterator(this);
};
Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.highWaterMark;
    }
});
Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState && this._readableState.buffer;
    }
});
Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.flowing;
    },
    set: function set(state) {
        if (this._readableState) this._readableState.flowing = state;
    }
});
// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.length;
    }
});
// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else // read part of list
    ret = state.buffer.consume(n, state.decoder);
    return ret;
}
function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the writable side is ready for autoDestroy as well
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) stream.destroy();
        }
    }
}
if (typeof Symbol === "function") Readable.from = function(iterable, opts) {
    if (from === undefined) from = require("7451b8c4bf72370");
    return from(Readable, iterable, opts);
};
function indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}

},{"896ff8d56553f7a":"8NJDu","16782d660ac22e0c":"aoA0X","9a34f23fa53f83f7":"BkEUw","fb95ecaa88342eae":"9BBmc","a4a723b7297c7152":"9BBmc","7a14cc1689b8c63e":"3m5ce","efa8155386cc4283":"8klsy","994c984d08c7bbf2":"2I36I","8de60461b822641b":"37XqY","19affa8ce41f090d":"5bfIJ","f1c95f846e94e4eb":"4EQB4","6392acd10886f115":"dk5HH","830c56f840811f05":"4Tac1","7451b8c4bf72370":"hyOuy"}],"8NJDu":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"BkEUw":[function(require,module,exports) {
module.exports = require("ed88fc9aa73f911").EventEmitter;

},{"ed88fc9aa73f911":"aoA0X"}],"3m5ce":[function(require,module,exports) {
"use strict";
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var _require = require("59f5d0111b7fa075"), Buffer = _require.Buffer;
var _require2 = require("eef6a677577349b8"), inspect = _require2.inspect;
var custom = inspect && inspect.custom || "inspect";
function copyBuffer(src, target, offset) {
    Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/ function() {
    function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    _createClass(BufferList, [
        {
            key: "push",
            value: function push(v) {
                var entry = {
                    data: v,
                    next: null
                };
                if (this.length > 0) this.tail.next = entry;
                else this.head = entry;
                this.tail = entry;
                ++this.length;
            }
        },
        {
            key: "unshift",
            value: function unshift(v) {
                var entry = {
                    data: v,
                    next: this.head
                };
                if (this.length === 0) this.tail = entry;
                this.head = entry;
                ++this.length;
            }
        },
        {
            key: "shift",
            value: function shift() {
                if (this.length === 0) return;
                var ret = this.head.data;
                if (this.length === 1) this.head = this.tail = null;
                else this.head = this.head.next;
                --this.length;
                return ret;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.head = this.tail = null;
                this.length = 0;
            }
        },
        {
            key: "join",
            value: function join(s) {
                if (this.length === 0) return "";
                var p = this.head;
                var ret = "" + p.data;
                while(p = p.next)ret += s + p.data;
                return ret;
            }
        },
        {
            key: "concat",
            value: function concat(n) {
                if (this.length === 0) return Buffer.alloc(0);
                var ret = Buffer.allocUnsafe(n >>> 0);
                var p = this.head;
                var i = 0;
                while(p){
                    copyBuffer(p.data, ret, i);
                    i += p.data.length;
                    p = p.next;
                }
                return ret;
            }
        },
        {
            key: "consume",
            value: function consume(n, hasStrings) {
                var ret;
                if (n < this.head.data.length) {
                    // `slice` is the same for buffers and strings.
                    ret = this.head.data.slice(0, n);
                    this.head.data = this.head.data.slice(n);
                } else if (n === this.head.data.length) // First chunk is a perfect match.
                ret = this.shift();
                else // Result spans more than one buffer.
                ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                return ret;
            }
        },
        {
            key: "first",
            value: function first() {
                return this.head.data;
            }
        },
        {
            key: "_getString",
            value: function _getString(n) {
                var p = this.head;
                var c = 1;
                var ret = p.data;
                n -= ret.length;
                while(p = p.next){
                    var str = p.data;
                    var nb = n > str.length ? str.length : n;
                    if (nb === str.length) ret += str;
                    else ret += str.slice(0, n);
                    n -= nb;
                    if (n === 0) {
                        if (nb === str.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = str.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: "_getBuffer",
            value: function _getBuffer(n) {
                var ret = Buffer.allocUnsafe(n);
                var p = this.head;
                var c = 1;
                p.data.copy(ret);
                n -= p.data.length;
                while(p = p.next){
                    var buf = p.data;
                    var nb = n > buf.length ? buf.length : n;
                    buf.copy(ret, ret.length - n, 0, nb);
                    n -= nb;
                    if (n === 0) {
                        if (nb === buf.length) {
                            ++c;
                            if (p.next) this.head = p.next;
                            else this.head = this.tail = null;
                        } else {
                            this.head = p;
                            p.data = buf.slice(nb);
                        }
                        break;
                    }
                    ++c;
                }
                this.length -= c;
                return ret;
            }
        },
        {
            key: custom,
            value: function value(_, options) {
                return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
                    // Only inspect one level.
                    depth: 0,
                    // It should not recurse.
                    customInspect: false
                }));
            }
        }
    ]);
    return BufferList;
}();

},{"59f5d0111b7fa075":"9BBmc","eef6a677577349b8":"9BBmc"}],"8klsy":[function(require,module,exports) {
var process = require("4284522496af5dfb");
"use strict";
// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) cb(err);
        else if (err) {
            if (!this._writableState) process.nextTick(emitErrorNT, this, err);
            else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                process.nextTick(emitErrorNT, this, err);
            }
        }
        return this;
    }
    // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) this._readableState.destroyed = true;
    // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) this._writableState.destroyed = true;
    this._destroy(err || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) process.nextTick(emitErrorAndCloseNT, _this, err);
            else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                process.nextTick(emitErrorAndCloseNT, _this, err);
            } else process.nextTick(emitCloseNT, _this);
        } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err);
        } else process.nextTick(emitCloseNT, _this);
    });
    return this;
}
function emitErrorAndCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose) return;
    if (self._readableState && !self._readableState.emitClose) return;
    self.emit("close");
}
function undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function emitErrorNT(self, err) {
    self.emit("error", err);
}
function errorOrDestroy(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
}
module.exports = {
    destroy: destroy,
    undestroy: undestroy,
    errorOrDestroy: errorOrDestroy
};

},{"4284522496af5dfb":"8NJDu"}],"2I36I":[function(require,module,exports) {
"use strict";
var ERR_INVALID_OPT_VALUE = require("4e508d569e2117ef").codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    }
    // Default value
    return state.objectMode ? 16 : 16384;
}
module.exports = {
    getHighWaterMark: getHighWaterMark
};

},{"4e508d569e2117ef":"37XqY"}],"37XqY":[function(require,module,exports) {
"use strict";
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code, message, Base) {
    if (!Base) Base = Error;
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") return message;
        else return message(arg1, arg2, arg3);
    }
    var NodeError = /*#__PURE__*/ function(_Base) {
        _inheritsLoose(NodeError, _Base);
        function NodeError(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError;
    }(Base);
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
            return String(i);
        });
        if (len > 2) return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        else if (len === 2) return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        else return "of ".concat(thing, " ").concat(expected[0]);
    } else return "of ".concat(thing, " ").concat(String(expected));
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) this_len = str.length;
    return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
    if (typeof start !== "number") start = 0;
    if (start + search.length > str.length) return false;
    else return str.indexOf(search, start) !== -1;
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
    } else determiner = "must be";
    var msg;
    if (endsWith(name, " argument")) // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
module.exports.codes = codes;

},{}],"4EQB4":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
var process = require("2ab1115635c50a9f");
"use strict";
/*<replacement>*/ var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj)keys.push(key);
    return keys;
};
/*</replacement>*/ module.exports = Duplex;
var Readable = require("68a7582259cd5865");
var Writable = require("93d042f8bb80078e");
require("aa7b11ba5bf4defc")(Duplex, Readable);
// Allow the keys array to be GC'ed.
var keys = objectKeys(Writable.prototype);
for(var v = 0; v < keys.length; v++){
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}
function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
        }
    }
}
Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
// the no-half-open enforcer
function onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return;
    // no more data can be written.
    // But allow more writes to happen in this tick.
    process.nextTick(onEndNT, this);
}
function onEndNT(self) {
    self.end();
}
Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined || this._writableState === undefined) return false;
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});

},{"2ab1115635c50a9f":"8NJDu","68a7582259cd5865":"7B9yT","93d042f8bb80078e":"5ruFN","aa7b11ba5bf4defc":"5bfIJ"}],"5ruFN":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
var global = arguments[3];
var process = require("f05a2a5a09d4d8b0");
"use strict";
module.exports = Writable;
/* <replacement> */ function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
}
// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var Duplex;
/*</replacement>*/ Writable.WritableState = WritableState;
/*<replacement>*/ var internalUtil = {
    deprecate: require("dc51171b07b54af1")
};
/*</replacement>*/ /*<replacement>*/ var Stream = require("44a3cc22ec64fcd3");
/*</replacement>*/ var Buffer = require("de8f7fb7ccda8086").Buffer;
var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = require("acf48fb5d9dc6204");
var _require = require("9d146cd974da0f53"), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require("3c574b8881abcf86").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require("10dad555ffe77dde")(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require("c5e7171d6f58d3c0");
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    // if _final has been called
    this.finalCalled = false;
    // drain event flag.
    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;
    // has it been destroyed
    this.destroyed = false;
    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;
    // a flag to see when we're in the middle of a write.
    this.writing = false;
    // when true all writes will be buffered until .uncork() call
    this.corked = 0;
    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;
    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;
    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        onwrite(stream, er);
    };
    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;
    // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;
    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;
    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;
    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;
    // Should .destroy() be called after 'finish' (and potentially 'end')
    this.autoDestroy = !!options.autoDestroy;
    // count buffered requests
    this.bufferedRequestCount = 0;
    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
                return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
    } catch (_) {}
})();
// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
        }
    });
} else realHasInstance = function realHasInstance(object) {
    return object instanceof this;
};
function Writable(options) {
    Duplex = Duplex || require("c5e7171d6f58d3c0");
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
}
// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    // TODO: defer error events consistently everywhere, not just the cb
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
}
// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) er = new ERR_STREAM_NULL_VALUES();
    else if (typeof chunk !== "string" && !state.objectMode) er = new ERR_INVALID_ARG_TYPE("chunk", [
        "string",
        "Buffer"
    ], chunk);
    if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
    }
    return true;
}
Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) chunk = _uint8ArrayToBuffer(chunk);
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
Writable.prototype.cork = function() {
    this._writableState.corked++;
};
Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!([
        "hex",
        "utf8",
        "utf-8",
        "ascii",
        "binary",
        "base64",
        "ucs2",
        "ucs-2",
        "utf16le",
        "utf-16le",
        "raw"
    ].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") chunk = Buffer.from(chunk, encoding);
    return chunk;
}
Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) last.next = state.lastBufferedRequest;
        else state.bufferedRequest = state.lastBufferedRequest;
        state.bufferedRequestCount += 1;
    } else doWrite(stream, state, false, len, chunk, encoding, cb);
    return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        process.nextTick(cb, er);
        // this can emit finish, and it will always happen
        // after error
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        // this can emit finish, but finish must
        // always follow error
        finishMaybe(stream, state);
    }
}
function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(stream, state);
        if (sync) process.nextTick(afterWrite, stream, state, finished, cb);
        else afterWrite(stream, state, finished, cb);
    }
}
function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
}
// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
}
// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while(entry){
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else state.corkedRequestsFree = new CorkedRequest(state);
        state.bufferedRequestCount = 0;
    } else {
        // Slow case, write chunks one-by-one
        while(entry){
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) break;
        }
        if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
    // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    // ignore unnecessary end() calls.
    if (!state.ending) endWritable(this, state, cb);
    return this;
};
Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
    stream._final(function(err) {
        state.pendingcb--;
        if (err) errorOrDestroy(stream, err);
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
    });
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
                // In case of duplex streams we need a way to detect
                // if the readable side is ready for autoDestroy as well
                var rState = stream._readableState;
                if (!rState || rState.autoDestroy && rState.endEmitted) stream.destroy();
            }
        }
    }
    return need;
}
function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while(entry){
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    }
    // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._writableState === undefined) return false;
        return this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) return;
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err, cb) {
    cb(err);
};

},{"f05a2a5a09d4d8b0":"8NJDu","dc51171b07b54af1":"gqVww","44a3cc22ec64fcd3":"BkEUw","de8f7fb7ccda8086":"9BBmc","acf48fb5d9dc6204":"8klsy","9d146cd974da0f53":"2I36I","3c574b8881abcf86":"37XqY","10dad555ffe77dde":"5bfIJ","c5e7171d6f58d3c0":"4EQB4"}],"gqVww":[function(require,module,exports) {
/**
 * Module exports.
 */ var global = arguments[3];
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */ function deprecate(fn, msg) {
    if (config("noDeprecation")) return fn;
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (config("throwDeprecation")) throw new Error(msg);
            else if (config("traceDeprecation")) console.trace(msg);
            else console.warn(msg);
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */ function config(name) {
    // accessing global.localStorage can trigger a DOMException in sandboxed iframes
    try {
        if (!global.localStorage) return false;
    } catch (_) {
        return false;
    }
    var val = global.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === "true";
}

},{}],"dk5HH":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
"use strict";
/*<replacement>*/ var Buffer = require("2a29807c689a070a").Buffer;
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch(encoding && encoding.toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while(true)switch(enc){
        case "utf8":
        case "utf-8":
            return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return "utf16le";
        case "latin1":
        case "binary":
            return "latin1";
        case "base64":
        case "ascii":
        case "hex":
            return enc;
        default:
            if (retried) return; // undefined
            enc = ("" + enc).toLowerCase();
            retried = true;
    }
}
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else i = 0;
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return "\uFFFD";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "\uFFFD";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return "\uFFFD";
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "\uFFFD";
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) this.lastChar[0] = buf[buf.length - 1];
    else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}

},{"2a29807c689a070a":"3OzSu"}],"3OzSu":[function(require,module,exports) {
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = require("7e0d6ecd698c3ca6");
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src)dst[key] = src[key];
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) module.exports = buffer;
else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") throw new TypeError("Argument must not be a number");
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === "string") buf.fill(fill, encoding);
        else buf.fill(fill);
    } else buf.fill(0);
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") throw new TypeError("Argument must be a number");
    return buffer.SlowBuffer(size);
};

},{"7e0d6ecd698c3ca6":"9BBmc"}],"4Tac1":[function(require,module,exports) {
var process = require("96b869862a96261a");
"use strict";
var _Object$setPrototypeO;
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
var finished = require("745a3cd8f6469ed5");
var kLastResolve = Symbol("lastResolve");
var kLastReject = Symbol("lastReject");
var kError = Symbol("error");
var kEnded = Symbol("ended");
var kLastPromise = Symbol("lastPromise");
var kHandlePromise = Symbol("handlePromise");
var kStream = Symbol("stream");
function createIterResult(value, done) {
    return {
        value: value,
        done: done
    };
}
function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
        var data = iter[kStream].read();
        // we defer if data is null
        // we can be expecting either 'end' or
        // 'error'
        if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
        }
    }
}
function onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
        lastPromise.then(function() {
            if (iter[kEnded]) {
                resolve(createIterResult(undefined, true));
                return;
            }
            iter[kHandlePromise](resolve, reject);
        }, reject);
    };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function() {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream () {
        return this[kStream];
    },
    next: function next() {
        var _this = this;
        // if we have detected an error in the meanwhile
        // reject straight away
        var error = this[kError];
        if (error !== null) return Promise.reject(error);
        if (this[kEnded]) return Promise.resolve(createIterResult(undefined, true));
        if (this[kStream].destroyed) // We need to defer via nextTick because if .destroy(err) is
        // called, the error will be emitted via nextTick, and
        // we cannot guarantee that there is no error lingering around
        // waiting to be emitted.
        return new Promise(function(resolve, reject) {
            process.nextTick(function() {
                if (_this[kError]) reject(_this[kError]);
                else resolve(createIterResult(undefined, true));
            });
        });
        // if we have multiple next() calls
        // we will wait for the previous Promise to finish
        // this logic is optimized to support for await loops,
        // where next() is only called once at a time
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) promise = new Promise(wrapForNext(lastPromise, this));
        else {
            // fast path needed to support multiple this.push()
            // without triggering the next() queue
            var data = this[kStream].read();
            if (data !== null) return Promise.resolve(createIterResult(data, false));
            promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
    }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to
    return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
            if (err) {
                reject(err);
                return;
            }
            resolve(createIterResult(undefined, true));
        });
    });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(data, false));
            } else {
                iterator[kLastResolve] = resolve;
                iterator[kLastReject] = reject;
            }
        },
        writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            // reject if we are waiting for data in the Promise
            // returned by next() and store the error
            if (reject !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                reject(err);
            }
            iterator[kError] = err;
            return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(undefined, true));
        }
        iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
};
module.exports = createReadableStreamAsyncIterator;

},{"96b869862a96261a":"8NJDu","745a3cd8f6469ed5":"5GCvx"}],"5GCvx":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
"use strict";
var ERR_STREAM_PREMATURE_CLOSE = require("d35458f585bdd360").codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        callback.apply(this, args);
    };
}
function noop() {}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
        if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
    };
    var onerror = function onerror(err) {
        callback.call(stream, err);
    };
    var onclose = function onclose() {
        var err;
        if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
    };
    var onrequest = function onrequest() {
        stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
        // legacy streams
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
}
module.exports = eos;

},{"d35458f585bdd360":"37XqY"}],"hyOuy":[function(require,module,exports) {
module.exports = function() {
    throw new Error("Readable.from is not available in the browser");
};

},{}],"4M8aw":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
"use strict";
module.exports = Transform;
var _require$codes = require("baab47252aa06434").codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require("db11ebf938e536ed");
require("82049677fa603d40")(Transform, Duplex);
function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
}
function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
    };
    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;
    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
    }
    // When the writable side finishes, then flush out anything remaining.
    this.on("prefinish", prefinish);
}
function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) this._flush(function(er, data) {
        done(_this, er, data);
    });
    else done(this, null, null);
}
Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
};
// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
};
// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
};
Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
    });
};
function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);
    // TODO(BridgeAR): Write a test for these two error cases
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
}

},{"baab47252aa06434":"37XqY","db11ebf938e536ed":"4EQB4","82049677fa603d40":"5bfIJ"}],"lp9kT":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
"use strict";
module.exports = PassThrough;
var Transform = require("7ab21291895ec3d2");
require("f24ec1883eef5e9b")(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};

},{"7ab21291895ec3d2":"4M8aw","f24ec1883eef5e9b":"5bfIJ"}],"gYjP2":[function(require,module,exports) {
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
"use strict";
var eos;
function once(callback) {
    var called = false;
    return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
    };
}
var _require$codes = require("6ba21bd580ac7d57").codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
    // Rethrow the error if it exists to avoid swallowing it
    if (err) throw err;
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
        closed = true;
    });
    if (eos === undefined) eos = require("dd7fd89dd81b8674");
    eos(stream, {
        readable: reading,
        writable: writing
    }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
    });
    var destroyed = false;
    return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        // request.destroy just do .end - .abort is what we want
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
}
function call(fn) {
    fn();
}
function pipe(from, to) {
    return from.pipe(to);
}
function popCallback(streams) {
    if (!streams.length) return noop;
    if (typeof streams[streams.length - 1] !== "function") return noop;
    return streams.pop();
}
function pipeline() {
    for(var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++)streams[_key] = arguments[_key];
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) throw new ERR_MISSING_ARGS("streams");
    var error;
    var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
        });
    });
    return streams.reduce(pipe);
}
module.exports = pipeline;

},{"6ba21bd580ac7d57":"37XqY","dd7fd89dd81b8674":"5GCvx"}],"1BUXo":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.HlsManifestParser = void 0;
var _StringUtils = require("9d4f4bd9858d5aa4");
var _YoLog = require("b415cfbc94ec8e7d");
var _Constant = require("90a734d748f984c3");
var _PlaylistPayload = require("6ba527f735974515");
var _HttpUtils = require("714032b8191ae869");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
var EXT3MU = "#EXTM3U";
var JSESSION_PATTERN = /;jsessionid=([^?]+)/;
var YO_JS_PATTERN = /yo\.js=([^?]+)/;
var PAYLOADFIRSTLEVEL = "FIRSTLEVELPLAYLIST";
var EXT_YOSPACE_ANALYTICS_URL = "#EXT-X-YOSPACE-ANALYTICS-URL";
var EXT_X_STREAM_INF = "#EXT-X-STREAM-INF";
var EXT_X_YOSPACE_PAUSE = "#EXT-X-YOSPACE-PAUSE";
var EXT_YOSPACE_MASTER_URL = "#EXT-X-YOSPACE-SDK-MASTER-URL";
var HlsManifestParser = exports.HlsManifestParser = /*#__PURE__*/ function() {
    function HlsManifestParser() {
        this.data = new Map();
        this.nextLineStreamInf = false;
    }
    var _proto = HlsManifestParser.prototype;
    _proto.buildPlaybackUrl = function buildPlaybackUrl() {
        var masterUrl = this.data.get(_Constant.Payload.LOCATION);
        if (masterUrl && !(0, _HttpUtils.getUrl)(masterUrl)) {
            _YoLog.YoLog.w("Master URL invalid in HSL manifest: " + masterUrl);
            this.data["delete"](_Constant.Payload.LOCATION);
        }
        var isYoJs = false;
        var location = this.data.get(_Constant.Payload.LOCATION);
        if (!location) location = this.data.get(PAYLOADFIRSTLEVEL);
        if (!location) {
            _YoLog.YoLog.e("No location or first level URL available");
            return false;
        }
        var loc = (0, _HttpUtils.getUrl)(location);
        var yojsMatch = location.match(YO_JS_PATTERN);
        var jsessMatch = location.match(JSESSION_PATTERN);
        if (loc) {
            // Parse the session id
            if (yojsMatch) {
                isYoJs = true;
                this.data.set(_Constant.Payload.IDENTIFIER, yojsMatch[1]);
            } else if (jsessMatch) this.data.set(_Constant.Payload.IDENTIFIER, jsessMatch[1]);
        }
        if (!loc || this.data.get(_Constant.Payload.IDENTIFIER) === undefined) {
            _YoLog.YoLog.e("Unable to build Location from components");
            return false;
        }
        var port = loc.port;
        this.data.set(_Constant.Payload.PORT, port === "" ? "" : port);
        this.data.set(_Constant.Payload.SCHEME, loc.protocol.substring(0, loc.protocol.length - 1));
        this.data.set(_Constant.Payload.HOSTNODE, loc.hostname);
        this.data.set(_Constant.Payload.QS, loc.search ? loc.search.replace("?", "") : "");
        this.updateLocationPath(loc, isYoJs);
        return true;
    };
    _proto.updateLocationPath = function updateLocationPath(loc, isYoJs) {
        if (!this.data.get(_Constant.Payload.LOCATION)) {
            // replace the final path fragment with the final path fragment of the master request URL
            var oldpath = loc.pathname;
            var path = oldpath.substring(0, oldpath.lastIndexOf("/")) + ".m3u8";
            var location = this.data.get(_Constant.Payload.SCHEME);
            location += "://";
            location += this.data.get(_Constant.Payload.HOSTNODE);
            location += this.data.get(_Constant.Payload.PORT) !== "" ? ":" + this.data.get(_Constant.Payload.PORT) : "";
            location += path;
            if (!isYoJs) location += ";jsessionid=" + this.data.get(_Constant.Payload.IDENTIFIER);
            if (!(0, _StringUtils.isNullOrEmpty)(this.data.get(_Constant.Payload.QS))) location += "?" + this.data.get(_Constant.Payload.QS);
            this.data.set(_Constant.Payload.LOCATION, location);
        }
    };
    HlsManifestParser.checkParameters = function checkParameters(hlsManifest) {
        if ((0, _StringUtils.isNullOrEmpty)(hlsManifest)) {
            _YoLog.YoLog.e("Yospace HLS manifest is empty");
            return false;
        }
        if (hlsManifest.indexOf("#EXT-X-STREAM-INF:") === -1) {
            _YoLog.YoLog.e("No stream info found in HLS manifest");
            return false;
        }
        return true;
    };
    HlsManifestParser.isHlsManifest = function isHlsManifest(content) {
        return content.length >= 7 && content.toUpperCase().indexOf(EXT3MU) !== -1;
    };
    _proto.parseManifestLines = function parseManifestLines(hlsManifest) {
        var hlsManifestLines = hlsManifest.split(/\r?\n/);
        for(var _iterator = _createForOfIteratorHelperLoose(hlsManifestLines), _step; !(_step = _iterator()).done;){
            var line = _step.value;
            if (line.length === 0) continue;
            if (line.startsWith("#")) this.processManifestDirective(line);
            else if (this.nextLineStreamInf && !this.data.has(PAYLOADFIRSTLEVEL)) this.data.set(PAYLOADFIRSTLEVEL, line);
        }
    };
    _proto.processManifestDirective = function processManifestDirective(line) {
        var colon = line.indexOf(":");
        if (colon === -1) return;
        var meta = line.substring(colon + 1);
        var key = line.substring(0, colon);
        if (key.includes(EXT_YOSPACE_ANALYTICS_URL)) this.data.set(_Constant.Payload.ANALYTICURL, meta.replace(/"/g, ""));
        else if (key.includes(EXT_X_STREAM_INF)) {
            if (!this.data.has(PAYLOADFIRSTLEVEL)) this.nextLineStreamInf = true;
        } else if (key.includes(EXT_X_YOSPACE_PAUSE)) this.data.set(_Constant.Payload.PAUSEURL, meta.replace(/"/g, ""));
        else if (key.includes(EXT_YOSPACE_MASTER_URL)) this.data.set(_Constant.Payload.LOCATION, meta.replace(/"/g, ""));
    };
    HlsManifestParser.parse = function parse(hlsManifest) {
        var parser = new HlsManifestParser();
        if (HlsManifestParser.checkParameters(hlsManifest)) {
            parser.parseManifestLines(hlsManifest);
            parser.buildPlaybackUrl();
            return new _PlaylistPayload.PlaylistPayload(parser.data, _Constant.Constant.INTERSEGMENT_TIMEOUT);
        }
        return null;
    };
    return HlsManifestParser;
}();

},{"9d4f4bd9858d5aa4":"7uXt7","b415cfbc94ec8e7d":"9KS65","90a734d748f984c3":"5j00o","6ba527f735974515":"1ynoa","714032b8191ae869":"2wJyf"}],"5HX1P":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.UrlPoller = void 0;
var _YoLog = require("878e1c7ab09d340e");
var _Constant = require("fa0a3722cea8a785");
var _HttpConnection = require("81ac4fbeba7b32f5");
var _Session = require("a5215d3d7bb69764");
function _regeneratorRuntime() {
    "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ 
    _regeneratorRuntime = function _regeneratorRuntime() {
        return e;
    };
    var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t, e, r) {
        t[e] = r.value;
    }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
    function define(t, e, r) {
        return Object.defineProperty(t, e, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }), t[e];
    }
    try {
        define({}, "");
    } catch (t) {
        define = function define(t, e, r) {
            return t[e] = r;
        };
    }
    function wrap(t, e, r, n) {
        var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []);
        return o(a, "_invoke", {
            value: makeInvokeMethod(t, r, c)
        }), a;
    }
    function tryCatch(t, e, r) {
        try {
            return {
                type: "normal",
                arg: t.call(e, r)
            };
        } catch (t) {
            return {
                type: "throw",
                arg: t
            };
        }
    }
    e.wrap = wrap;
    var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var p = {};
    define(p, a, function() {
        return this;
    });
    var d = Object.getPrototypeOf, v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t) {
        [
            "next",
            "throw",
            "return"
        ].forEach(function(e) {
            define(t, e, function(t) {
                return this._invoke(e, t);
            });
        });
    }
    function AsyncIterator(t, e) {
        function invoke(r, o, i, a) {
            var c = tryCatch(t[r], t, o);
            if ("throw" !== c.type) {
                var u = c.arg, h = u.value;
                return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function(t) {
                    invoke("next", t, i, a);
                }, function(t) {
                    invoke("throw", t, i, a);
                }) : e.resolve(h).then(function(t) {
                    u.value = t, i(u);
                }, function(t) {
                    return invoke("throw", t, i, a);
                });
            }
            a(c.arg);
        }
        var r;
        o(this, "_invoke", {
            value: function value(t, n) {
                function callInvokeWithMethodAndArg() {
                    return new e(function(e, r) {
                        invoke(t, n, e, r);
                    });
                }
                return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
            }
        });
    }
    function makeInvokeMethod(e, r, n) {
        var o = h;
        return function(i, a) {
            if (o === f) throw new Error("Generator is already running");
            if (o === s) {
                if ("throw" === i) throw a;
                return {
                    value: t,
                    done: !0
                };
            }
            for(n.method = i, n.arg = a;;){
                var c = n.delegate;
                if (c) {
                    var u = maybeInvokeDelegate(c, n);
                    if (u) {
                        if (u === y) continue;
                        return u;
                    }
                }
                if ("next" === n.method) n.sent = n._sent = n.arg;
                else if ("throw" === n.method) {
                    if (o === h) throw o = s, n.arg;
                    n.dispatchException(n.arg);
                } else "return" === n.method && n.abrupt("return", n.arg);
                o = f;
                var p = tryCatch(e, r, n);
                if ("normal" === p.type) {
                    if (o = n.done ? s : l, p.arg === y) continue;
                    return {
                        value: p.arg,
                        done: n.done
                    };
                }
                "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
            }
        };
    }
    function maybeInvokeDelegate(e, r) {
        var n = r.method, o = e.iterator[n];
        if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
        var i = tryCatch(o, e.iterator, r.arg);
        if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
        var a = i.arg;
        return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
    }
    function pushTryEntry(t) {
        var e = {
            tryLoc: t[0]
        };
        1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
    }
    function resetTryEntry(t) {
        var e = t.completion || {};
        e.type = "normal", delete e.arg, t.completion = e;
    }
    function Context(t) {
        this.tryEntries = [
            {
                tryLoc: "root"
            }
        ], t.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(e) {
        if (e || "" === e) {
            var r = e[a];
            if (r) return r.call(e);
            if ("function" == typeof e.next) return e;
            if (!isNaN(e.length)) {
                var o = -1, i = function next() {
                    for(; ++o < e.length;)if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
                    return next.value = t, next.done = !0, next;
                };
                return i.next = i;
            }
        }
        throw new TypeError(typeof e + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: !0
    }), o(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t) {
        var e = "function" == typeof t && t.constructor;
        return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
    }, e.mark = function(t) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
    }, e.awrap = function(t) {
        return {
            __await: t
        };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
        return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function(t, r, n, o, i) {
        void 0 === i && (i = Promise);
        var a = new AsyncIterator(wrap(t, r, n, o), i);
        return e.isGeneratorFunction(r) ? a : a.next().then(function(t) {
            return t.done ? t.value : a.next();
        });
    }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function() {
        return this;
    }), define(g, "toString", function() {
        return "[object Generator]";
    }), e.keys = function(t) {
        var e = Object(t), r = [];
        for(var n in e)r.push(n);
        return r.reverse(), function next() {
            for(; r.length;){
                var t = r.pop();
                if (t in e) return next.value = t, next.done = !1, next;
            }
            return next.done = !0, next;
        };
    }, e.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(e) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for(var r in this)"t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
        },
        stop: function stop() {
            this.done = !0;
            var t = this.tryEntries[0].completion;
            if ("throw" === t.type) throw t.arg;
            return this.rval;
        },
        dispatchException: function dispatchException(e) {
            if (this.done) throw e;
            var r = this;
            function handle(n, o) {
                return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
            }
            for(var o = this.tryEntries.length - 1; o >= 0; --o){
                var i = this.tryEntries[o], a = i.completion;
                if ("root" === i.tryLoc) return handle("end");
                if (i.tryLoc <= this.prev) {
                    var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc");
                    if (c && u) {
                        if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
                        if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
                    } else if (c) {
                        if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
                    } else {
                        if (!u) throw new Error("try statement without catch or finally");
                        if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
                    }
                }
            }
        },
        abrupt: function abrupt(t, e) {
            for(var r = this.tryEntries.length - 1; r >= 0; --r){
                var o = this.tryEntries[r];
                if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
                    var i = o;
                    break;
                }
            }
            i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
            var a = i ? i.completion : {};
            return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
        },
        complete: function complete(t, e) {
            if ("throw" === t.type) throw t.arg;
            return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
        },
        finish: function finish(t) {
            for(var e = this.tryEntries.length - 1; e >= 0; --e){
                var r = this.tryEntries[e];
                if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
            }
        },
        "catch": function _catch(t) {
            for(var e = this.tryEntries.length - 1; e >= 0; --e){
                var r = this.tryEntries[e];
                if (r.tryLoc === t) {
                    var n = r.completion;
                    if ("throw" === n.type) {
                        var o = n.arg;
                        resetTryEntry(r);
                    }
                    return o;
                }
            }
            throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(e, r, n) {
            return this.delegate = {
                iterator: values(e),
                resultName: r,
                nextLoc: n
            }, "next" === this.method && (this.arg = t), y;
        }
    }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) resolve(value);
    else Promise.resolve(value).then(_next, _throw);
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
var UrlPoller = exports.UrlPoller = /*#__PURE__*/ function() {
    function UrlPoller(url, timeout, handler, frequency) {
        this.url = url;
        this.timeout = timeout;
        this.handler = handler;
        this.frequency = frequency ? frequency : _Constant.Constant.DEFAULT_POLLING_DELAY;
        this.requestInProgress = false;
        this.intervalID = null;
        // Poll time to be used when determining whether to poll
        this.lastPollTime = 0;
        // Last poll time for metrics only (do not use this in calculations!)
        this.lastPollTimeMetric = 0;
        this.queryParams = new Map();
        this.queryParams.set("ysdk", _Session.Session.version());
    }
    var _proto = UrlPoller.prototype;
    _proto.handleRequest = /*#__PURE__*/ function() {
        var _handleRequest = _asyncToGenerator(/*#__PURE__*/ _regeneratorRuntime().mark(function _callee() {
            var opts, response, retry;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
                while(true)switch(_context.prev = _context.next){
                    case 0:
                        opts = {};
                        _context.next = 3;
                        return _HttpConnection.HttpConnection.get(this.url, opts, this.timeout, null, this.queryParams);
                    case 3:
                        response = _context.sent;
                        if (response.error) _YoLog.YoLog.w("Poll failed: " + response.error);
                        if (!response.ok) {
                            if (response.status === 400 || response.status === 410) {
                                this.stop();
                                if (response.status === 410) _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_POLLING, "Stream is resolved.  Stopping " + (this.handler ? "analytic" : "pause") + " poller");
                            } else _YoLog.YoLog.w("Unexpected poll response " + response.status + ", intervalID: " + this.frequency + " ms");
                        } else {
                            _YoLog.YoLog.trace("sdk poll");
                            retry = this.getRetryFromResponse(response);
                            if (retry !== this.frequency) {
                                _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_POLLING, "Poll interval changed to " + retry + " millis");
                                this.frequency = retry;
                                // Only restart poller if it was running
                                if (this.isRunning()) this._start(false);
                            }
                        }
                        return _context.abrupt("return", response);
                    case 7:
                    case "end":
                        return _context.stop();
                }
            }, _callee, this);
        }));
        function handleRequest() {
            return _handleRequest.apply(this, arguments);
        }
        return handleRequest;
    }();
    _proto.getRetryFromResponse = function getRetryFromResponse(response) {
        var retry = response.headers.get("Retry-After");
        retry = Number.parseFloat(retry) * 1000;
        if (!Number.isNaN(retry) && retry > 0) return retry;
        return this.frequency;
    };
    _proto.getFrequency = function getFrequency() {
        return this.frequency;
    };
    _proto.isRunning = function isRunning() {
        return this.intervalID !== null;
    };
    _proto.request = function request() {
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_POLLING, "Request poll");
        this._poll(true);
    };
    _proto._poll = /*#__PURE__*/ function() {
        var _poll2 = _asyncToGenerator(/*#__PURE__*/ _regeneratorRuntime().mark(function _callee2(request) {
            var pollTime, response;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                while(true)switch(_context2.prev = _context2.next){
                    case 0:
                        if (this.shouldPoll(request)) {
                            _context2.next = 2;
                            break;
                        }
                        return _context2.abrupt("return");
                    case 2:
                        this.requestInProgress = true;
                        pollTime = Date.now(); // Last poll time gets set if:
                        //   1. It's not a request poll
                        //   2. The request poll is the very first poll
                        if (this.lastPollTime === 0 || !request) this.lastPollTime = pollTime;
                        this.lastPollTimeMetric = pollTime;
                        _context2.next = 8;
                        return this.handleRequest();
                    case 8:
                        response = _context2.sent;
                        if (this.handler) this.handler(response, this.frequency);
                        this.requestInProgress = false;
                    case 11:
                    case "end":
                        return _context2.stop();
                }
            }, _callee2, this);
        }));
        function _poll(_x) {
            return _poll2.apply(this, arguments);
        }
        return _poll;
    }();
    _proto.shouldPoll = function shouldPoll(request) {
        if (this.requestInProgress) {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_POLLING, "Last poll still in flight. Ignoring.");
            return false;
        }
        if (request) return true;
        // If last poll time is less than half the frequency, don't poll
        var delta = Date.now() - this.lastPollTime;
        if (delta < this.frequency / 2) {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_POLLING, "Last poll too recent (" + delta / 1000 + "s). Ignoring.");
            return false;
        }
        return true;
    };
    _proto.start = function start() {
        this._start(true);
    };
    _proto._start = function _start(immediate) {
        var _this = this;
        this.stop();
        var initialDelay = UrlPoller.computeTimeToNextInterval(Date.now(), this.lastPollTime, this.frequency);
        // Save timeout to intervalID so poller is 'running' and a request can occur
        this.intervalID = setTimeout(function() {
            _this.intervalID = setInterval(function() {
                _this._poll();
            }, _this.frequency);
            _this._poll();
        }, immediate ? 0 : initialDelay);
    };
    UrlPoller.computeTimeToNextInterval = function computeTimeToNextInterval(after, previous, interval) {
        var intervalsBetweenPreviousAndAfter = Math.floor(Math.abs(after - previous) / interval);
        var nextInterval = previous + interval * (intervalsBetweenPreviousAndAfter + 1);
        return nextInterval - after;
    };
    _proto.stop = function stop() {
        clearInterval(this.intervalID);
        this.intervalID = null;
    };
    _proto.shutdown = function shutdown() {
        this.stop();
        this.handler = function() {};
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "Poller shutdown");
    };
    return UrlPoller;
}();

},{"878e1c7ab09d340e":"9KS65","fa0a3722cea8a785":"5j00o","81ac4fbeba7b32f5":"6cS9V","a5215d3d7bb69764":"62muZ"}],"iG6Z6":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.StreamData = exports.Parser = exports.CreativeData = exports.AdvertData = void 0;
var _sax = _interopRequireDefault(require("cb4f274328b2ae21"));
var _YoLog = require("4021d38c63d53816");
var _ConversionUtils = require("3d6509fd3aaf9359");
var _AdBreak = require("5605146537da25fd");
var _Advert = require("e2ca759a9177088f");
var _AdvertWrapper = require("ac7551da0c61864d");
var _CompanionCreative = require("89c6b6bd7763c0ce");
var _IconClickFallbackImage = require("ae1fe73454e59e4c");
var _IndustryIcon = require("a84269bfbd2ec121");
var _InteractiveCreative = require("596e5dbd885edb06");
var _LinearCreative = require("141ab5a6ca47ef57");
var _NonLinearAds = require("d5ade2f1951706de");
var _NonLinearCreative = require("c7e6705edfc30985");
var _Resource = require("c3ecc0ea5c24eae2");
var _VASTProperty = require("416eae9639203cfa");
var _VideoClicks = require("c9cfeb3bc1bf4fcf");
var _XmlNode = require("44e2ed583f6f6f23");
var _TrackingReport = require("6bf31caae1bb272f");
var _AdVerification = require("6609b134918cc3ad");
var _CompanionAds = require("a40eb0c45af08efe");
var _StringUtils = require("d6c640720d67b29c");
var _HttpUtils = require("65bce526262aa884");
var _AnalyticPayload = require("973c55c4bac3dd1e");
var _CollectionUtils = require("a2cad4d5e24baa17");
var _ParsingError = require("a352eee08ade0455");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
var CreativeType = {
    NONE: 0,
    COMPANION: 1,
    LINEAR: 2,
    NONLINEAR: 3
};
var AD_TITLE_TOKEN = "AdTitle";
var AD_TOKEN = "Ad";
var AD_SERVING_ID_TOKEN = "AdServingId";
var ALT_TEXT_TOKEN = "AltText";
var CLICK_THROUGH_TOKEN = "ClickThrough";
var CLICK_TRACKING_TOKEN = "ClickTracking";
var COMPANION_CLICK_THROUGH_TOKEN = "CompanionClickThrough";
var COMPANION_CLICK_TRACKING_TOKEN = "CompanionClickTracking";
var CUSTOM_CLICK = "CustomClick";
var DESCRIPTION_TOKEN = "Description";
var DURATION_TOKEN = "Duration";
var ERROR_TOKEN = "Error";
var ICON_CLICK_THROUGH_TOKEN = "IconClickThrough";
var ICON_CLICK_TRACKING_TOKEN = "IconClickTracking";
var ICON_VIEW_TRACKING_TOKEN = "IconViewTracking";
var IFRAME_RESOURCE_TOKEN = "IFrameResource";
var NON_LINEAR_CLICK_THROUGH_TOKEN = "NonLinearClickThrough";
var NON_LINEAR_CLICK_TRACKING_TOKEN = "NonLinearClickTracking";
var NOT_VIEWABLE_TOKEN = "NotViewable";
var VERIFICATION_PARAMETERS_TOKEN = "VerificationParameters";
var VIEWABLE_TOKEN = "Viewable";
var VIEW_UNDETERMINED_TOKEN = "ViewUndetermined";
var VMAP_ADBREAK_TOKEN = "vmap:AdBreak";
var VMAP_TOKEN = "vmap:VMAP";
var YOSPACE_ADBREAK_TOKEN = "yospace:AdBreak";
var YOSPACE_STREAM_TOKEN = "yospace:Stream";
var VMAP_TRACKING_TOKEN = "vmap:Tracking";
var VAST_TOKEN = "VAST";
var AD_WRAPPER_TOKEN = "AdWrapper";
var CATEGORY_TOKEN = "Category";
var AD_SYSTEM_TOKEN = "AdSystem";
var ADVERTISER_TOKEN = "Advertiser";
var SURVEY_TOKEN = "Survey";
var PRICING_TOKEN = "Pricing";
var UNIVERSAL_AD_ID_TOKEN = "UniversalAdId";
var EXTENSIONS_TOKEN = "Extensions";
var CREATIVE_TOKEN = "Creative";
var LINEAR_TOKEN = "Linear";
var ICON_TOKEN = "Icon";
var ICON_CLICK_FALLBACK_IMAGE_TOKEN = "IconClickFallbackImage";
var IMPRESSION_TOKEN = "Impression";
var AD_PARAMETERS_TOKEN = "AdParameters";
var MEDIAFILE_TOKEN = "MediaFile";
var INTERACTIVE_CREATIVE_FILE_TOKEN = "InteractiveCreativeFile";
var NON_LINEAR_ADS_TOKEN = "NonLinearAds";
var NON_LINEAR_TOKEN = "NonLinear";
var COMPANION_ADS_TOKEN = "CompanionAds";
var COMPANION_TOKEN = "Companion";
var STATIC_RESOURCE_TOKEN = "StaticResource";
var HTML_RESOURCE_TOKEN = "HTMLResource";
var TRACKING_TOKEN = "Tracking";
var VERIFICATION_TOKEN = "Verification";
var JAVASCRIPT_RESOURCE_TOKEN = "JavaScriptResource";
var EXECUTABLE_RESOURCE_TOKEN = "ExecutableResource";
var EXTENSION_TOKEN = "Extension";
var CREATIVE_EXTENSIONS_TOKEN = "CreativeExtensions";
var CREATIVE_EXTENSION_TOKEN = "CreativeExtension";
var VMAP_ADTAG_URI = "vmap:AdTagURI";
var MIN_VAST_VERSION = 4.2;
var YOPSI_PATTERN = "yo.p.si=([^&]+)";
function logParsingSummary(parser) {
    if (_YoLog.YoLog.debugflags & _YoLog.DebugFlags.DEBUG_PARSING) {
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, "\n--------------- VMAP PARSING SUMMARY ---------------");
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, " * Number of ad breaks: " + parser.linearAdBreaks.length);
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, " * Number of nonlinear ad breaks: " + parser.nonLinearAdBreaks.length);
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, " * Number of display ad breaks: " + parser.displayAdBreaks.length);
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, " * Stream duration: " + parser.streamData.duration + "ms\n");
        for(var _iterator = _createForOfIteratorHelperLoose(parser.linearAdBreaks), _step; !(_step = _iterator()).done;){
            var ab = _step.value;
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, ab.toString());
            for(var _iterator4 = _createForOfIteratorHelperLoose(ab.getAdverts()), _step4; !(_step4 = _iterator4()).done;){
                var ad = _step4.value;
                _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, ad.toString());
            }
        }
        for(var _iterator2 = _createForOfIteratorHelperLoose(parser.nonLinearAdBreaks), _step2; !(_step2 = _iterator2()).done;){
            var nab = _step2.value;
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, nab.toString());
            for(var _iterator5 = _createForOfIteratorHelperLoose(nab.getAdverts()), _step5; !(_step5 = _iterator5()).done;){
                var _ad = _step5.value;
                _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, _ad.toString());
            }
        }
        for(var _iterator3 = _createForOfIteratorHelperLoose(parser.displayAdBreaks), _step3; !(_step3 = _iterator3()).done;){
            var dab = _step3.value;
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, dab.toString());
            for(var _iterator6 = _createForOfIteratorHelperLoose(dab.getAdverts()), _step6; !(_step6 = _iterator6()).done;){
                var _ad2 = _step6.value;
                _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, _ad2.toString());
            }
        }
        if (parser.streamData.getEarlyReturn()) _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, "Early return: " + parser.streamData.getEarlyReturn());
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, "--------------- END PARSING SUMMARY ----------------\n");
    }
}
var AdBreakData = /*#__PURE__*/ function() {
    function AdBreakData() {
        this.clear();
    }
    var _proto = AdBreakData.prototype;
    _proto.clear = function clear() {
        this.adverts = [];
        this.timelineTrackingMap = new Map();
        this.trackingEvent = null;
        this.start = 0;
        this.duration = 0;
        this.position = null;
        this.breakType = null;
        this.identifier = null;
        this.earlyReturn = null; // null = not set, -1 error, >= 0 value as successfully parsed
        this.adTagUri = null;
        this.timeOffset = null;
        this.vastVersion = null;
    };
    return AdBreakData;
}();
var AdvertData = exports.AdvertData = /*#__PURE__*/ function() {
    function AdvertData() {
        this.clear();
    }
    var _proto2 = AdvertData.prototype;
    _proto2.clear = function clear() {
        this.id = null;
        this.sequence = null;
        this.adType = null;
        this.properties = [];
        this.linearCreative = null;
        this.companionAds = null;
        this.impressions = null;
        this.errors = null;
        this.viewableImpressions = new Map();
        this.adVerifications = [];
        this.filler = false;
        this.nonLinear = false;
        this.topLevelWrapper = null;
        this.extensions = null;
        this.processingCompanionCreative = false;
        this.currentCreativeType = CreativeType.NONE;
        this.nonLinearAds = null;
        this.adSystemVersion = null;
        this.advertiserId = null;
        this.categoryAuthority = null;
        this.pricingModel = null;
        this.pricingCurrency = null;
        this.surveyType = null;
        this.verificationVendor = null;
        this.verificationEvents = new Map();
        this.verificationResources = [];
        this.verificationApiFramework = null;
        this.verificationBrowserOptional = null;
        this.verificationParameters = null;
        this.verificationResourceType = null;
        this.extensionStack = [];
        this.identifier = "";
        this.mediaIdentifier = "";
    };
    _proto2.parseId = function parseId(id) {
        this.id = id;
        this.identifier = "";
        this.mediaIdentifier = "";
        if (id) {
            var components = id.split("_YO_");
            if (components.length === 2) {
                this.identifier = components[0];
                this.mediaIdentifier = components[1];
            }
        }
    };
    return AdvertData;
}();
var CompanionAdsData = /*#__PURE__*/ function() {
    function CompanionAdsData() {
        this.clear();
    }
    var _proto3 = CompanionAdsData.prototype;
    _proto3.clear = function clear() {
        this.required = null;
        this.companions = [];
    };
    return CompanionAdsData;
}();
var CreativeData = exports.CreativeData = /*#__PURE__*/ function() {
    function CreativeData() {
        this.clearAll();
    }
    var _proto4 = CreativeData.prototype;
    _proto4.clear = function clear() {
        this.clickThroughUrl = "";
        this.clickThroughTrackings = [];
        this.clickThroughCustoms = [];
        this.nonLinearResources = [];
        this.duration = null;
        this.trackingMap = new Map();
        this.interactiveTracking = null;
        this.icons = [];
        this.currentAssetUri = null;
        this.skipOffset = null;
        this.adParameters = null;
        this.staticResourceCreativeType = null;
        this.trackingEvent = null;
        this.htmlResourceEncoded = false;
        this.altText = null;
        this.companionExtensionStack = [];
        this.companionExtensions = null;
        this.icSource = null;
        this.properties = [];
    };
    _proto4.clearAll = function clearAll() {
        // Top level
        this.advertId = null;
        this.id = null;
        this.sequence = null;
        this.universalAdIds = [];
        this.universalAdIdRegistry = null;
        this.extensions = null;
        this.extensionStack = [];
        // Per element
        this.clickThroughTrackings = [];
        this.clickThroughUrl = "";
        this.adParameters = null;
        this.trackingEvent = null;
        // Linear data
        this.duration = null;
        this.trackingMap = new Map();
        this.interactiveTracking = null;
        this.icons = [];
        this.currentAssetUri = null;
        this.skipOffset = null;
        this.clickThroughCustoms = [];
        // Non-linear data
        this.nonLinearResources = [];
        this.staticResourceCreativeType = null;
        this.htmlResourceEncoded = null;
        // Companion data
        this.altText = null;
        this.companionExtensions = null;
        this.companionExtensionStack = [];
        // Interactive creative
        this.properties = [];
        this.icSource = null;
    };
    return CreativeData;
}();
var IconData = /*#__PURE__*/ function() {
    function IconData() {
        this.clear();
    }
    var _proto5 = IconData.prototype;
    _proto5.clear = function clear() {
        this.resources = [];
        this.properties = [];
        this.clickThroughUrl = null;
        this.staticResourceCreativeType = null;
        this.clickTrackings = [];
        this.clickFallbackImages = [];
        this.viewTrackings = [];
        this.htmlResourceEncoded = false;
    };
    return IconData;
}();
var IconClickFallbackImageData = /*#__PURE__*/ function() {
    function IconClickFallbackImageData() {
        this.clear();
    }
    var _proto6 = IconClickFallbackImageData.prototype;
    _proto6.clear = function clear() {
        this.properties = [];
        this.resource = null;
        this.staticResourceCreativeType = null;
        this.altText = null;
    };
    return IconClickFallbackImageData;
}();
var NonLinearAdsData = /*#__PURE__*/ function() {
    function NonLinearAdsData() {
        this.clear();
    }
    var _proto7 = NonLinearAdsData.prototype;
    _proto7.clear = function clear() {
        this.nonLinearCreatives = [];
        this.trackingMap = new Map();
    };
    return NonLinearAdsData;
}();
var StreamData = exports.StreamData = /*#__PURE__*/ function() {
    function StreamData() {
        this.sessionIdentifier = null;
        this.duration = 0;
        this.hostNode = null;
        this.hostSuffix = null;
        this.pdtInitial = null;
        this.pdtStart = null;
        this.pdtEnd = null;
        this.earlyReturn = null;
        this.hasPlaceholder = false;
    }
    var _proto8 = StreamData.prototype;
    _proto8.getSessionIdentifier = function getSessionIdentifier() {
        return this.sessionIdentifier;
    };
    _proto8.getDuration = function getDuration() {
        return this.duration;
    };
    _proto8.getHasPlaceholder = function getHasPlaceholder() {
        return this.hasPlaceholder;
    };
    _proto8.getHostNode = function getHostNode() {
        return this.hostNode;
    };
    _proto8.getHostSuffix = function getHostSuffix() {
        return this.hostSuffix;
    };
    _proto8.getPdtInitial = function getPdtInitial() {
        return this.pdtInitial;
    };
    _proto8.getPdtStart = function getPdtStart() {
        return this.pdtStart;
    };
    _proto8.getPdtEnd = function getPdtEnd() {
        return this.pdtEnd;
    };
    _proto8.getEarlyReturn = function getEarlyReturn() {
        return this.earlyReturn;
    };
    return StreamData;
}();
var Parser = exports.Parser = /*#__PURE__*/ function() {
    function Parser(broker) {
        this.broker = broker;
        this.skipNormalisation = false;
        // vars
        this.linearAdBreaks = [];
        this.nonLinearAdBreaks = [];
        this.displayAdBreaks = [];
        this.isVmap = false;
        this.isValidVAST = true;
        this.processingAdvertExtensions = false;
        this.processingCreativeExtensions = false;
        this.characters = "";
        // Objects
        this.adBreakData = new AdBreakData();
        this.advertData = new AdvertData();
        this.companionAdsData = new CompanionAdsData();
        this.creativeData = new CreativeData();
        this.iconClickFallbackImageData = new IconClickFallbackImageData();
        this.iconData = new IconData();
        this.iconFallbackImageData = new IconClickFallbackImageData();
        this.nonLinearAdsData = new NonLinearAdsData();
        this.streamData = new StreamData();
        // callbacks
        this.onCdata = this.onCdata.bind(this);
        this.onOpenTag = this.onOpenTag.bind(this);
        this.onCloseTag = this.onCloseTag.bind(this);
        this.onText = this.onText.bind(this);
    }
    var _proto9 = Parser.prototype;
    _proto9.addToCreativeExtensionStack = function addToCreativeExtensionStack(node) {
        if (this.advertData.processingCompanionCreative) this.creativeData.companionExtensionStack.push(node);
        else this.creativeData.extensionStack.push(node);
    };
    _proto9.checkAdBreakForParsingErrors = function checkAdBreakForParsingErrors(ab) {
        if (ab.getType() === _AdBreak.BreakType.LINEAR) {
            if (ab.getStart() === -1) {
                var parsingError = new _ParsingError.ParsingError(this.adBreakData.identifier, _ParsingError.ParsingError.Message.INVALID_START_TIME, _ParsingError.ParsingError.Message.INVALID_START_TIME + ": " + this.adBreakData.timeOffset);
                this.broker.addParsingError(parsingError);
            }
            if (ab.getAdverts().length === 0 && ab.getTrackingMap().size === 0) {
                var _parsingError = new _ParsingError.ParsingError(this.adBreakData.identifier, _ParsingError.ParsingError.Message.EMPTY_ADVERT_AND_TRACKING, "Empty ad break at offset: " + this.adBreakData.timeOffset);
                this.broker.addParsingError(_parsingError);
            }
        }
    };
    _proto9.checkValidVersion = function checkValidVersion(versionStr) {
        var version = parseFloat(versionStr);
        return !Number.isNaN(version) && version >= MIN_VAST_VERSION;
    };
    _proto9.getStreamData = function getStreamData() {
        return this.streamData;
    };
    _proto9.handleCreativeExtensionsForOnEndDefault = function handleCreativeExtensionsForOnEndDefault(name) {
        var stack = this.advertData.processingCompanionCreative ? this.creativeData.companionExtensionStack : this.creativeData.extensionStack;
        var size = stack.length;
        if (size === 2) {
            this.pop(false, true);
            this.processingCreativeExtensions = false;
        } else if (size > 0) {
            var node = stack[size - 1];
            if (name === node.getName()) this.pop(false, true);
        }
    };
    _proto9.handleStartAd = function handleStartAd(attributes) {
        this.advertData.parseId(attributes.id);
        var sequence = parseInt(attributes.sequence);
        this.advertData.sequence = !Number.isNaN(sequence) ? sequence : 0;
        if (!Number.isNaN(sequence)) this.advertData.sequence = sequence;
        this.advertData.adType = attributes.adType;
        if (_AdBreak.AdBreak.getBreakTypeFromString(this.adBreakData.breakType) !== _AdBreak.BreakType.LINEAR) this.advertData.nonLinear = true;
    };
    _proto9.handleStartAdWrapper = function handleStartAdWrapper(attributes) {
        var wrapperId = attributes.id ? attributes.id : "";
        var wrapperCreativeId = attributes.creativeId ? attributes.creativeId : "";
        var wrapperAdSystem = attributes.AdSystem ? attributes.AdSystem : "";
        var advertWrapper = new _AdvertWrapper.AdvertWrapper(wrapperId, wrapperCreativeId, wrapperAdSystem);
        if (this.advertData.topLevelWrapper) advertWrapper.setChild(this.advertData.topLevelWrapper);
        this.advertData.topLevelWrapper = advertWrapper;
    };
    _proto9.handleStartCreative = function handleStartCreative(attributes) {
        this.creativeData.advertId = attributes.adId;
        this.creativeData.id = attributes.id;
        var seq = parseInt(attributes.sequence);
        this.creativeData.sequence = isNaN(seq) ? 0 : seq;
    };
    _proto9.handleStartCreativeExtension = function handleStartCreativeExtension(attributes, tag) {
        var type = attributes.type;
        type = type ? type : "";
        if (type.indexOf("com.yospace") === -1 && type.indexOf("AdVerifications") === -1) {
            this.processingCreativeExtensions = true;
            this.addToCreativeExtensionStack(new _XmlNode.XmlNode(tag.name, (0, _CollectionUtils.objectToMap)(attributes)));
        }
    };
    _proto9.handleStartExtension = function handleStartExtension(attributes, tag) {
        var type = attributes.type;
        type = type ? type : "";
        if (type.indexOf("com.yospace") === -1 && type.indexOf("AdVerifications") === -1) {
            this.processingAdvertExtensions = true;
            this.advertData.extensionStack.push(new _XmlNode.XmlNode(tag.name, (0, _CollectionUtils.objectToMap)(attributes)));
        }
    };
    _proto9.handleStartExtensionElement = function handleStartExtensionElement(attributes, tag) {
        if (this.processingAdvertExtensions) this.advertData.extensionStack.push(new _XmlNode.XmlNode(tag.name, (0, _CollectionUtils.objectToMap)(attributes)));
        else if (this.processingCreativeExtensions) this.addToCreativeExtensionStack(new _XmlNode.XmlNode(tag.name, (0, _CollectionUtils.objectToMap)(attributes)));
    };
    _proto9.handleStartHtmlResource = function handleStartHtmlResource(attributes) {
        var boolString = attributes.xmlEncoded;
        var encoded = boolString ? boolString.toUpperCase() === "TRUE" || boolString === "1" : false;
        if (this.iconData.properties.length > 0) this.iconData.htmlResourceEncoded = encoded;
        else this.creativeData.htmlResourceEncoded = encoded;
    };
    _proto9.handleStartPricing = function handleStartPricing(attributes) {
        var model = attributes.model;
        if (model) this.advertData.pricingModel = model.toUpperCase();
        else this.advertData.pricingModel = "";
        this.advertData.pricingCurrency = attributes.currency;
    };
    _proto9.handleStartStaticResource = function handleStartStaticResource(attributes) {
        if (this.iconClickFallbackImageData.properties.length > 0) this.iconClickFallbackImageData.staticResourceCreativeType = attributes.creativeType;
        else if (this.iconData.properties.length > 0) this.iconData.staticResourceCreativeType = attributes.creativeType;
        else this.creativeData.staticResourceCreativeType = attributes.creativeType;
    };
    _proto9.handleStartTracking = function handleStartTracking(attributes) {
        this.creativeData.trackingEvent = attributes.event;
        if (this.creativeData.trackingEvent === "progress") {
            var offset = attributes.offset;
            if (!(0, _StringUtils.isNullOrEmpty)(offset)) this.creativeData.trackingEvent = this.creativeData.trackingEvent + "-" + offset;
        }
    };
    _proto9.handleEndAd = function handleEndAd() {
        var advert = new _Advert.Advert(this.advertData);
        if (advert.isValid()) this.adBreakData.adverts.push(advert);
        else if (!this.advertData.nonLinear && !this.advertData.linearCreative) {
            var parsingError = new _ParsingError.ParsingError(null, _ParsingError.ParsingError.Message.MISSING_CREATIVE, "No creative for advert: " + this.advertData.id);
            this.broker.addParsingError(parsingError);
        } else if ((0, _StringUtils.isNullOrEmpty)(advert.mediaIdentifier)) {
            var _parsingError2 = new _ParsingError.ParsingError(null, _ParsingError.ParsingError.Message.INVALID_MEDIAID, "Yospace media identifier could not be parsed (advert id: " + this.advertData.id + ")");
            this.broker.addParsingError(_parsingError2);
        }
        if (!advert.isValid()) _YoLog.YoLog.w("Invalid advert.  Discarding (" + this.advertData.id + ")");
        this.advertData.clear();
    };
    _proto9.handleAdvertExtensionsForOnEndDefault = function handleAdvertExtensionsForOnEndDefault(name) {
        var size = this.advertData.extensionStack.length;
        if (size === 2) {
            this.pop(true, true);
            this.processingAdvertExtensions = false;
        } else if (size > 0) {
            var node = this.advertData.extensionStack[size - 1];
            if (name === node.getName()) this.pop(true, true);
        }
    };
    _proto9.handleEndAdTitle = function handleEndAdTitle() {
        var title = this.characters.trim();
        this.advertData.properties.push(new _VASTProperty.VASTProperty("AdTitle", title));
        if (title === "filler") this.advertData.filler = true;
    };
    _proto9.handleEndClickTracking = function handleEndClickTracking() {
        var characters = this.characters.trim();
        if ((0, _HttpUtils.getUrl)(characters)) this.creativeData.clickThroughTrackings.push(characters);
        else _YoLog.YoLog.w("Discarding click tracking URL:" + characters);
    };
    _proto9.handleEndCompanion = function handleEndCompanion() {
        var videoClicks = null;
        if (!(0, _StringUtils.isNullOrEmpty)(this.creativeData.clickThroughUrl)) videoClicks = new _VideoClicks.VideoClicks(this.creativeData.clickThroughUrl, this.creativeData.clickThroughTrackings, null);
        var companion = new _CompanionCreative.CompanionCreative(this.creativeData, videoClicks, this.creativeData.nonLinearResources, this.creativeData.trackingMap, this.broker);
        if (companion.isValid()) {
            companion.setNonLinear(this.advertData.nonLinear);
            this.companionAdsData.companions.push(companion);
        } else _YoLog.YoLog.w("Discarding invalid Companion");
        this.creativeData.clear();
    };
    _proto9.handleEndCompanionClickTracking = function handleEndCompanionClickTracking() {
        var characters = this.characters.trim();
        if ((0, _HttpUtils.getUrl)(characters)) this.creativeData.clickThroughTrackings.push(characters);
        else _YoLog.YoLog.w("Discarding empty Companion click tracking URL");
    };
    _proto9.handleEndCreative = function handleEndCreative() {
        switch(this.advertData.currentCreativeType){
            case CreativeType.COMPANION:
                for(var _iterator7 = _createForOfIteratorHelperLoose(this.advertData.companionAds.companions), _step7; !(_step7 = _iterator7()).done;){
                    var c = _step7.value;
                    c.postParse(this.creativeData.extensions);
                }
                break;
            case CreativeType.LINEAR:
                if (this.advertData.linearCreative) this.advertData.linearCreative.postParse(this.creativeData.extensions);
                break;
            case CreativeType.NONLINEAR:
                for(var _iterator8 = _createForOfIteratorHelperLoose(this.advertData.nonLinearAds.nonLinearCreatives), _step8; !(_step8 = _iterator8()).done;){
                    var _c = _step8.value;
                    _c.postParse(this.creativeData.extensions);
                }
                break;
        }
        this.creativeData.clearAll();
    };
    _proto9.handleEndCustomClick = function handleEndCustomClick() {
        var characters = this.characters.trim();
        if (characters !== "") this.creativeData.clickThroughCustoms.push(characters);
        else _YoLog.YoLog.w("Discarding empty custom click URL");
    };
    _proto9.handleEndError = function handleEndError(name) {
        var characters = this.characters.trim();
        if ((0, _HttpUtils.getUrl)(characters)) {
            if (!this.advertData.errors) this.advertData.errors = new _TrackingReport.TrackingReport(name, [
                characters
            ], this.adBreakData.identifier, this.advertData.mediaIdentifier);
            else this.advertData.errors.addTrackingUrl(characters);
        } else _YoLog.YoLog.w("Discarding empty Error");
    };
    _proto9.handleEndExecutableResource = function handleEndExecutableResource() {
        if (this.advertData.verificationApiFramework && this.advertData.verificationResourceType) {
            var prop = new _VASTProperty.VASTProperty("ExecutableResource", this.characters.trim(), "apiFramework", this.advertData.verificationApiFramework);
            prop.addAttribute("type", this.advertData.verificationResourceType);
            this.advertData.verificationResources.push(prop);
        }
        this.advertData.verificationApiFramework = null;
        this.advertData.verificationResourceType = null;
    };
    _proto9.handleEndIcon = function handleEndIcon() {
        var videoClicks = null;
        if (!(0, _StringUtils.isNullOrEmpty)(this.iconData.clickThroughUrl) || this.iconData.viewTrackings.length > 0) {
            if ((0, _StringUtils.isNullOrEmpty)(this.iconData.clickThroughUrl)) videoClicks = new _VideoClicks.VideoClicks(null, null, this.iconData.viewTrackings);
            else videoClicks = new _VideoClicks.VideoClicks(this.iconData.clickThroughUrl, this.iconData.clickTrackings, this.iconData.viewTrackings);
        }
        var icon = new _IndustryIcon.IndustryIcon(this.iconData.properties, this.iconData.resources, videoClicks, this.iconData.clickFallbackImages, this.broker);
        if (icon.isValid()) this.creativeData.icons.push(icon);
        else _YoLog.YoLog.w("Discarding invalid Icon");
        this.iconData.clear();
    };
    _proto9.handleEndIFrameResource = function handleEndIFrameResource() {
        var characters = this.characters.trim();
        if (this.iconData.properties.length > 0) this.iconData.resources.push(new _Resource.Resource(_Resource.ResourceType.IFRAME, characters));
        else this.creativeData.nonLinearResources.push(new _Resource.Resource(_Resource.ResourceType.IFRAME, characters));
    };
    _proto9.handleEndExtensionElement = function handleEndExtensionElement(name) {
        if (this.processingAdvertExtensions) this.handleAdvertExtensionsForOnEndDefault(name);
        else this.handleCreativeExtensionsForOnEndDefault(name);
    };
    _proto9.handleEndHtmlResource = function handleEndHtmlResource() {
        if (this.iconData.properties.length > 0) {
            var characters = this.characters.trim();
            this.iconData.resources.push(new _Resource.Resource(_Resource.ResourceType.HTML, characters, null, this.iconData.htmlResourceEncoded));
        } else this.creativeData.nonLinearResources.push(new _Resource.Resource(_Resource.ResourceType.HTML, this.characters, null, this.creativeData.htmlResourceEncoded));
    };
    _proto9.handleEndIconClickFallbackImage = function handleEndIconClickFallbackImage() {
        var iconClickFallbackImage = new _IconClickFallbackImage.IconClickFallbackImage(this.iconClickFallbackImageData.properties, this.iconClickFallbackImageData.altText, this.iconClickFallbackImageData.resource);
        if (iconClickFallbackImage.isValid()) this.iconData.clickFallbackImages.push(iconClickFallbackImage);
        else _YoLog.YoLog.w("Discarding invalid IconClickFallbackImage");
        this.iconClickFallbackImageData.clear();
    };
    _proto9.handleEndIconClickTracking = function handleEndIconClickTracking() {
        var characters = this.characters.trim();
        if ((0, _HttpUtils.getUrl)(characters)) this.iconData.clickTrackings.push(characters);
        else _YoLog.YoLog.w("Discarding empty Icon click tracking URL");
    };
    _proto9.handleEndIconViewTracking = function handleEndIconViewTracking() {
        var characters = this.characters.trim();
        if ((0, _HttpUtils.getUrl)(characters)) this.iconData.viewTrackings.push(characters);
        else _YoLog.YoLog.w("Discarding empty Icon view tracking URL");
    };
    _proto9.handleEndInteractiveTracking = function handleEndInteractiveTracking() {
        if (!this.creativeData.interactiveTracking) this.creativeData.interactiveTracking = new _TrackingReport.TrackingReport(this.creativeData.trackingEvent, [
            this.characters.trim()
        ], this.adBreakData.identifier, this.advertData.mediaIdentifier);
        else this.creativeData.interactiveTracking.addTrackingUrl(this.characters.trim());
    };
    _proto9.handleEndLinear = function handleEndLinear() {
        var videoClicks = null;
        if (!(0, _StringUtils.isNullOrEmpty)(this.creativeData.clickThroughUrl) || this.creativeData.clickThroughCustoms.length > 0) {
            if ((0, _StringUtils.isNullOrEmpty)(this.creativeData.clickThroughUrl)) videoClicks = new _VideoClicks.VideoClicks(null, null, this.creativeData.clickThroughCustoms);
            else videoClicks = new _VideoClicks.VideoClicks(this.creativeData.clickThroughUrl, this.creativeData.clickThroughTrackings, this.creativeData.clickThroughCustoms);
        }
        var ic = null;
        if (this.creativeData.properties.length > 0) {
            ic = new _InteractiveCreative.InteractiveCreative(this.creativeData.icSource, this.creativeData.properties, this.broker, this.creativeData.interactiveTracking);
            if (!ic.isValid()) {
                _YoLog.YoLog.w("Discarding invalid InteractiveCreative");
                ic = null;
            }
        }
        var lc = new _LinearCreative.LinearCreative(this.creativeData, videoClicks, ic, this.broker);
        if (lc.isValid()) this.advertData.linearCreative = lc;
        else _YoLog.YoLog.w("Discarding invalid LinearCreative");
        this.creativeData.clear();
    };
    _proto9.handleEndImpression = function handleEndImpression(name) {
        var characters = this.characters.trim();
        if ((0, _HttpUtils.getUrl)(characters)) {
            if (!this.advertData.impressions) this.advertData.impressions = new _TrackingReport.TrackingReport(name, [
                characters
            ], this.adBreakData.identifier, this.advertData.mediaIdentifier);
            else this.advertData.impressions.addTrackingUrl(characters);
        } else _YoLog.YoLog.w("Discarding empty Impression");
    };
    _proto9.handleEndInteractiveCreativeFile = function handleEndInteractiveCreativeFile() {
        this.creativeData.icSource = this.characters.trim();
    };
    _proto9.handleEndJavaScriptResource = function handleEndJavaScriptResource() {
        if (this.advertData.verificationApiFramework && this.advertData.verificationBrowserOptional) {
            var prop = new _VASTProperty.VASTProperty(JAVASCRIPT_RESOURCE_TOKEN, this.characters.trim(), "apiFramework", this.advertData.verificationApiFramework);
            prop.addAttribute("browserOptional", this.advertData.verificationBrowserOptional);
            this.advertData.verificationResources.push(prop);
        }
        this.advertData.verificationApiFramework = null;
        this.advertData.verificationBrowserOptional = null;
    };
    _proto9.handleEndMediaFile = function handleEndMediaFile() {
        if (this.creativeData.properties.length !== 0) this.creativeData.icSource = this.characters.trim();
        else this.creativeData.currentAssetUri = this.characters.trim();
    };
    _proto9.handleEndNonLinearClickTracking = function handleEndNonLinearClickTracking() {
        var characters = this.characters.trim();
        if ((0, _HttpUtils.getUrl)(characters)) this.creativeData.clickThroughTrackings.push(characters);
        else _YoLog.YoLog.w("Discarding empty Nonlinear click tracking URL");
    };
    _proto9.handleEndPricing = function handleEndPricing() {
        var characters = this.characters.trim();
        if (characters !== "") {
            var prop = new _VASTProperty.VASTProperty(PRICING_TOKEN, characters, "currency", this.advertData.pricingCurrency);
            prop.addAttribute("model", this.advertData.pricingModel);
            if (!(0, _StringUtils.isNullOrEmpty)(this.advertData.pricingCurrency) && !(0, _StringUtils.isNullOrEmpty)(this.advertData.pricingModel)) this.advertData.properties.push(prop);
            else _YoLog.YoLog.w("Discarding invalid Pricing property");
        } else _YoLog.YoLog.w("Discarding invalid Pricing property");
    };
    _proto9.handleEndUniversalAdId = function handleEndUniversalAdId() {
        var characters = this.characters.trim();
        if (characters !== "") this.creativeData.universalAdIds.push(new _VASTProperty.VASTProperty(UNIVERSAL_AD_ID_TOKEN, characters, "idRegistry", this.creativeData.universalAdIdRegistry));
        else _YoLog.YoLog.w("Discarding empty UniversalAdId URL");
    };
    _proto9.handleEndVerification = function handleEndVerification() {
        var adVerification = new _AdVerification.AdVerification(this.advertData);
        if (adVerification.isValid()) this.advertData.adVerifications.push(adVerification);
        else _YoLog.YoLog.w("Discarding invalid AdVerification");
        this.advertData.verificationEvents = new Map();
        this.advertData.verificationResources = [];
        this.advertData.verificationParameters = null;
    };
    _proto9.handleEndVmapTracking = function handleEndVmapTracking() {
        var characters = this.characters.trim();
        if (!_TrackingReport.TrackingReport.isValidAdBreakEvent(this.adBreakData.trackingEvent)) _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, "Discarding invalid vmap:Tracking event");
        else if (!(0, _StringUtils.isNullOrEmpty)(characters)) {
            var report = this.adBreakData.timelineTrackingMap.get(this.adBreakData.trackingEvent);
            if (!report) {
                report = new _TrackingReport.TrackingReport(this.adBreakData.trackingEvent, [
                    characters
                ], this.adBreakData.identifier, this.advertData.mediaIdentifier);
                this.adBreakData.timelineTrackingMap.set(this.adBreakData.trackingEvent, report);
            } else report.addTrackingUrl(characters);
        } else _YoLog.YoLog.w("Discarding empty VMAP");
    };
    _proto9.handleEndNonLinear = function handleEndNonLinear() {
        var videoClicks = null;
        if (this.creativeData.clickThroughUrl && this.creativeData.clickThroughUrl !== "") videoClicks = new _VideoClicks.VideoClicks(this.creativeData.clickThroughUrl, this.creativeData.clickThroughTrackings, null);
        var creative = new _NonLinearCreative.NonLinearCreative(this.creativeData, videoClicks, this.creativeData.nonLinearResources, this.broker);
        if (creative.isValid()) {
            creative.setNonLinear(this.advertData.nonLinear);
            this.nonLinearAdsData.nonLinearCreatives.push(creative);
        } else _YoLog.YoLog.w("Discarding invalid NonLinear");
        this.creativeData.clear();
    };
    _proto9.handleEndStaticResource = function handleEndStaticResource() {
        var characters = this.characters.trim();
        if (this.iconClickFallbackImageData.properties.length > 0) {
            var res = new _Resource.Resource(_Resource.ResourceType.STATIC, characters, this.iconClickFallbackImageData.staticResourceCreativeType);
            if (res.isValid()) {
                this.iconClickFallbackImageData.resource = res;
                return;
            }
        } else if (this.iconData.properties.length > 0) {
            var _res = new _Resource.Resource(_Resource.ResourceType.STATIC, characters, this.iconData.staticResourceCreativeType);
            if (_res.isValid()) {
                this.iconData.resources.push(_res);
                return;
            }
        } else {
            var _res2 = new _Resource.Resource(_Resource.ResourceType.STATIC, characters, this.creativeData.staticResourceCreativeType);
            if (_res2.isValid()) {
                this.creativeData.nonLinearResources.push(_res2);
                return;
            }
        }
        _YoLog.YoLog.w("Discarding invalid StaticResource");
    };
    _proto9.handleEndTracking = function handleEndTracking() {
        var characters = this.characters.trim();
        if (!(0, _StringUtils.isNullOrEmpty)((0, _HttpUtils.getUrl)(characters))) {
            var map = null;
            if (_TrackingReport.TrackingReport.isValidVerificationEvent(this.creativeData.trackingEvent)) map = this.advertData.verificationEvents;
            else if (this.advertData.currentCreativeType === CreativeType.LINEAR && _TrackingReport.TrackingReport.isValidLinearEvent(this.creativeData.trackingEvent) || this.creativeData.trackingEvent.indexOf("progress") === 0) map = this.creativeData.trackingMap;
            else if (this.advertData.currentCreativeType === CreativeType.LINEAR && _TrackingReport.TrackingReport.isValidInteractiveEvent(this.creativeData.trackingEvent)) this.handleEndInteractiveTracking();
            else if (this.advertData.currentCreativeType === CreativeType.COMPANION && _TrackingReport.TrackingReport.isValidCompanionEvent(this.creativeData.trackingEvent)) map = this.creativeData.trackingMap;
            else if (this.advertData.currentCreativeType === CreativeType.NONLINEAR && _TrackingReport.TrackingReport.isValidNonLinearEvent(this.creativeData.trackingEvent)) map = this.nonLinearAdsData.trackingMap;
            if (map) this.parseMapForOnEndTracking(map);
        } else {
            _YoLog.YoLog.w("Discarding empty tracking URL");
            var parsingError = new _ParsingError.ParsingError(null, _ParsingError.ParsingError.Message.INVALID_TRACKING_URL, "Bad tracking url:" + characters + " event: " + this.creativeData.trackingEvent);
            this.broker.addParsingError(parsingError);
        }
    };
    _proto9.handleEndViewableImpression = function handleEndViewableImpression(name) {
        var characters = this.characters.trim();
        if (!(0, _StringUtils.isNullOrEmpty)((0, _HttpUtils.getUrl)(characters))) {
            var report = this.advertData.viewableImpressions.get(name);
            if (!report) {
                report = new _TrackingReport.TrackingReport(name, [
                    characters
                ], this.adBreakData.identifier, this.advertData.mediaIdentifier);
                this.advertData.viewableImpressions.set(name, report);
            } else report.addTrackingUrl(characters);
        } else _YoLog.YoLog.w("Discarding empty ViewableImpression URL");
    };
    _proto9.handleTextDataForExtensions = function handleTextDataForExtensions() {
        var characters = this.characters.trim();
        if (characters !== "") {
            var stack = [];
            if (this.processingAdvertExtensions) stack = this.advertData.extensionStack;
            else stack = this.advertData.processingCompanionCreative ? this.creativeData.companionExtensionStack : this.creativeData.extensionStack;
            if (stack.length > 0) {
                var node = stack[stack.length - 1];
                node.setInnerText(characters);
            }
        }
    };
    _proto9.handleVmapAdBreak = function handleVmapAdBreak() {
        // If early return is not null, discard the ad break.
        if (this.adBreakData.earlyReturn !== null) {
            // Set this so that a new adbreak won't be created due to a subsequent vmap ad break section
            this.streamData.earlyReturn = this.adBreakData.earlyReturn;
            this.adBreakData.clear();
            return;
        }
        if (_AdBreak.AdBreak.getBreakTypeFromString(this.adBreakData.breakType) === _AdBreak.BreakType.LINEAR && !this.skipNormalisation) // Get the normalised position of the ad break in case there is an overlap or a gap
        this.adBreakData.start = this.broker.normaliseAdBreakStart(this.adBreakData.start, this.adBreakData.position);
        var ab = new _AdBreak.AdBreak(this.adBreakData.start, this.adBreakData.duration, this.adBreakData.position, this.adBreakData.timelineTrackingMap, this.adBreakData.breakType, this.adBreakData.identifier, null, this.adBreakData.adTagUri);
        if (this.adBreakData.adverts.length > 0) ab.setAdverts(this.adBreakData.adverts);
        ab.postParse(this.broker);
        if (ab.isValid()) {
            var breakType = _AdBreak.AdBreak.getBreakTypeFromString(this.adBreakData.breakType);
            switch(breakType){
                case _AdBreak.BreakType.LINEAR:
                    this.linearAdBreaks.push(ab);
                    break;
                case _AdBreak.BreakType.NONLINEAR:
                    this.nonLinearAdBreaks.push(ab);
                    break;
                case _AdBreak.BreakType.DISPLAY:
                    this.displayAdBreaks.push(ab);
                    break;
            }
        } else {
            var fragment = this.streamData.hasPlaceholder ? " placeholder " : " ";
            _YoLog.YoLog.w("Discarding empty" + fragment + "ad break");
            this.checkAdBreakForParsingErrors(ab);
        }
        this.adBreakData.clear();
    };
    _proto9.handleVmapAdTagURI = function handleVmapAdTagURI() {
        this.streamData.hasPlaceholder = true;
        this.adBreakData.adTagUri = this.characters.trim();
    };
    _proto9.handleStartYospaceAdBreak = function handleStartYospaceAdBreak(attributes) {
        var durationAttr = attributes.duration;
        var error = -1;
        if (durationAttr) this.adBreakData.duration = (0, _ConversionUtils.timeStringToMillis)(durationAttr, error);
        if (_AdBreak.AdBreak.getBreakTypeFromString(this.adBreakData.breakType) === _AdBreak.BreakType.LINEAR && this.adBreakData.duration === error) {
            var parsingError = new _ParsingError.ParsingError(this.adBreakData.identifier, _ParsingError.ParsingError.Message.INVALID_DURATION, _ParsingError.ParsingError.Message.INVALID_DURATION + ": " + durationAttr);
            this.broker.addParsingError(parsingError);
        }
        var positionAttr = attributes.position;
        if (positionAttr) this.adBreakData.position = positionAttr;
        var earlyReturnAttr = attributes.earlyReturn;
        if (earlyReturnAttr) {
            var earlyReturn = (0, _ConversionUtils.timeStringToMillis)(earlyReturnAttr, error);
            // This is an offset relative to ad break start
            this.adBreakData.earlyReturn = earlyReturn !== error ? earlyReturn + this.adBreakData.start : -1;
        }
    };
    _proto9.handleYospaceStream = function handleYospaceStream(attributes) {
        var urlDomainAttr = attributes.urlDomain;
        if (urlDomainAttr) this.streamData.hostNode = urlDomainAttr;
        var hostSuffixAttr = attributes.urlSuffix;
        if (hostSuffixAttr) this.streamData.hostSuffix = hostSuffixAttr;
        var durationAttr = attributes.duration;
        if (durationAttr) {
            var duration = (0, _ConversionUtils.timeStringToMillis)(attributes.duration, 0);
            if (duration) this.streamData.duration = duration;
        }
        // Try to find the session identifier
        if (this.streamData.hostSuffix) {
            var match = this.streamData.hostSuffix.match(YOPSI_PATTERN);
            if (match) this.streamData.sessionIdentifier = match[1];
        }
        // yyyy-MM-dd'T'HH:mm:ss.SSS
        this.streamData.pdtInitial = (0, _ConversionUtils.pdtToMillis)(attributes.pdtinitial, null);
        this.streamData.pdtStart = (0, _ConversionUtils.pdtToMillis)(attributes.pdtstart, null);
        this.streamData.pdtEnd = (0, _ConversionUtils.pdtToMillis)(attributes.pdtend, null);
        if (this.streamData.pdtStart === null || this.streamData.pdtEnd === null || this.streamData.pdtStart > this.streamData.pdtEnd) {
            this.streamData.pdtStart = null;
            this.streamData.pdtEnd = null;
            this.streamData.pdtInitial = null;
        }
    };
    _proto9.onCdata = function onCdata(data) {
        this.characters = data;
        if (this.processingAdvertExtensions || this.processingCreativeExtensions) this.handleTextDataForExtensions();
    };
    _proto9.onOpenTag = function onOpenTag(tag) {
        var attributes = tag.attributes;
        if (this.processingAdvertExtensions || this.processingCreativeExtensions) {
            this.handleStartExtensionElement(attributes, tag);
            return;
        }
        if (tag.name === VMAP_TOKEN) this.isVmap = true;
        if (tag.name === YOSPACE_STREAM_TOKEN) this.handleYospaceStream(attributes);
        if (tag.name === VMAP_ADBREAK_TOKEN) {
            this.adBreakData.timeOffset = attributes.timeOffset;
            if (this.adBreakData.timeOffset) this.adBreakData.start = (0, _ConversionUtils.timeStringToMillis)(this.adBreakData.timeOffset, -1);
            var breakTypeAttr = attributes.breakType;
            if (breakTypeAttr) this.adBreakData.breakType = breakTypeAttr;
            var breakIdAttr = attributes.breakId;
            if (breakIdAttr) this.adBreakData.identifier = breakIdAttr;
        }
        if (tag.name === YOSPACE_ADBREAK_TOKEN) this.handleStartYospaceAdBreak(attributes);
        if (tag.name === VMAP_TRACKING_TOKEN) this.adBreakData.trackingEvent = attributes.event;
        if (tag.name === VAST_TOKEN) {
            this.adBreakData.vastVersion = attributes.version;
            if (!this.checkValidVersion(this.adBreakData.vastVersion)) {
                _YoLog.YoLog.e("Invalid or missing VAST version; is AV tag defined?");
                this.isValidVAST = false;
            }
        }
        if (tag.name === AD_TOKEN) this.handleStartAd(attributes);
        if (tag.name === AD_WRAPPER_TOKEN) this.handleStartAdWrapper(attributes);
        if (tag.name === CATEGORY_TOKEN) this.advertData.categoryAuthority = attributes.authority;
        if (tag.name === AD_SYSTEM_TOKEN) this.advertData.adSystemVersion = attributes.version;
        if (tag.name === ADVERTISER_TOKEN) this.advertData.advertiserId = attributes.id;
        if (tag.name === SURVEY_TOKEN) this.advertData.surveyType = attributes.type;
        if (tag.name === PRICING_TOKEN) this.handleStartPricing(attributes);
        if (tag.name === UNIVERSAL_AD_ID_TOKEN) this.creativeData.universalAdIdRegistry = attributes.idRegistry;
        if (tag.name === EXTENSIONS_TOKEN) this.advertData.extensionStack.push(new _XmlNode.XmlNode(tag.name, (0, _CollectionUtils.objectToMap)(attributes)));
        if (tag.name === CREATIVE_TOKEN) this.handleStartCreative(attributes);
        if (tag.name === LINEAR_TOKEN) {
            this.advertData.currentCreativeType = CreativeType.LINEAR;
            this.creativeData.skipOffset = attributes.skipoffset;
        }
        if (tag.name === ICON_TOKEN) this.populateIconPropertyList(attributes);
        if (tag.name === ICON_CLICK_FALLBACK_IMAGE_TOKEN) this.populateIconClickFallbackImagePropertyList(attributes);
        if (tag.name === AD_PARAMETERS_TOKEN) this.creativeData.adParameters = new _VASTProperty.VASTProperty(AD_PARAMETERS_TOKEN, null, "xmlEncoded", attributes.xmlEncoded);
        if (tag.name === INTERACTIVE_CREATIVE_FILE_TOKEN) this.populateInteractiveCreativePropertyList(attributes);
        if (tag.name === NON_LINEAR_ADS_TOKEN) this.advertData.currentCreativeType = CreativeType.NONLINEAR;
        if (tag.name === NON_LINEAR_TOKEN) this.populateNonLinearPropertyList(attributes);
        if (tag.name === COMPANION_ADS_TOKEN) {
            this.advertData.currentCreativeType = CreativeType.COMPANION;
            this.advertData.processingCompanionCreative = true;
            this.companionAdsData.required = attributes.required;
        }
        if (tag.name === COMPANION_TOKEN) this.populateCompanionPropertyList(attributes);
        if (tag.name === STATIC_RESOURCE_TOKEN) this.handleStartStaticResource(attributes);
        if (tag.name === HTML_RESOURCE_TOKEN) this.handleStartHtmlResource(attributes);
        if (tag.name === TRACKING_TOKEN) this.handleStartTracking(attributes);
        if (tag.name === VERIFICATION_TOKEN) this.advertData.verificationVendor = attributes.vendor;
        if (tag.name === JAVASCRIPT_RESOURCE_TOKEN) {
            this.advertData.verificationApiFramework = attributes.apiFramework;
            this.advertData.verificationBrowserOptional = attributes.browserOptional;
        }
        if (tag.name === EXECUTABLE_RESOURCE_TOKEN) {
            this.advertData.verificationApiFramework = attributes.apiFramework;
            this.advertData.verificationResourceType = attributes.type;
        }
        if (tag.name === EXTENSION_TOKEN) this.handleStartExtension(attributes, tag);
        if (tag.name === CREATIVE_EXTENSIONS_TOKEN) this.addToCreativeExtensionStack(new _XmlNode.XmlNode(tag.name, (0, _CollectionUtils.objectToMap)(attributes)));
        if (tag.name === CREATIVE_EXTENSION_TOKEN) this.handleStartCreativeExtension(attributes, tag);
        if (tag.isSelfClosing) this.onCloseTag(tag);
    };
    _proto9.onCloseTag = function onCloseTag(tag) {
        if (this.processingAdvertExtensions || this.processingCreativeExtensions) {
            this.handleEndExtensionElement(tag);
            this.characters = "";
            return;
        }
        if (tag === VMAP_ADBREAK_TOKEN) this.handleVmapAdBreak();
        if (tag === VMAP_TRACKING_TOKEN) this.handleEndVmapTracking();
        if (tag === AD_TOKEN) this.handleEndAd();
        if (tag === AD_SYSTEM_TOKEN) this.advertData.properties.push(new _VASTProperty.VASTProperty("AdSystem", this.characters.trim(), "version", this.advertData.adSystemVersion));
        if (tag === AD_TITLE_TOKEN) this.handleEndAdTitle();
        if (tag === IMPRESSION_TOKEN) this.handleEndImpression(tag);
        if (tag === AD_SERVING_ID_TOKEN) this.advertData.properties.push(new _VASTProperty.VASTProperty(AD_SERVING_ID_TOKEN, this.characters.trim()));
        if (tag === CATEGORY_TOKEN) this.advertData.properties.push(new _VASTProperty.VASTProperty(CATEGORY_TOKEN, this.characters.trim(), "authority", this.advertData.categoryAuthority));
        if (tag === DESCRIPTION_TOKEN) this.advertData.properties.push(new _VASTProperty.VASTProperty(DESCRIPTION_TOKEN, this.characters.trim()));
        if (tag === ADVERTISER_TOKEN) this.advertData.properties.push(new _VASTProperty.VASTProperty(ADVERTISER_TOKEN, this.characters.trim(), "id", this.advertData.advertiserId));
        if (tag === SURVEY_TOKEN) this.advertData.properties.push(new _VASTProperty.VASTProperty(SURVEY_TOKEN, this.characters.trim(), "type", this.advertData.surveyType));
        if (tag === ERROR_TOKEN) this.handleEndError(tag);
        if (tag === PRICING_TOKEN) this.handleEndPricing();
        if (tag === UNIVERSAL_AD_ID_TOKEN) this.handleEndUniversalAdId();
        if (tag === EXTENSIONS_TOKEN) this.pop(true, false);
        if (tag === CREATIVE_EXTENSIONS_TOKEN) this.pop(false, false);
        if (tag === VERIFICATION_TOKEN) this.handleEndVerification();
        if (tag === VERIFICATION_PARAMETERS_TOKEN) this.advertData.verificationParameters = this.characters.trim();
        if (tag === MEDIAFILE_TOKEN) this.handleEndMediaFile();
        if (tag === INTERACTIVE_CREATIVE_FILE_TOKEN) this.handleEndInteractiveCreativeFile();
        if (tag === CLICK_THROUGH_TOKEN || tag === NON_LINEAR_CLICK_THROUGH_TOKEN || tag === COMPANION_CLICK_THROUGH_TOKEN) this.creativeData.clickThroughUrl = this.characters.trim();
        if (tag === ICON_CLICK_THROUGH_TOKEN) this.iconData.clickThroughUrl = this.characters.trim();
        if (tag === CLICK_TRACKING_TOKEN) this.handleEndClickTracking();
        if (tag === NON_LINEAR_CLICK_TRACKING_TOKEN) this.handleEndNonLinearClickTracking();
        if (tag === COMPANION_CLICK_TRACKING_TOKEN) this.handleEndCompanionClickTracking();
        if (tag === ICON_CLICK_TRACKING_TOKEN) this.handleEndIconClickTracking();
        if (tag === ICON_CLICK_FALLBACK_IMAGE_TOKEN) this.handleEndIconClickFallbackImage();
        if (tag === ALT_TEXT_TOKEN) {
            if (this.iconClickFallbackImageData.properties.length > 0) this.iconClickFallbackImageData.altText = this.characters.trim();
            else this.creativeData.altText = this.characters.trim();
        }
        if (tag === CUSTOM_CLICK) this.handleEndCustomClick();
        if (tag === ICON_VIEW_TRACKING_TOKEN) this.handleEndIconViewTracking();
        if (tag === CREATIVE_TOKEN) this.handleEndCreative();
        if (tag === LINEAR_TOKEN) this.handleEndLinear();
        if (tag === NON_LINEAR_ADS_TOKEN) {
            this.advertData.nonLinearAds = new _NonLinearAds.NonLinearAds(this.nonLinearAdsData.trackingMap, this.nonLinearAdsData.nonLinearCreatives);
            this.nonLinearAdsData.clear();
        }
        if (tag === NON_LINEAR_TOKEN) this.handleEndNonLinear();
        if (tag === COMPANION_ADS_TOKEN) {
            this.advertData.companionAds = new _CompanionAds.CompanionAds(this.companionAdsData.required, this.companionAdsData.companions);
            this.companionAdsData.clear();
            this.advertData.processingCompanionCreative = false;
        }
        if (tag === COMPANION_TOKEN) this.handleEndCompanion();
        if (tag === ICON_TOKEN) this.handleEndIcon();
        if (tag === AD_PARAMETERS_TOKEN) this.creativeData.adParameters.setValue(this.characters.trim());
        if (tag === DURATION_TOKEN) this.creativeData.duration = this.characters.trim();
        if (tag === VIEWABLE_TOKEN || tag === NOT_VIEWABLE_TOKEN || tag === VIEW_UNDETERMINED_TOKEN) this.handleEndViewableImpression(tag);
        if (tag === STATIC_RESOURCE_TOKEN) this.handleEndStaticResource();
        if (tag === HTML_RESOURCE_TOKEN) this.handleEndHtmlResource();
        if (tag === IFRAME_RESOURCE_TOKEN) this.handleEndIFrameResource();
        if (tag === TRACKING_TOKEN) this.handleEndTracking();
        if (tag === JAVASCRIPT_RESOURCE_TOKEN) this.handleEndJavaScriptResource();
        if (tag === EXECUTABLE_RESOURCE_TOKEN) this.handleEndExecutableResource();
        if (tag === VMAP_ADTAG_URI) this.handleVmapAdTagURI();
    };
    _proto9.onText = function onText(text) {
        this.characters = text;
        if (this.processingAdvertExtensions || this.processingCreativeExtensions) this.handleTextDataForExtensions();
    };
    Parser.parse = function parse(xml, broker, options) {
        var parser = new Parser(broker);
        return parser.parse(xml, options);
    };
    _proto9.parse = function parse(xml, options) {
        var _this = this;
        this.skipNormalisation = options && options.skipNormalisation ? options.skipNormalisation : false;
        var error = false;
        return new Promise(function(resolve, reject) {
            try {
                var parser = _sax["default"].parser(true);
                parser.onerror = function(e) {
                    error = true;
                    _YoLog.YoLog.e("Failed to parse document: " + e);
                    _this.broker.addParsingError(new _ParsingError.ParsingError(null, _ParsingError.ParsingError.Message.BAD_XML, e.message));
                    resolve(null);
                };
                parser.ontext = _this.onText;
                parser.onopentag = _this.onOpenTag;
                parser.onclosetag = _this.onCloseTag;
                parser.oncdata = _this.onCdata;
                parser.write(xml).close();
                var payload = null;
                if (error) return;
                if (_this.isVmap) {
                    if (!_this.isValidVAST) {
                        _this.broker.addParsingError(new _ParsingError.ParsingError(null, _ParsingError.ParsingError.Message.INCORRECT_VAST_VERSION, "Version is " + _this.adBreakData.vastVersion + ", expected >= 4.2"));
                        _YoLog.YoLog.e("Failed to parse document.  VAST not valid");
                        resolve(null);
                        return;
                    }
                } else {
                    _this.broker.addParsingError(new _ParsingError.ParsingError(null, _ParsingError.ParsingError.Message.NO_VMAP));
                    _YoLog.YoLog.e("Failed to parse document.  VMAP not found");
                    resolve(null);
                    return;
                }
                logParsingSummary(_this);
                payload = new _AnalyticPayload.AnalyticPayload(_this, xml.toString());
                resolve(payload);
            } catch (err) {
                _this.broker.addParsingError(new _ParsingError.ParsingError(null, _ParsingError.ParsingError.Message.BAD_XML, err.message));
                reject(err);
            }
        });
    };
    _proto9.parseMapForOnEndTracking = function parseMapForOnEndTracking(map) {
        var characters = this.characters.trim();
        var report = map.get(this.creativeData.trackingEvent);
        if (!report) {
            if (this.creativeData.trackingEvent.indexOf("progress") !== -1) report = new _TrackingReport.TrackingReport("progress", [
                characters
            ], this.adBreakData.identifier, this.advertData.mediaIdentifier);
            else report = new _TrackingReport.TrackingReport(this.creativeData.trackingEvent, [
                characters
            ], this.adBreakData.identifier, this.advertData.mediaIdentifier);
            map.set(this.creativeData.trackingEvent, report);
        } else report.addTrackingUrl(characters);
    };
    _proto9.pop = function pop(adExtension, addAsChild) {
        var stack = [];
        if (adExtension) stack = this.advertData.extensionStack;
        else stack = this.advertData.processingCompanionCreative ? this.creativeData.companionExtensionStack : this.creativeData.extensionStack;
        var node = stack.pop();
        if (addAsChild) stack[stack.length - 1].addChild(node);
        else {
            if (adExtension) this.advertData.extensions = node;
            else if (this.advertData.processingCompanionCreative) this.creativeData.companionExtensions = node;
            else this.creativeData.extensions = node;
        }
    };
    _proto9.populateCompanionProperty = function populateCompanionProperty(attributes, name) {
        this.populateCreativeProperty(attributes, name);
    };
    _proto9.populateCompanionPropertyList = function populateCompanionPropertyList(attributes) {
        this.populateCompanionProperty(attributes, "id");
        this.populateCompanionProperty(attributes, "width");
        this.populateCompanionProperty(attributes, "height");
        this.populateCompanionProperty(attributes, "assetWidth");
        this.populateCompanionProperty(attributes, "assetHeight");
        this.populateCompanionProperty(attributes, "expandedWidth");
        this.populateCompanionProperty(attributes, "expandedHeight");
        this.populateCompanionProperty(attributes, "apiFramework");
        this.populateCompanionProperty(attributes, "adSlotId");
        this.populateCompanionProperty(attributes, "pxratio");
        this.populateCompanionProperty(attributes, "renderingMode");
    };
    _proto9.populateCreativeProperty = function populateCreativeProperty(attributes, name) {
        var attr = attributes[name];
        if (!(0, _StringUtils.isNullOrEmpty)(attr)) this.creativeData.properties.push(new _VASTProperty.VASTProperty(name, attr));
    };
    _proto9.populateIconProperty = function populateIconProperty(attributes, name) {
        var attr = attributes[name];
        if (!(0, _StringUtils.isNullOrEmpty)(attr)) this.iconData.properties.push(new _VASTProperty.VASTProperty(name, attr));
    };
    _proto9.populateIconPropertyList = function populateIconPropertyList(attributes) {
        for(var property in attributes)this.populateIconProperty(attributes, property);
    };
    _proto9.populateIconClickFallbackImageProperty = function populateIconClickFallbackImageProperty(attributes, name) {
        var attr = attributes[name];
        if (!(0, _StringUtils.isNullOrEmpty)(attr)) this.iconClickFallbackImageData.properties.push(new _VASTProperty.VASTProperty(name, attr));
    };
    _proto9.populateIconClickFallbackImagePropertyList = function populateIconClickFallbackImagePropertyList(attributes) {
        this.populateIconClickFallbackImageProperty(attributes, "width");
        this.populateIconClickFallbackImageProperty(attributes, "height");
    };
    _proto9.populateInteractiveCreativeProperty = function populateInteractiveCreativeProperty(attributes, name) {
        this.populateCreativeProperty(attributes, name);
    };
    _proto9.populateInteractiveCreativePropertyList = function populateInteractiveCreativePropertyList(attributes) {
        this.populateInteractiveCreativeProperty(attributes, "apiFramework");
        this.populateInteractiveCreativeProperty(attributes, "type");
        var variableDuration = attributes.variableDuration;
        if (!(0, _StringUtils.isNullOrEmpty)(variableDuration)) this.populateInteractiveCreativeProperty(attributes, "variableDuration");
        else this.creativeData.properties.push(new _VASTProperty.VASTProperty("variableDuration", "false"));
    };
    _proto9.populateNonLinearProperty = function populateNonLinearProperty(attributes, name) {
        this.populateCreativeProperty(attributes, name);
    };
    _proto9.populateNonLinearPropertyList = function populateNonLinearPropertyList(attributes) {
        this.populateNonLinearProperty(attributes, "id");
        this.populateNonLinearProperty(attributes, "width");
        this.populateNonLinearProperty(attributes, "height");
        this.populateNonLinearProperty(attributes, "expandedWidth");
        this.populateNonLinearProperty(attributes, "expandedHeight");
        this.populateNonLinearProperty(attributes, "scalable");
        this.populateNonLinearProperty(attributes, "maintainAspectRatio");
        this.populateNonLinearProperty(attributes, "apiFramework");
        this.populateNonLinearProperty(attributes, "minSuggestedDuration");
    };
    return Parser;
}();

},{"cb4f274328b2ae21":"lEjO0","4021d38c63d53816":"9KS65","3d6509fd3aaf9359":"8owmX","5605146537da25fd":"8JE54","e2ca759a9177088f":"h21pj","ac7551da0c61864d":"dVAhT","89c6b6bd7763c0ce":"lj3Py","ae1fe73454e59e4c":"cg5iB","a84269bfbd2ec121":"heno1","596e5dbd885edb06":"Ir4VY","141ab5a6ca47ef57":"cZC7f","d5ade2f1951706de":"boy2w","c7e6705edfc30985":"1lIbj","c3ecc0ea5c24eae2":"3iyI3","416eae9639203cfa":"kiVVI","c9cfeb3bc1bf4fcf":"bOBcw","44e2ed583f6f6f23":"hUwGK","6bf31caae1bb272f":"fbiP9","6609b134918cc3ad":"153sX","a40eb0c45af08efe":"dG5RW","d6c640720d67b29c":"7uXt7","65bce526262aa884":"2wJyf","973c55c4bac3dd1e":"14hHv","a2cad4d5e24baa17":"2pu2E","a352eee08ade0455":"8IvwS"}],"14hHv":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.AnalyticPayload = void 0;
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/*
 * COPYRIGHT 2020-2022 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ var AnalyticPayload = exports.AnalyticPayload = /*#__PURE__*/ function() {
    function AnalyticPayload(parser, xml) {
        if (parser) {
            this.linearAdBreaks = parser.linearAdBreaks ? parser.linearAdBreaks : [];
            this.nonLinearAdBreaks = parser.nonLinearAdBreaks ? parser.nonLinearAdBreaks : [];
            this.displayAdBreaks = parser.displayAdBreaks ? parser.displayAdBreaks : [];
            var streamData = parser.getStreamData();
            this.processStreamData(streamData);
        }
        this.setHash(xml);
    }
    /*
   * returns the value of displayAdBreaks
   */ var _proto = AnalyticPayload.prototype;
    _proto.getDisplayAdBreaks = function getDisplayAdBreaks() {
        return this.displayAdBreaks;
    } /*
   * returns the value of earlyReturn, -1 if not set, null if not well-formed
   */ ;
    _proto.getEarlyReturn = function getEarlyReturn() {
        return this.earlyReturn;
    } /*
   * returns the value of linearAdBreaks
   */ ;
    _proto.getLinearAdBreaks = function getLinearAdBreaks() {
        return this.linearAdBreaks;
    } /*
   * returns whether the Vmap has a placeholder break
   */ ;
    _proto.getHasPlaceholder = function getHasPlaceholder() {
        return this.hasPlaceholder;
    } /*
   * returns the value of hostNode
   */ ;
    _proto.getHostNode = function getHostNode() {
        return this.hostNode;
    } /*
   * returns the value of hostSuffix
   */ ;
    _proto.getHostSuffix = function getHostSuffix() {
        return this.hostSuffix;
    } /*
   * returns the value of nonLinearAdBreaks
   */ ;
    _proto.getNonLinearAdBreaks = function getNonLinearAdBreaks() {
        return this.nonLinearAdBreaks;
    } /*
   * returns the value of pdtInitial
   */ ;
    _proto.getPdtInitial = function getPdtInitial() {
        return this.pdtInitial;
    } /*
   * returns the value of pdtStart
   */ ;
    _proto.getPdtStart = function getPdtStart() {
        return this.pdtStart;
    } /*
   * returns the value of pdtEnd
   */ ;
    _proto.getPdtEnd = function getPdtEnd() {
        return this.pdtEnd;
    } /*
   * returns the value of sessionIdentifier
   */ ;
    _proto.getSessionIdentifier = function getSessionIdentifier() {
        return this.sessionIdentifier;
    } /*
   * returns the value of streamDuration
   */ ;
    _proto.getStreamDuration = function getStreamDuration() {
        return this.streamDuration;
    } /*
   * returns true if this payload has any ad breaks
   */ ;
    _proto.hasAdBreaks = function hasAdBreaks() {
        return this.linearAdBreaks.length > 0 || this.nonLinearAdBreaks.length > 0 || this.displayAdBreaks.length > 0;
    } /*
   * returns true if the supplied payload is equal to the receiver
   */ ;
    _proto.isEqualTo = function isEqualTo(payload) {
        return this.hashCode === payload.hashCode;
    };
    _proto.processStreamData = function processStreamData(streamData) {
        this.sessionIdentifier = streamData.getSessionIdentifier();
        this.streamDuration = streamData.getDuration();
        this.hostNode = streamData.getHostNode();
        this.hostSuffix = streamData.getHostSuffix();
        this.pdtInitial = streamData.getPdtInitial();
        this.pdtStart = streamData.getPdtStart();
        this.pdtEnd = streamData.getPdtEnd();
        this.earlyReturn = streamData.getEarlyReturn();
        this.hasPlaceholder = streamData.getHasPlaceholder();
    };
    _proto.setHash = function setHash(xml) {
        if (!xml) return;
        var hash = 0;
        var i;
        var chr;
        for(i = 0; i < xml.length; i++){
            chr = xml.charCodeAt(i);
            hash = (hash << 5) - hash + chr;
            hash = hash & hash;
        }
        this.hashCode = hash;
    };
    _proto.toString = function toString() {
        var ret = "Linear AdBreaks:";
        for(var _iterator = _createForOfIteratorHelperLoose(this.linearAdBreaks), _step; !(_step = _iterator()).done;){
            var lab = _step.value;
            ret += "\n" + lab;
        }
        ret += "\n\nNonLinear AdBreaks:";
        for(var _iterator2 = _createForOfIteratorHelperLoose(this.nonLinearAdBreaks), _step2; !(_step2 = _iterator2()).done;){
            var nla = _step2.value;
            ret += "\n" + nla;
        }
        ret += "\n\nDisplay AdBreaks:";
        for(var _iterator3 = _createForOfIteratorHelperLoose(this.displayAdBreaks), _step3; !(_step3 = _iterator3()).done;){
            var dab = _step3.value;
            ret += "\n" + dab;
        }
        ret += "\n\nHostNode:";
        ret += "\n" + this.hostNode;
        ret += "\n\nHostSuffix:";
        ret += "\n" + this.hostSuffix;
        ret += "\n\nSessionIdentifier:";
        ret += "\n" + this.sessionIdentifier;
        ret += "\n\nStreamDuration:";
        ret += "\n" + this.streamDuration;
        ret += "\n\npdtInitial:";
        ret += "\n" + this.pdtInitial;
        ret += "\n\npdtStart:";
        ret += "\n" + this.pdtStart;
        ret += "\n\npdtEnd:";
        ret += "\n" + this.pdtEnd;
        ret += "mmearlyReturn:";
        ret += "\n" + this.earlyReturn;
        return ret;
    };
    return AnalyticPayload;
}();

},{}],"4FieK":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.SessionLive = void 0;
var _Constant = require("a226736c49a6196e");
var _DashManifestParser = require("856fa45bdea47487");
var _DefaultPlaybackPolicyHandler = require("e9b7f89e187346ab");
var _Event = require("575d800c817291ed");
var _Session2 = require("eafae3a0b533df99");
var _YoLog = require("4a5731b9b36b75ed");
var _StringUtils = require("622d81d5865249ae");
var _ReportsManager = require("bfcdee8ea9ba12ce");
var _HlsManifestParser = require("92c74c53e73a3030");
var _TimedMetadata = require("7778ff191b4e4b56");
var _HttpConnection = require("78942e8ef7f69bc7");
var _HttpUtils = require("90ec3eeb633cb3f7");
var _UrlPoller = require("5e41c312baf788de");
var _Parser = require("f737be785273c810");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// Imports for jsdoc
var AdvertStatus = Object.freeze({
    PLAYED_OUT: 0,
    NOT_PLAYED_OUT: 1,
    NEW_ADVERT_STARTING: 2
});
/**
 * Concrete Session implementation representing a single viewing of a single live stream sourced from
 * the Yospace Video Platform via the Central Streaming Manager (CSM)
 * @see {@link Session} base class
 * @hideconstructor
 */ var SessionLive = exports.SessionLive = /*#__PURE__*/ function(_Session) {
    _inheritsLoose(SessionLive, _Session);
    function SessionLive(properties, analyticUrl) {
        var _this;
        _this = _Session.call(this, properties) || this;
        /** @private */ _this.advertEndWatchdog = null;
        /** @private */ _this.interSegmentTimeout = _Constant.Constant.INTERSEGMENT_TIMEOUT;
        /** @private */ _this.lastTimedMetadata = null;
        /** @private */ _this.pendingTimedMetadata = null;
        /** @private */ _this.historicalTimedMetadata = [];
        /** @private */ _this.inAdBreak = false;
        /** @private */ _this.targetDuration = _Constant.Constant.DEFAULT_POLLING_DELAY;
        _this.setAnalyticsUrl(analyticUrl);
        _this.setPlaybackPolicyHandler(new _DefaultPlaybackPolicyHandler.DefaultPlaybackPolicyHandler(_Session2.PlaybackMode.LIVE));
        return _this;
    }
    /**
   * @callback sessionCallback
   * @param {SessionLive} session a completed session object
   */ /**
   * The factory method for creating a SessionLive instance, when using Direct Initialisation.
   * Constructs and initialises a new SessionLive using the {@link SessionProperties} provided.
   * On completion calls the EventListener provided passing the initialised SessionLive back if
   * a callback was provided.  If a callback was not provided, a Promise is returned instead.
   *
   * @param {string} url The Yospace initialisation URL to the Central Streaming Manager
   * @param {SessionProperties} [properties] (Optional) An initialisation properties object
   * @param {sessionCallback} [callback] (Optional) A completion handler to call after initialisation is finished.
   */ SessionLive.create = function create(url, properties, callback) {
        var session = new SessionLive(properties, null);
        if (callback) session.initialiseFromSession(url).then(function() {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "Session initialised");
        })["catch"](function() {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "Session failed to initialise");
        })["finally"](function() {
            callback(new _Event.Event(session));
        });
        else return session.initialiseFromSession(url);
    };
    var _proto = SessionLive.prototype;
    _proto.cancelScheduleWatchdog = function cancelScheduleWatchdog() {
        if (this.advertEndWatchdog !== null) {
            clearTimeout(this.advertEndWatchdog);
            this.advertEndWatchdog = null;
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "Cancelled watchdog timer");
        }
    };
    _proto.getAdBreakForAdvert = function getAdBreakForAdvert(advert) {
        if (advert && this.linearAdBreaks.length > 0) {
            var mediaId = advert.getMediaIdentifier();
            for(var _iterator = _createForOfIteratorHelperLoose(this.linearAdBreaks), _step; !(_step = _iterator()).done;){
                var ab = _step.value;
                var ad = ab.getAdvertFromIdentifier(mediaId);
                if (ad) return ab;
            }
        }
        return null;
    };
    _proto.getFirstAdvertRemovingAllPrevious = function getFirstAdvertRemovingAllPrevious(mediaId) {
        if (this.linearAdBreaks.length === 0) return null;
        var match = null;
        var breakIndexFound = -1;
        for(var breakIndex = 0; breakIndex < this.linearAdBreaks.length; ++breakIndex){
            var br = this.linearAdBreaks[breakIndex];
            for(var _iterator2 = _createForOfIteratorHelperLoose(br.getAdverts()), _step2; !(_step2 = _iterator2()).done;){
                var advert = _step2.value;
                if (advert.getMediaIdentifier() === mediaId && advert.isActive()) {
                    match = advert;
                    breakIndexFound = breakIndex;
                    break;
                } else advert.setInactive();
            }
            if (match !== null) break;
        }
        // If this is not the first break then remove breaks prior to this one
        if (breakIndexFound > 0) this.linearAdBreaks.splice(0, breakIndexFound);
        return match;
    };
    _proto.getMetadataTimeout = function getMetadataTimeout(metadata) {
        if (metadata && metadata.getTypeWithinSegment() === _TimedMetadata.TypeWithinSegment.END) return this.interSegmentTimeout;
        else return Math.max(this.targetDuration + 1000 >> 1, _Constant.Constant.MIN_INTRASEGMENT_TIMEOUT);
    };
    _proto.getPlaybackMode = function getPlaybackMode() {
        return _Session2.PlaybackMode.LIVE;
    };
    _proto.handleMetaDataInSequence = function handleMetaDataInSequence(advert, metadata) {
        var currentAdvert = this.getCurrentAdvert();
        if (metadata.isFirstInSequence()) // Start of an advert.  Start a break if required and notify clients
        this.onAdvertStart(advert, metadata.getPlayhead());
        else if (metadata.isLastInSequence()) // The order is important because HasAdvertExpired() returns false if currentAdvert is invalid
        {
            if (currentAdvert && (!currentAdvert.isFiller() || this.hasAdvertExpired(currentAdvert, metadata))) this.onAdvertEnd(AdvertStatus.PLAYED_OUT);
        } else if (currentAdvert) {
            if (metadata.isLastInSegment() && (currentAdvert.isFiller() || currentAdvert.isTruncated()) && this.hasAdvertExpired(currentAdvert, metadata)) {
                // End of a filler segment or truncated advert
                _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "Filler expired or truncated advert completed.  Ending advert and ad break");
                this.onAdvertEnd(AdvertStatus.PLAYED_OUT);
            } else {
                // Middle of an advert
                var delta = Math.max(metadata.getPlayhead() - currentAdvert.getStart(), 0);
                this.signalTimelineTrackingEvents(delta);
            }
        } else // Start an ad break anyway, even if the advert is not known
        this.onAdvertBreakStart(advert);
    };
    _proto.handleMetaDataOutOfSequence = function handleMetaDataOutOfSequence(advert, metadata) {
        var currentAdvert = this.getCurrentAdvert();
        if (!currentAdvert) {
            if (metadata.isFirstInSequence()) // Not in an advert and TimedMetadata is the first ID3 tag of an advert
            this.onAdvertStart(advert, metadata.getPlayhead());
            else // In case an out-of-sequence tag is received and there is no valid advert.
            // This is the only place the Session should schedule an adbreak watchdog timer
            // when it may not be in an adbreak.
            this.scheduleAdvertBreakEnd(this.interSegmentTimeout);
        } else if (currentAdvert.getMediaIdentifier() !== advert.getMediaIdentifier()) {
            // In advert (and therefore break) and Yospace ids differ
            this.onAdvertEnd(AdvertStatus.NOT_PLAYED_OUT);
            if (metadata.isFirstInSequence()) // Start of the next advert so schedule
            this.onAdvertStart(advert, metadata.getPlayhead());
            else if (metadata.isLastInSequence() || (advert.isFiller() || advert.isTruncated()) && metadata.isLastInSegment() && this.hasAdvertExpired(advert, metadata)) {
                advert.setInactive();
                if (!this.getCurrentAdBreak().isActive()) this.onAdvertBreakEnd();
            }
        }
    };
    _proto.hasAdvertExpired = function hasAdvertExpired(advert, metadata) {
        var ist = this.interSegmentTimeout;
        var dur = metadata.getPlayhead() - advert.getStart() + ist;
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "(" + (advert.isFiller() ? "FILLER" : "ADVERT") + " CHECK): Ad duration: " + advert.getDuration() + ", elapsed: " + (metadata.getPlayhead() - advert.getStart() + this.interSegmentTimeout));
        return dur >= advert.getDuration();
    };
    _proto.initialiseFromSession = function initialiseFromSession(url) {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
            _YoLog.YoLog.trace("sdk init");
            if (!(0, _HttpUtils.getUrl)(url)) {
                _this2.completeWithStatus(_Session2.SessionState.FAILED, _Session2.MALFORMED_URL);
                reject(_this2);
                return;
            }
            return _HttpConnection.HttpConnection.get(url, {
                method: "GET"
            }, _this2.sessionProperties.getRequestTimeout(), _this2.sessionProperties.getCustomHttpHeaders()).then(function(response) {
                if (response.ok) {
                    var contentType = response.headers.get("content-type");
                    if (contentType && contentType.toLowerCase().includes("application/json")) {
                        if (_this2.handleFallbackUrl(response.body)) resolve(_this2);
                        else reject(_this2);
                    } else {
                        var playerUrl = response.url ? response.url : url;
                        _this2.parseManifestResponse(response.body, playerUrl);
                        if (_this2.getSessionState() === _Session2.SessionState.INITIALISED) _this2.initialisePoller();
                        resolve(_this2);
                    }
                } else {
                    if (response.timeout) {
                        _YoLog.YoLog.e("Primary Url request failed: " + url + ", reason: timeout");
                        _this2.completeWithStatus(_Session2.SessionState.FAILED, _Session2.CONNECTION_TIMEOUT);
                    } else {
                        _YoLog.YoLog.e("Primary Url request failed: " + url + ", status: " + response.status + ", error: " + response.statusText);
                        _this2.completeWithStatus(_Session2.SessionState.FAILED, response.status);
                    }
                    reject(_this2);
                }
            });
        });
    };
    _proto.initialisePoller = function initialisePoller() {
        var _this3 = this;
        if (!this.getAnalyticsUrl() || this.getSessionState() !== _Session2.SessionState.INITIALISED) return;
        this.analyticPoller = new _UrlPoller.UrlPoller(this.getAnalyticsUrl(), this.getSessionProperties().getRequestTimeout(), function(response, retry) {
            if (response.status === 400) _this3.onSessionError(_Session2.SessionErrorCode.TIMEOUT);
            else if (response.ok) {
                _this3.targetDuration = retry;
                _this3.parseAnalyticPayload(response.body);
            }
        });
    };
    _proto.isMetadataInSequence = function isMetadataInSequence(current, next) {
        if (this.pendingTimedMetadata) {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "Pending metadata");
            return false;
        }
        return next.isInSequence(current);
    };
    _proto.onAdvertBreakEnd = function onAdvertBreakEnd() {
        if (!this.inAdBreak) return;
        var adbreak = this.getCurrentAdBreak();
        if (adbreak) {
            var report = adbreak.getTrackingReport("breakEnd", true);
            this.getReportsManager().fireBeacon(report, new _ReportsManager.ReportingParams(this.getPlayhead()));
        }
        this.inAdBreak = false;
        _YoLog.YoLog.trace("adbreakEnd");
        this.getReportsManager().raiseAdBreakCallback("end", null, this);
        if (this.trackingErrors.length > 0) this.getReportsManager().raiseSessionErrorCallback(_Session2.SessionErrorCode.TRACKING_ERROR, this);
        // remove ad break from array if necessary
        if (this.linearAdBreaks.length > 0) {
            this.linearAdBreaks.splice(0, 1);
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "Removed AdBreak.  Remaining: " + this.linearAdBreaks.length);
        }
        // reset data
        this.pendingTimedMetadata = null;
        this.historicalTimedMetadata = [];
        this.setCurrentAdvert(null);
        this.setCurrentAdBreak(null);
    };
    _proto.onAdvertBreakStart = function onAdvertBreakStart(advert) {
        var adBreak = this.getAdBreakForAdvert(advert);
        if (this.inAdBreak) {
            if (adBreak != null) {
                var report = adBreak.getTrackingReport("breakStart", !this.reportsManager.reportsSuppressed());
                this.getReportsManager().fireBeacon(report, new _ReportsManager.ReportingParams(this.getPlayhead()));
            }
            return;
        }
        this.inAdBreak = true;
        this.clearTrackingErrors();
        this.setCurrentAdBreak(adBreak);
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "AdBreak count: " + this.linearAdBreaks.length);
        _YoLog.YoLog.trace("adbreakStart");
        this.getReportsManager().raiseAdBreakCallback("start", adBreak, this);
        if (adBreak) {
            var _report = adBreak.getTrackingReport("breakStart", !this.reportsManager.reportsSuppressed());
            this.getReportsManager().fireBeacon(_report, new _ReportsManager.ReportingParams(this.getPlayhead()));
        }
    };
    _proto.onAdvertEnd = function onAdvertEnd(advertStatus) {
        if (!this.getCurrentAdvert()) return;
        // SDK-505: Cancel the advert watchdog if a new ad is not starting
        if (advertStatus !== AdvertStatus.NEW_ADVERT_STARTING) this.cancelScheduleWatchdog();
        else _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "onAdvertEnd(): new ad starting, not firing adbreak watchdog timer");
        if (advertStatus === AdvertStatus.PLAYED_OUT) this.signalTimelineTrackingEvents(this.getCurrentAdvert().getDuration());
        else this.getCurrentAdvert().clearTrackingSchedule();
        this.getCurrentAdvert().setInactive();
        // Notify listeners
        _YoLog.YoLog.trace("advertEnd");
        this.getReportsManager().raiseAdvertCallback("end", null, this);
        this.setCurrentAdvert(null);
        // If the current ad break is played out then signal onAdvertBreakEnd.  Otherwise, schedule it to signal when the belt and
        // braces timer expires
        if (!this.getCurrentAdBreak().isActive()) this.onAdvertBreakEnd();
        else // SDK-535: do this only if a new ad is not starting
        if (advertStatus !== AdvertStatus.NEW_ADVERT_STARTING) this.scheduleAdvertBreakEnd(this.interSegmentTimeout);
    };
    _proto.onAdvertStart = function onAdvertStart(advert, timestamp) {
        advert.setStart(timestamp);
        // end the current ad if there is one
        this.onAdvertEnd(AdvertStatus.NEW_ADVERT_STARTING);
        // If not in a break, start one
        this.onAdvertBreakStart(advert);
        // Update the current break in case the VAST wasn't available at the point the first ID3 appeared
        this.setCurrentAdBreak(this.getAdBreakForAdvert(advert));
        if (!this.getCurrentAdBreak()) {
            _YoLog.YoLog.e("*** AdBreak is null ***");
            return;
        }
        this.setCurrentAdvert(advert);
        _Session.prototype.onAdvertStart.call(this, advert);
        if (this.reportsManager.reportsSuppressed()) // clear the advert tracking map: do not fire beacons for partial adverts
        this.getCurrentAdvert().clearTrackingSchedule();
        _YoLog.YoLog.trace("advertStart");
        this.getReportsManager().raiseAdvertCallback("start", advert, this);
        // Fire impressions
        this.fireImpressionReport();
        // Signal any tracking events
        this.signalTimelineTrackingEvents(_Constant.Constant.ADVERT_START_TIMESLOT);
    };
    _proto.parseAnalyticPayload = function parseAnalyticPayload(data) {
        var _this4 = this;
        // Clear any errors encountered previously
        this.clearParsingErrors();
        return _Parser.Parser.parse(data, this).then(function(vmap) {
            if (_this4.parsingErrors.length > 0) _this4.getReportsManager().raiseSessionErrorCallback(_Session2.SessionErrorCode.PARSING_ERROR, _this4);
            if (!vmap) return null;
            if (_this4.getLastAnalyticUpdate() && vmap.isEqualTo(_this4.getLastAnalyticUpdate())) {
                _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, "Content unchanged.  Analytic update not delivered");
                return vmap;
            }
            var earlyReturn = vmap.getEarlyReturn();
            if (earlyReturn && earlyReturn !== -1) _this4.adjustForEarlyReturn(earlyReturn);
            _this4.setLastAnalyticUpdate(vmap);
            if (!vmap.hasAdBreaks()) {
                _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, "No ad breaks in payload");
                if (!_this4.playing) {
                    // Initial poll after playback ready
                    _YoLog.YoLog.trace("sdk analytics 0 0 0");
                    _this4.reportsManager.raiseAnalyticUpdateCallback(_this4);
                }
                return vmap;
            }
            _YoLog.YoLog.trace("sdk analytics: " + vmap.getLinearAdBreaks().length + " " + vmap.getNonLinearAdBreaks().length + " " + vmap.getDisplayAdBreaks().length);
            var notify = false;
            for(var _iterator3 = _createForOfIteratorHelperLoose(vmap.getLinearAdBreaks()), _step3; !(_step3 = _iterator3()).done;){
                var adbreak = _step3.value;
                if (adbreak.getAdverts().length === 0) {
                    // No adverts: just fire the ad break events (missed opportunity) then discard
                    var params = new _ReportsManager.ReportingParams(_this4.getPlayhead());
                    _this4.getReportsManager().fireBeacon(adbreak.getTrackingReport("breakStart", true), params);
                    _this4.getReportsManager().fireBeacon(adbreak.getTrackingReport("breakEnd", true), params);
                } else {
                    _this4.linearAdBreaks.push(adbreak);
                    notify = true;
                }
            }
            for(var _iterator4 = _createForOfIteratorHelperLoose(vmap.getNonLinearAdBreaks()), _step4; !(_step4 = _iterator4()).done;){
                var _adbreak = _step4.value;
                _this4.nonLinearAdBreaks.push(_adbreak);
                notify = true;
            }
            for(var _iterator5 = _createForOfIteratorHelperLoose(vmap.getDisplayAdBreaks()), _step5; !(_step5 = _iterator5()).done;){
                var _adbreak2 = _step5.value;
                _this4.displayAdBreaks.push(_adbreak2);
                notify = true;
            }
            // SDK-371 - send onAnalyticUpdate before handling pending metadata
            // SDK-1190 - don't raise analytic update if pending metadata exists
            if (notify && !_this4.pendingTimedMetadata) _this4.getReportsManager().raiseAnalyticUpdateCallback(_this4);
            if (_this4.pendingTimedMetadata) {
                _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "Process pending metadata: " + _this4.pendingTimedMetadata);
                var pending = _this4.pendingTimedMetadata;
                _this4.pendingTimedMetadata = null;
                _this4.onTimedMetadata(pending);
            }
            // Fire beacons for any historical adverts
            _this4.processHistoricalData();
            return vmap;
        })["catch"](function(err) {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_POLLING, "Analytic Poll completed with unreadable data: " + err);
            if (_this4.parsingErrors.length > 0) _this4.getReportsManager().raiseSessionErrorCallback(_Session2.SessionErrorCode.PARSING_ERROR, _this4);
        });
    };
    _proto.onPlaybackContinue = function onPlaybackContinue() {
        if (this.isPlaybackBuffering()) {
            if (this.getCurrentAdvert()) this.scheduleAdvertEnd();
            else // Don't schedule a watchdog timer if the session is not in an ad break
            if (this.getCurrentAdBreak()) this.scheduleAdvertBreakEnd(this.interSegmentTimeout);
        }
        _Session.prototype.onPlaybackContinue.call(this);
    };
    _proto.onPlaybackPause = function onPlaybackPause() {
        _Session.prototype.onPlaybackPause.call(this);
        // Prevent premature firing of watchdog.  Will be restarted when playback starts again
        this.cancelScheduleWatchdog();
    };
    _proto.onPlaybackReady = function onPlaybackReady() {
        // Handles any error messages
        _Session.prototype.onPlaybackReady.call(this);
        if (this.getSessionState() === _Session2.SessionState.INITIALISED && this.playing !== true) {
            if (this.analyticPoller) this.analyticPoller.request();
        }
    };
    _proto.onPlaybackResume = function onPlaybackResume() {
        if (this.isNotPlaying() && !this.isPlaybackBuffering()) {
            if (this.getCurrentAdvert()) this.scheduleAdvertEnd(null);
            else // Don't schedule a watchdog timer if the session is not in an ad break
            if (this.getCurrentAdBreak()) this.scheduleAdvertBreakEnd(this.interSegmentTimeout);
        }
        _Session.prototype.onPlaybackResume.call(this);
    };
    _proto.onPlaybackStall = function onPlaybackStall() {
        _Session.prototype.onPlaybackStall.call(this);
        // Prevent pramture firing of watchdog.  Will be restarted when buffering ends
        this.cancelScheduleWatchdog();
    };
    _proto.onPlaybackStart = function onPlaybackStart(playhead) {
        if (!this.isNotPlaying()) _YoLog.YoLog.w("Reporting START when start has already been reported");
        else if (this.getSessionState() !== _Session2.SessionState.INITIALISED) _YoLog.YoLog.w("Reporting START when session has not been initialised");
        else {
            _Session.prototype.onPlaybackStart.call(this, playhead);
            this.analyticPoller.start();
        }
    };
    _proto.onTimedMetadata = function onTimedMetadata(metadata) {
        _YoLog.YoLog.trace("timedmetadata " + metadata.getTypeWithinSegment().key + metadata.getSegmentNumber() + ":" + metadata.getSegmentCount() + " " + metadata.getPlayhead());
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "Received metadata: " + metadata + ", timestamp: " + metadata.getTimestamp());
        if (this.isPlaybackBuffering()) {
            _YoLog.YoLog.w("Playback buffering - should not be receiving timed metadata");
            return;
        }
        if (this.isNotPlaying()) {
            _YoLog.YoLog.w("Playback not playing - should not be receiving timed metadata");
            return;
        }
        // Reschedule the advert end watchdogs
        this.scheduleAdvertEnd(metadata);
        if (metadata.isDuplicate(this.lastTimedMetadata) || metadata.isDuplicate(this.pendingTimedMetadata)) {
            // This can happen as a result of a level switch and is therefore not a warning
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "Duplicate metadata: " + metadata);
            return;
        }
        // Find the relevant Advert
        var yospaceId = metadata.getMediaId();
        var advert = this.getFirstAdvertRemovingAllPrevious(yospaceId);
        if (!advert) {
            // Unknown advert
            if (metadata.isFirstInSequence()) {
                // This is the first TimedMetadata for the Advert.  Store it in case VAST is received
                // later during playback of the ad.
                // Note that the tag could be from filler, in which case (re)start the ad break end timer
                // to make sure it fires after the filler is finished.
                _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "FIRST pending metadata for advert " + yospaceId);
                this.pendingTimedMetadata = metadata;
                this.lastTimedMetadata = null;
                // Make a poll request to see whether VMAP can now be obtained
                if (this.analyticPoller) this.analyticPoller.request();
            } else if (metadata.isLastInSequence() && this.getSessionProperties().getFireHistoricalBeacons() && this.pendingTimedMetadata) {
                // This is the last TimedMetadata for the Advert: as long as the first metadata tag is received,
                // move it to the array of historicals so that if VAST subsequently arrives during this ad break
                // the Session can fire beacons on it.
                _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "LAST pending metadata for advert: " + yospaceId + " .  Moving to historical list");
                this.historicalTimedMetadata.push(this.pendingTimedMetadata);
                this.pendingTimedMetadata = null;
            }
            // Start an advert break if one is not active
            this.onAdvertBreakStart(null);
            return;
        }
        // A valid Advert is known at this point.  Check whether the TimedMetadata is in the expected sequence
        if (this.isMetadataInSequence(this.lastTimedMetadata, metadata)) {
            this.lastTimedMetadata = metadata;
            this.handleMetaDataInSequence(advert, metadata);
            return;
        }
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "Metadata out of sequence");
        this.pendingTimedMetadata = null;
        this.lastTimedMetadata = metadata;
        this.handleMetaDataOutOfSequence(advert, metadata);
    };
    _proto.parseManifestResponse = function parseManifestResponse(response, url) {
        var playlist = response;
        var payload = null;
        if (_HlsManifestParser.HlsManifestParser.isHlsManifest(playlist)) {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, "Processing HLS master playlist: " + url);
            payload = _HlsManifestParser.HlsManifestParser.parse(playlist);
        } else {
            // DASH
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, "Processing DASH manifest: " + url);
            payload = _DashManifestParser.DashManifestParser.parse(playlist);
        }
        if (!payload) {
            this.setPlaybackUrl(url);
            _YoLog.YoLog.w("Playlist/manifest processing unsuccesful");
            this.completeWithStatus(_Session2.SessionState.NO_ANALYTICS, _Session2.UNKNOWN_FORMAT);
        } else if ((0, _StringUtils.isNullOrEmpty)(payload.getAnalyticUrl())) {
            this.setPlaybackUrl(url);
            _YoLog.YoLog.w("Analytics URL not found in manifest payload");
            this.completeWithStatus(_Session2.SessionState.NO_ANALYTICS, 0);
        } else if (!(0, _HttpUtils.getUrl)(payload.getAnalyticUrl())) {
            this.setPlaybackUrl(url);
            _YoLog.YoLog.w("Malformed analytics URL in manifest payload");
            this.completeWithStatus(_Session2.SessionState.NO_ANALYTICS, _Session2.MALFORMED_URL);
        } else if ((0, _StringUtils.isNullOrEmpty)(payload.getPlaybackUrl())) {
            this.setPlaybackUrl(url);
            _YoLog.YoLog.w("Playback URL not found in manifest payload");
            this.completeWithStatus(_Session2.SessionState.NO_ANALYTICS, _Session2.MALFORMED_URL);
        } else {
            // Store the properties
            this.setPlaylistProperties(payload);
            this.interSegmentTimeout = payload.getIntersegmentTimeout();
            this.completeWithStatus(_Session2.SessionState.INITIALISED, 0);
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "Successful.  URL: " + this.getPlaybackUrl());
        }
    };
    _proto.processHistoricalData = function processHistoricalData() {
        var ab = this.getCurrentAdBreak();
        if (ab) for(var _iterator6 = _createForOfIteratorHelperLoose(this.historicalTimedMetadata), _step6; !(_step6 = _iterator6()).done;){
            var metadata = _step6.value;
            var yospaceId = metadata.getMediaId();
            var advert = ab.getAdvertFromIdentifier(yospaceId);
            if (advert) {
                _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_REPORTS, "Firing beacon for historical advert: " + yospaceId);
                var params = new _ReportsManager.ReportingParams(this.getPlayhead(), advert.getStart(), advert.getLinearCreative().getAssetUri(), advert.getMacroSubstitutions());
                var keys = [];
                for(var _iterator7 = _createForOfIteratorHelperLoose(advert.getTrackingSchedule()), _step7; !(_step7 = _iterator7()).done;){
                    var _step7$value = _step7.value, key = _step7$value[0], value = _step7$value[1];
                    keys.push(key);
                    var report = advert.getTrackingReportLinear(value);
                    if (report) {
                        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_REPORTS, "Firing beacon(s) for event: " + key);
                        this.getReportsManager().fireBeacon(report, params);
                    }
                }
                this.removeKeysFromTrackingSchedule(keys);
            }
        }
        this.historicalTimedMetadata = [];
    };
    _proto.scheduleAdvertBreakEnd = function scheduleAdvertBreakEnd(after) {
        this.cancelScheduleWatchdog();
        this.advertEndWatchdog = setTimeout(this.metadataWatchdogEndBreak.bind(this), after);
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "Scheduled adbreak end watchdog timer: " + after + "ms");
    };
    _proto.scheduleAdvertEnd = function scheduleAdvertEnd(metadata) {
        this.cancelScheduleWatchdog();
        var timeout = this.getMetadataTimeout(metadata);
        this.advertEndWatchdog = setTimeout(this.metadataWatchdog.bind(this), timeout);
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_STATE_MACHINE, "Scheduled advert end watchdog timer: " + timeout + "ms");
    };
    _proto.setTargetDuration = function setTargetDuration(duration) {
        this.targetDuration = duration;
    };
    _proto.shutdown = function shutdown() {
        _Session.prototype.shutdown.call(this);
        this.cancelScheduleWatchdog();
        // Due to JS "Run-to-completion", we don't expect any concurrency issues when shutting down and setting
        // the poller to null
        if (this.analyticPoller) {
            this.analyticPoller.shutdown();
            this.analyticPoller = null;
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "Analytic poller cancelled");
        }
    };
    _proto.setPlaylistProperties = function setPlaylistProperties(payload) {
        this.setIdentifier(payload.getSessionIdentifier());
        this.setAnalyticsUrl(payload.getAnalyticUrl());
        this.setPlaybackUrl(payload.getPlaybackUrl());
    };
    _proto.metadataWatchdog = function metadataWatchdog() {
        _YoLog.YoLog.w("Watchdog timer expired before metadata was received");
        if (this.pendingTimedMetadata) this.onAdvertBreakEnd();
        else this.onAdvertEnd(AdvertStatus.NOT_PLAYED_OUT);
    };
    _proto.metadataWatchdogEndBreak = function metadataWatchdogEndBreak() {
        _YoLog.YoLog.w("Watchdog timer expired before metadata was received");
        this.onAdvertBreakEnd();
    };
    return SessionLive;
}(_Session2.Session);

},{"a226736c49a6196e":"5j00o","856fa45bdea47487":"d1z2P","e9b7f89e187346ab":"4Kn9B","575d800c817291ed":"kKDLv","eafae3a0b533df99":"62muZ","4a5731b9b36b75ed":"9KS65","622d81d5865249ae":"7uXt7","bfcdee8ea9ba12ce":"kknG8","92c74c53e73a3030":"1BUXo","7778ff191b4e4b56":"50n6I","78942e8ef7f69bc7":"6cS9V","90ec3eeb633cb3f7":"2wJyf","5e41c312baf788de":"5HX1P","f737be785273c810":"iG6Z6"}],"f2Ak4":[function(require,module,exports) {
"use strict";
exports.__esModule = true;
exports.SessionVOD = void 0;
var _Event = require("5d5fe4b3731fee47");
var _YoLog = require("20c297aec04a9ec2");
var _Session = require("73da88de3877e630");
var _Parser = require("f976144d5cd72681");
var _StringUtils = require("848eb47b1d16b773");
var _PlaybackEventHandler = require("97b37274a4eca813");
var _HttpConnection = require("48ff94aab6a7f0c4");
var _HttpUtils = require("e5c5bba181916287");
var _SessionSeekable2 = require("840f0ca80726c434");
var _DefaultPlaybackPolicyHandler = require("a31b848474f5c5a");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
} /*
 * COPYRIGHT 2020-2023 YOSPACE TECHNOLOGIES LTD. ALL RIGHTS RESERVED.
 * The contents of this file are proprietary and confidential.
 * Unauthorised copying of this file, via any medium is strictly prohibited.
 */ 
// JsDoc/TS imports
var PATTERN_SCHEME = /(.+?:\/\/)/;
/**
 * Concrete Session implementation representing a single viewing of a single Video-on-Demand (VOD) stream sourced from
 * the Yospace Video Platform via the Yospace VOD access service
 * @see {@link Session} base class
 * @hideconstructor
 */ var SessionVOD = exports.SessionVOD = /*#__PURE__*/ function(_SessionSeekable) {
    _inheritsLoose(SessionVOD, _SessionSeekable);
    /**
   * @callback sessionCallback 
   * @param {SessionVOD} session a completed session object
   */ /**
   * The factory method for creating a SessionVOD instance. Constructs and initialises a new
   * SessionVOD instance using the {@link SessionProperties} provided. On completion invokes the
   * callback provided, passing back the initialised SessionVOD instance if a callback was provided.
   *
   * If a callback was not provided, a Promise is returned instead.
   *
   * @param {string} url The Yospace initialisation URL to the Central Streaming Manager
   * @param {SessionProperties} [properties] (Optional) An initialisation properties object
   * @param {sessionCallback} [callback] (Optional) A completion handler to call after initialisation is finished.
   */ SessionVOD.create = function create(url, properties, callback) {
        var session = new SessionVOD(properties);
        if (callback) return session.initialiseSession(url).then(function() {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "Session initialised");
        })["catch"](function() {
            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "Session failed to initialise");
        })["finally"](function() {
            callback(new _Event.Event(session));
        });
        else return session.initialiseSession(url);
    };
    function SessionVOD(properties) {
        var _this;
        _this = _SessionSeekable.call(this, properties) || this;
        _this.setPlaybackPolicyHandler(new _DefaultPlaybackPolicyHandler.DefaultPlaybackPolicyHandler(_Session.PlaybackMode.VOD));
        return _this;
    }
    /**
   * Provides a relative content playhead position to the client, discounting the sum of all ad break
   * durations prior to the absolute playhead position provided. This allows the client to return
   * to the same content position if a VOD stream is stopped before playback ends.
   *
   * @param {number} playhead the absolute playhead position, in milliseconds
   * @return {number} the relative content position, in milliseconds
   * @see {@link SessionVOD}.getPlayheadForContentPosition()
   */ var _proto = SessionVOD.prototype;
    _proto.getContentPositionForPlayhead = function getContentPositionForPlayhead(playhead) {
        if (this.duration === 0 || playhead === 0) return 0;
        if (this.linearAdBreaks.length === 0) return playhead;
        // Adjust playhead to end of break if playhead is within a break
        for(var _iterator = _createForOfIteratorHelperLoose(this.linearAdBreaks), _step; !(_step = _iterator()).done;){
            var ab = _step.value;
            if (ab.getStart() <= playhead && playhead < ab.getStart() + ab.getDuration()) {
                playhead = ab.getStart() + ab.getDuration();
                break;
            }
        }
        var index = 0;
        var contentPlayhead = playhead;
        while(index < this.linearAdBreaks.length && this.linearAdBreaks[index].getStart() < playhead)contentPlayhead -= this.linearAdBreaks[index++].getDuration();
        return contentPlayhead;
    };
    _proto.getPlaybackMode = function getPlaybackMode() {
        return _Session.PlaybackMode.VOD;
    } /**
   * Provides an absolute playhead position to the client calculating the sum of all ad break durations
   * prior to that absolute playhead position plus the relative content playhead position.
   * This allows the client to return to the same content position if a VOD stream is stopped
   * before playback ends.
   *
   * @param {number} position the relative content position, in milliseconds
   * @return {number} the absolute playhead position, in milliseconds
   * @see {@link SessionVOD}.getContentPositionForPlayhead()
   */ ;
    _proto.getPlayheadForContentPosition = function getPlayheadForContentPosition(position) {
        if (this.linearAdBreaks.length === 0) return position;
        var index = 0;
        while(index < this.linearAdBreaks.length && this.linearAdBreaks[index].getStart() <= position)position += this.linearAdBreaks[index++].getDuration();
        return position;
    };
    _proto.initialiseSession = function initialiseSession(url) {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
            _YoLog.YoLog.trace("sdk init");
            if (!(0, _HttpUtils.getUrl)(url)) {
                _this2.completeWithStatus(_Session.SessionState.FAILED, _Session.MALFORMED_URL);
                reject(_this2);
                return;
            }
            // Request the access URL
            return _HttpConnection.HttpConnection.get(url, {
                method: "GET"
            }, _this2.sessionProperties.getRequestTimeout(), _this2.sessionProperties.getCustomHttpHeaders()).then(function(response) {
                if (response.ok) {
                    var contentType = response.headers.get("content-type");
                    if (contentType && contentType.toLowerCase().includes("application/json")) {
                        if (_this2.handleFallbackUrl(response.body)) resolve(_this2);
                        else reject(_this2);
                    } else // Parse the VMAP response
                    return _Parser.Parser.parse(response.body, _this2).then(function(vmapResponse) {
                        if (!vmapResponse || vmapResponse.getStreamDuration() === 0 || (0, _StringUtils.isNullOrEmpty)(vmapResponse.getHostNode() || (0, _StringUtils.isNullOrEmpty)(vmapResponse.getHostSuffix()))) {
                            _this2.setPlaybackUrl(url);
                            _this2.logVmapParseWarning(vmapResponse);
                            if (!vmapResponse) {
                                _this2.completeWithStatus(_Session.SessionState.NO_ANALYTICS, _Session.UNKNOWN_FORMAT);
                                resolve(_this2);
                            } else {
                                _this2.completeWithStatus(_Session.SessionState.NO_ANALYTICS, 0);
                                resolve(_this2);
                            }
                        } else if (vmapResponse.getHasPlaceholder()) {
                            _this2.handlePlaceholderBreaks(vmapResponse, url);
                            _this2.completeWithStatus(_Session.SessionState.INITIALISED, _Session.PARTIAL_VMAP);
                            resolve(_this2);
                        } else {
                            // Set the session properties
                            _this2.initialiseFromAnalyticData(vmapResponse, _this2.findScheme(url));
                            _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, vmapResponse.toString());
                            _this2.completeWithStatus(_Session.SessionState.INITIALISED, 0);
                            resolve(_this2);
                        }
                    });
                } else {
                    _YoLog.YoLog.e("VMAP request failed.  URL: " + url + ", status: " + response.status + ", error: " + response.statusText);
                    _this2.completeWithStatus(_Session.SessionState.FAILED, response.status);
                    reject(_this2);
                }
            });
        });
    };
    _proto.logVmapParseWarning = function logVmapParseWarning(vmapResponse) {
        var warning = "Unable to parse VMAP data.\n - Stream duration: " + (vmapResponse ? vmapResponse.getStreamDuration() : "null") + "\n - Host node: " + (vmapResponse ? vmapResponse.getHostNode() : "null") + "\n - Host suffix: " + (vmapResponse ? vmapResponse.getHostSuffix() : null);
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, warning);
    };
    _proto.findScheme = function findScheme(url) {
        if (PATTERN_SCHEME.exec(url)) {
            var arr = PATTERN_SCHEME.exec(url);
            return arr[1];
        } else {
            _YoLog.YoLog.w("Unable to match scheme in primary URL.  Assuming http://");
            return "http://";
        }
    };
    _proto.handlePlaceholderBreaks = function handlePlaceholderBreaks(vmapResponse, url) {
        var _this3 = this;
        _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_LIFECYCLE, "Found partial VMAP");
        this.initialiseFromAnalyticData(vmapResponse, this.findScheme(url), true);
        var abs = vmapResponse.getLinearAdBreaks();
        // This isn't expected to happen and is intended for future-proofing in the event of changes elsewhere
        if (!abs.length) {
            _YoLog.YoLog.e("Fulfilment payload contains no breaks");
            this.onSessionError(_Session.SessionErrorCode.UNRESOLVED_BREAK);
            return;
        }
        // For VOD, all followup URLs are the same so just take the last one
        var followupUrl = abs[abs.length - 1].getAdTagUri();
        if (!(0, _HttpUtils.getUrl)(followupUrl)) {
            _YoLog.YoLog.e("Fulfilment payload followup URL is not valid: " + followupUrl);
            this.onSessionError(_Session.SessionErrorCode.UNRESOLVED_BREAK);
            return;
        }
        // Call out and amalgamate the partial vmap data
        return _HttpConnection.HttpConnection.get(followupUrl, {
            method: "GET"
        }, this.sessionProperties.getRequestTimeout(), this.sessionProperties.getCustomHttpHeaders()).then(function(response) {
            if (response.ok) return _Parser.Parser.parse(response.body, _this3, {
                skipNormalisation: true
            }).then(function(vmapResponse) {
                if (_this3.parsingErrors.length > 0) _this3.getReportsManager().raiseSessionErrorCallback(_Session.SessionErrorCode.PARSING_ERROR, _this3);
                if (vmapResponse) {
                    if (_this3.mergePlaceholderBreaks(vmapResponse)) {
                        if (_this3.reportsManager) _this3.reportsManager.raiseAnalyticUpdateCallback(_this3);
                    } else {
                        _YoLog.YoLog.e("Fulfilment payload could not be merged");
                        _this3.onSessionError(_Session.SessionErrorCode.UNRESOLVED_BREAK);
                    }
                    _YoLog.YoLog.d(_YoLog.DebugFlags.DEBUG_PARSING, vmapResponse.toString());
                } else {
                    _YoLog.YoLog.e("Fulfilment payload could not be parsed");
                    _this3.onSessionError(_Session.SessionErrorCode.UNRESOLVED_BREAK);
                }
            });
            else {
                _YoLog.YoLog.e("Fulfilment payload request failed: " + response.statusText);
                _this3.onSessionError(_Session.SessionErrorCode.UNRESOLVED_BREAK);
            }
        });
    };
    _proto.onPlayerEvent = function onPlayerEvent(event, playhead) {
        // Playback state has changed
        // Any non-linear playhead change must set this.didSeek
        if (event === _PlaybackEventHandler.PlayerEvent.SEEK || event === _PlaybackEventHandler.PlayerEvent.ADVERT_SKIP || event === _PlaybackEventHandler.PlayerEvent.ADVERT_REWIND) this.didSeek = true;
        _SessionSeekable.prototype.onPlayerEvent.call(this, event, playhead);
    };
    _proto.onPlayheadUpdate = function onPlayheadUpdate(playhead) {
        this.handleHeartbeat(playhead);
        _SessionSeekable.prototype.onPlayheadUpdate.call(this, playhead);
    } /**
   * Sets all adverts inactive in all ad breaks prior to the given playhead position. If the playhead
   * is within an advert then that advert is NOT marked as inactive. This method allows client applications
   * to seek to a position before playback begins.
   *
   * @param {number} playhead the playhead position
   */ ;
    _proto.setAdBreaksInactivePriorTo = function setAdBreaksInactivePriorTo(playhead) {
        _SessionSeekable.prototype.setAdBreaksInactivePriorTo.call(this, playhead);
    };
    _proto.setDuration = function setDuration(duration) {
        this.duration = duration;
    };
    return SessionVOD;
}(_SessionSeekable2.SessionSeekable);

},{"5d5fe4b3731fee47":"kKDLv","20c297aec04a9ec2":"9KS65","73da88de3877e630":"62muZ","f976144d5cd72681":"iG6Z6","848eb47b1d16b773":"7uXt7","97b37274a4eca813":"cPeeN","48ff94aab6a7f0c4":"6cS9V","e5c5bba181916287":"2wJyf","840f0ca80726c434":"6uJDY","a31b848474f5c5a":"4Kn9B"}],"kOYtJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseYospaceID3Tag", ()=>parseYospaceID3Tag);
const parseYospaceID3Tag = (id3DataArray)=>{
    let rawTag = "";
    id3DataArray.forEach((charCode)=>{
        const char = String.fromCharCode(charCode);
        rawTag += char;
    });
    if (!rawTag.includes("YMID")) return null;
    const tagChars = rawTag.replace(/[^a-zA-z0-9.:]/g, "");
    const yospaceAttributes = {
        _empty: "",
        YMID: "",
        YSEQ: "",
        YTYP: "",
        YDUR: "",
        YCSP: "",
        YPRG: ""
    };
    let idx = 0;
    let currentYTag = "_empty";
    while(idx < tagChars.length){
        // eslint-disable-next-line no-restricted-syntax
        for (const yTag of Object.keys(yospaceAttributes))if (tagChars.slice(idx, idx + yTag.length) === yTag) {
            currentYTag = yTag;
            idx += yTag.length;
        }
        yospaceAttributes[currentYTag] += tagChars[idx];
        idx += 1;
    }
    return {
        attributes: yospaceAttributes,
        adData: {
            adId: yospaceAttributes.YMID,
            currentFragNumberInAd: Number(yospaceAttributes.YSEQ.split(":")[0]) || -1,
            totalFragsInAd: Number(yospaceAttributes.YSEQ.split(":")[1]) || -1,
            tagStartTimeInFrag: Number(yospaceAttributes.YDUR) || -1,
            tagPositionInFrag: yospaceAttributes.YTYP
        }
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"albJk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _defineProperty = require("@swc/helpers/_/_define_property");
var _objectSpread = require("@swc/helpers/_/_object_spread");
var _objectSpreadProps = require("@swc/helpers/_/_object_spread_props");
var _youboralib = require("youboralib");
var _youboralibDefault = parcelHelpers.interopDefault(_youboralib);
var _nineStore = require("../helpers/nine-store");
var _messengers = require("../helpers/Messengers");
var _customNpawAampAdapter = require("./custom-npaw-aamp-adapter");
var _nineProgramTracker = require("../nine-services/nine-program-tracker");
const AppVersion = (0, _nineStore.Store).appVersion;
class NpawClient {
    constructor(){
        (0, _defineProperty._)(this, "plugin", void 0);
        (0, _defineProperty._)(this, "listeners", []);
        (0, _defineProperty._)(this, "contentCdn", void 0);
        (0, _defineProperty._)(this, "init", ()=>{
            this.removeListeners(); // remove in case monitoringTeardown isn't called
            const useProd = (0, _nineStore.Store).useProdConfig;
            const accountCode = useProd ? "nine" : "ninedev";
            const config = {
                accountCode,
                "background.enabled": true,
                "app.name": "ctv_foxtel_mle",
                "app.releaseVersion": AppVersion
            };
            (0, _youboralibDefault.default).adapters.AAMP = (0, _customNpawAampAdapter.customAAMPAdapter);
            this.plugin = new (0, _youboralibDefault.default).Plugin(config);
            // youbora.Log.logLevel = youbora.Log.Level.DEBUG;
            console.log("[acc] NPAW: configured", config);
            this.addListeners();
        });
        (0, _defineProperty._)(this, "addListeners", ()=>{
            this.listeners = [
                ...this.listeners,
                (0, _messengers.Messengers).streamReady$.addReceiver(this.onChannelDataReceived, true),
                (0, _messengers.Messengers).programChange$.addReceiver(this.updateNpawProperties),
                (0, _messengers.Messengers).appTeardown$.addReceiver(this.onAppTeardown),
                (0, _messengers.Messengers).playerError$.addReceiver(this.onPlayerError)
            ];
        });
        (0, _defineProperty._)(this, "removeListeners", ()=>{
            this.listeners.forEach((receiver)=>receiver.unlisten());
            this.listeners = [];
        });
        (0, _defineProperty._)(this, "onAppTeardown", ()=>{
            this.onPlayerDestroy();
            this.removeListeners();
            this.plugin = null;
        });
        /**
     * Update plugin with adapter to use for the currently playing video.
     */ (0, _defineProperty._)(this, "onPlayerInit", ()=>{
            this.plugin.enable();
            const adapter = new (0, _youboralibDefault.default).adapters.AAMP();
            adapter.setIsLive(true);
            this.plugin.setAdapter(adapter);
            // do play event as soon as we have channel
            // data and an adapter ready
            adapter.playListener();
        });
        /**
     * Remove player adapter when playback has ended.
     */ (0, _defineProperty._)(this, "onPlayerDestroy", ()=>{
            this.plugin.removeAdapter();
            this.plugin.disable();
        });
        (0, _defineProperty._)(this, "updateNpawProperties", (channelData)=>{
            if (!channelData) return;
            if (!this.contentCdn) {
                var _channelData_stream;
                const streamUrl = ((_channelData_stream = channelData.stream) === null || _channelData_stream === void 0 ? void 0 : _channelData_stream.url) || "";
                const urlQuery = new URLSearchParams(streamUrl);
                // yo.ap or yo.up value reveals underlying cdn
                // akamai value https://p-9now-ys-v2.akamaized.net/
                // cloudfront value https://livestream-cdn.9vms.com.au/
                let cdnValue = "";
                const yoApValue = urlQuery.get("yo.ap");
                const yoUpValue = urlQuery.get("yo.up");
                const akamaiString = "akamaized.net";
                const cloudfrontString = "livestream-cdn.9vms.com.au";
                if ((yoApValue === null || yoApValue === void 0 ? void 0 : yoApValue.includes(akamaiString)) || yoApValue === "https" || (yoUpValue === null || yoUpValue === void 0 ? void 0 : yoUpValue.includes(akamaiString)) || yoUpValue === "https") // special 'https' value means akamai for legacy uplift
                cdnValue = "AKAMAI";
                else if ((yoApValue === null || yoApValue === void 0 ? void 0 : yoApValue.includes(cloudfrontString)) || (yoUpValue === null || yoUpValue === void 0 ? void 0 : yoUpValue.includes(cloudfrontString))) cdnValue = "CLOUDFRT";
                else if (streamUrl.includes(akamaiString)) cdnValue = "AKAMAI";
                else if (streamUrl.includes(cloudfrontString)) cdnValue = "CLOUDFRT";
                // fallback to yoApValue because for debugging in case unexpected values
                // come through
                this.contentCdn = {
                    "content.cdn": cdnValue || yoApValue || "<unknown>"
                };
            }
            const program = (0, _nineProgramTracker.getActiveListing)(channelData);
            const nuid = (0, _nineStore.Store).nuid;
            const platformString = (0, _nineStore.Store).devicePlatform.toLowerCase() === "soip-pck" ? "PUCK" : "TV";
            var _channelData_referenceId, _channelData_referenceId1;
            this.plugin.setOptions((0, _objectSpreadProps._)((0, _objectSpread._)({
                "content.isLive": true,
                "content.playbackType": "live",
                "content.title": program === null || program === void 0 ? void 0 : program.name,
                "content.channel": (_channelData_referenceId = channelData.referenceId) !== null && _channelData_referenceId !== void 0 ? _channelData_referenceId : "",
                "content.id": (_channelData_referenceId1 = channelData.referenceId) !== null && _channelData_referenceId1 !== void 0 ? _channelData_referenceId1 : "",
                "content.type": "channel"
            }, this.contentCdn), {
                // If there are less than 20 custom dimensions
                // we should pass each as a dimension with a magic number on
                // it
                "content.customDimension.1": (0, _messengers.Messengers).oztamSessionId$.getCurrentValue(),
                "content.customDimension.6": (0, _nineStore.Store).getOztamVendorVersion(),
                "content.customDimension.5": "live_page",
                "content.customDimension.2": String(false),
                "content.customDimension.3": String(!!channelData.ssai),
                "user.name": nuid !== null && nuid !== void 0 ? nuid : "",
                "user.type": nuid ? "registered" : "unregistered",
                // hardcode to get around npaw library bug
                "content.streamingProtocol": "HLS",
                "device.code": `HUBBL_${platformString}`,
                "device.type": platformString === "TV" ? "TV" : "STB",
                // will show as Device Vendor on back-end
                "device.brand": "Foxtel"
            }));
        });
        /**
     * Update plugin with data of the currently playing video.
     */ (0, _defineProperty._)(this, "onChannelDataReceived", (channelData)=>{
            if (!channelData) return;
            // reset in case cdn changes across channels
            this.contentCdn = null;
            this.updateNpawProperties(channelData);
            this.onPlayerInit();
        });
        /**
     * Emit player error events manually. Do not add error listeners in npaw
     * adapter because aamp only emits fatal errors to us.
     */ (0, _defineProperty._)(this, "onPlayerError", (errorData)=>{
            var _errorData_detail, _errorData_detail1;
            const errorMessage = (errorData === null || errorData === void 0 ? void 0 : (_errorData_detail = errorData.detail) === null || _errorData_detail === void 0 ? void 0 : _errorData_detail.description) || "PLAY FAILURE"; // default from Npaw
            const errorCode = (errorData === null || errorData === void 0 ? void 0 : (_errorData_detail1 = errorData.detail) === null || _errorData_detail1 === void 0 ? void 0 : _errorData_detail1.code) || "<unknown>";
            // assume error is always fatal
            this.plugin.fireFatalError(errorCode, errorMessage);
            this.onPlayerDestroy();
        });
    }
}
exports.default = new NpawClient();

},{"@swc/helpers/_/_define_property":"9kWBJ","@swc/helpers/_/_object_spread":"lupAG","@swc/helpers/_/_object_spread_props":"8Y68S","youboralib":"k8N3l","../helpers/nine-store":"d7nPH","../helpers/Messengers":"48YTm","./custom-npaw-aamp-adapter":"6TsZp","../nine-services/nine-program-tracker":"cxKPT","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"k8N3l":[function(require,module,exports) {
// No-Conflict
var previousYoubora = youbora // eslint-disable-line no-use-before-define
;
var youbora = {};
/**
 * This allows you to run multiple instances of YouboraLib on the same webapp.
 * After loading the new version, call `noConflict()` to get a reference to it.
 * At the same time the old version will be returned to Youbora.
 */ youbora.noConflict = function() {
    youbora = previousYoubora;
    return this;
};
// Info
youbora.VERSION = require("1bc6e992c196e0b9");
// Polyfills
youbora.polyfills = require("f08bfc61891dc058");
youbora.polyfills();
// Base Classes
youbora.Object = require("90cb6602d935f8cb");
youbora.Emitter = require("7d9113decf6fee4c");
// Log
youbora.Log = require("e0a816f7122c8349");
youbora.Log.loadLevelFromUrl();
// General classes
youbora.Util = require("dc305f28b3bd9160");
youbora.HybridNetwork = require("dc707a3a6e2e59b0");
youbora.Chrono = require("5cae036fc3a0ca30");
youbora.Timer = require("5518874e799207c3");
youbora.Constants = require("bae6721161071766");
// Comm classes
youbora.Request = require("ba53eb90247b0460");
youbora.Communication = require("972688152c143f76");
// Resource Transform classes
youbora.Transform = require("8f44a23398e6bfb");
youbora.ViewTransform = require("3226b5f7d8984966");
youbora.ResourceTransform = require("368b1a48500f6fe6");
youbora.CdnParser = require("baf6ac8e23c0ed87");
youbora.HlsParser = require("50e30e1617327d0b");
youbora.DashParser = require("73d933e3360b0904");
youbora.OfflineParser = require("127991abf9e6d634");
youbora.LocationheaderParser = require("c0437cd6e5db0ed4");
// Plugin Classes
youbora.Options = require("d766cc0093775165");
youbora.Plugin = require("218535623bf7e5e0");
youbora.Storage = require("d9d216e2e5e079e");
youbora.RequestBuilder = require("fe7f7102ff17cdf5");
// Adapters
youbora.PlayheadMonitor = require("ff6d5bca8370865b");
youbora.Adapter = require("62e0d8158c3372aa");
youbora.adapters = {};
// Infinity
youbora.Infinity = require("71d1cb2c399d8415");
// Detector classes
youbora.BackgroundDetector = require("e93e33b15ddaabe7");
youbora.DeviceDetector = require("500fef9149606a77");
youbora.UUIDGenerator = require("7018f23ea5703b69");
/**
 * Register the given adapter in <youbora>.adapters.
 *
 * @param {string} key Unique adapter identifier.
 * @param {youbora.Adapter} Adapter Adapter class.
 *
 * @memberof youbora
 */ youbora.registerAdapter = (function(key, Adapter) {
    this.adapters[key] = Adapter;
}).bind(youbora);
/**
 * Remove the given adapter in <youbora>.adapters.
 *
 * @param {string} key Unique adapter identifier.
 *
 * @memberof youbora
 */ youbora.unregisterAdapter = (function(key) {
    this.adapters[key] = null;
}).bind(youbora);
module.exports = youbora;

},{"1bc6e992c196e0b9":"bsoIP","f08bfc61891dc058":"2syLH","90cb6602d935f8cb":"j7KrE","7d9113decf6fee4c":"cuYJd","e0a816f7122c8349":"8xsxZ","dc305f28b3bd9160":"drhpF","dc707a3a6e2e59b0":"395SH","5cae036fc3a0ca30":"6HP4E","5518874e799207c3":"cqNVd","bae6721161071766":"92xpS","ba53eb90247b0460":"6hKtj","972688152c143f76":"bOkDM","8f44a23398e6bfb":"8oBJA","3226b5f7d8984966":"hugd5","368b1a48500f6fe6":"3JgT9","baf6ac8e23c0ed87":"dslIv","50e30e1617327d0b":"4m7oU","73d933e3360b0904":"8Pt5M","127991abf9e6d634":"9eqxK","c0437cd6e5db0ed4":"i5KqT","d766cc0093775165":"f2zFO","218535623bf7e5e0":"2BjVJ","d9d216e2e5e079e":"9mqvX","fe7f7102ff17cdf5":"fouWB","ff6d5bca8370865b":"6a8xK","62e0d8158c3372aa":"7AnqL","71d1cb2c399d8415":"7fbyw","e93e33b15ddaabe7":"eFDAY","500fef9149606a77":"32dVf","7018f23ea5703b69":"7v7Id"}],"bsoIP":[function(require,module,exports) {
module.exports = require("197984af627a7b57").version;

},{"197984af627a7b57":"2VsLu"}],"2VsLu":[function(require,module,exports) {
module.exports = JSON.parse('{"name":"youboralib","type":"lib","tech":"js","author":"Nice People At Work","version":"6.8.54","built":"2024-04-05","repo":"https://bitbucket.org/npaw/lib-plugin-js.git"}');

},{}],"2syLH":[function(require,module,exports) {
/* eslint no-extend-native: "off" */ /**
 * When executed, this function applies polyfills to the following functionalities:
 * Function.prototype.bind and
 * Array.prototype.forEach.
 *
 * @memberof youbora
 */ var applyPolyfills = function() {
    // Bind, changed for compatibility
    Function.prototype.bind = Function.prototype.bind || function(context) {
        var slice = Array.prototype.slice;
        var func = this;
        var args = slice.call(arguments, 1);
        function bound() {
            var invokedAsConstructor = func.prototype && this instanceof func;
            return func.apply(!invokedAsConstructor && context || this, args.concat(slice.call(arguments)) // eslint-disable-line no-mixed-operators
            );
        }
        bound.prototype = func.prototype;
        return bound;
    };
    // Foreach
    Array.prototype.forEach = Array.prototype.forEach || function(callback, thisArg) {
        if (typeof callback !== "function") throw new TypeError(callback + " is not a function!");
        var len = this.length;
        for(var i = 0; i < len; i++)callback.call(thisArg, this[i], i, this);
    };
    // Trunc
    Math.trunc = Math.trunc || function(x) {
        if (isNaN(x)) return NaN;
        if (x > 0) return Math.floor(x);
        return Math.ceil(x);
    };
};
module.exports = applyPolyfills;

},{}],"j7KrE":[function(require,module,exports) {
var assign = require("3fd7fe930adf8f04");
var createObject = require("3d39f7340a8c7ade");
var YouboraObject = function() {};
YouboraObject.prototype = {
    /**
   * A base class that other Classes should inherit from.
   * It has a no-op constructor intended to be overridden by classes that extend from this.
   *
   * @constructs YouboraObject
   * @abstract
   * @memberof youbora
   */ constructor: function() {}
};
/**
 * This method allows the extension of the current class, emulating 1-level inheritance.
 * It is inspired by Backbone's extend, but removing all references to underscore.
 *
 * @see http://backbonejs.org/#Model-extend
 *
 * @example
 * var A = YouboraObject.extend({ a: 1, b: 1, c: { d: 0 } });
 * var a = new A(); // { a: 1, b: 1, c: { d: 0 } }
 *
 * var B = A.extend({ b: 2, c: { e: 3 } });
 * var b = new B(); // { a: 1, b: 2, c: { e: 3 } }
 *
 * @param  {Object} protoProps  Prototype properties (available on the instances)
 * @param  {Object} staticProps Static properties (available on the contructor)
 * @return {Object}             New sub class
 */ YouboraObject.extend = function(protoProps, staticProps) {
    var parent = this;
    var child;
    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent constructor.
    if (protoProps && protoProps.hasOwnProperty("constructor")) child = protoProps.constructor;
    else child = function() {
        return parent.apply(this, arguments);
    };
    // Add static properties to the constructor function, if supplied.
    assign(child, parent, staticProps);
    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function and add the prototype properties.
    child.prototype = createObject(parent.prototype);
    if (protoProps) assign(child.prototype, protoProps);
    child.prototype.constructor = child;
    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;
    return child;
};
module.exports = YouboraObject;

},{"3fd7fe930adf8f04":"i2p6U","3d39f7340a8c7ade":"iBHjc"}],"i2p6U":[function(require,module,exports) {
/**
 * See Object.assign.
 *
 * @memberof youbora.Util
 */ module.exports = function(target) {
    if (target === undefined || target === null) throw new TypeError("Cannot convert undefined or null to object");
    var output = Object(target);
    for(var index = 1; index < arguments.length; index++){
        var source = arguments[index];
        if (source !== undefined && source !== null) {
            for(var nextKey in source)if (source.hasOwnProperty(nextKey)) output[nextKey] = source[nextKey];
        }
    }
    return output;
};

},{}],"iBHjc":[function(require,module,exports) {
var F = function() {};
/** See Object.create. */ module.exports = function(o) {
    if (arguments.length > 1) throw Error("Second argument not supported");
    if (o === null) throw Error("Cannot set a null [[Prototype]]");
    if (typeof o !== "object") throw TypeError("Argument must be an object");
    F.prototype = o;
    return new F();
};

},{}],"cuYJd":[function(require,module,exports) {
var YouboraObject = require("dde5fc718f57d012");
var isArray = require("f77656661710df9a");
/**
 * This class extends YouboraObject, adding event emitting/listening functionalities.
 *
 * @constructs Emitter
 * @extends youbora.YouboraObject
 * @memberof youbora
 */ var Emitter = YouboraObject.extend(/** @lends youbora.Emitter.prototype */ {
    /**
     * Sets a listener to a given event. Use {@link emit} to trigger those events.
     * Pass '*' to listen ALL events.
     *
     * @param {string} event Name of the event.
     * @param {function} callback Callback of the event. Receives event and data.
     * @return this
     */ on: function(event, callback) {
        this._listeners = this._listeners || {};
        if (typeof callback === "function") {
            this._listeners[event] = this._listeners[event] || [];
            this._listeners[event].push(callback);
            return this;
        }
    },
    /**
     * Removes given callback from the listeners of this object.
     *
     * @param {string} event Name of the event.
     * @param {function} callback Callback of the event.
     * @return this
     */ off: function(event, callback) {
        this._listeners = this._listeners || {};
        if (this._listeners[event]) {
            var index = this._listeners[event].indexOf(callback);
            if (index !== -1) this._listeners[event].splice(index, 1);
        }
        return this;
    },
    /**
     * Emits given event, triggering all the associated callbacks.
     *
     * @param {string} event Name of the event.
     * @param {object} [data] Custom data to be sent to the callbacks.
     * @return this
     */ emit: function(event, data) {
        this._listeners = this._listeners || {};
        data = data || {};
        if (isArray(this._listeners[event])) this._listeners[event].forEach(this._eachCallback.bind(this, event, data));
        if (isArray(this._listeners["*"])) this._listeners["*"].forEach(this._eachCallback.bind(this, event, data));
        return this;
    },
    /**
     * Travels through the listener list and executes them them.
     *
     * @private
     */ _eachCallback: function(event, data, callback) {
        if (typeof callback === "function") {
            var callbackArguments = {
                type: event,
                data: data,
                target: this
            };
            callback(callbackArguments);
        }
    }
});
module.exports = Emitter;

},{"dde5fc718f57d012":"j7KrE","f77656661710df9a":"egFaS"}],"egFaS":[function(require,module,exports) {
/**
 * See Array.isArray.
 * @memberof youbora.Util
 */ module.exports = function(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
};

},{}],"8xsxZ":[function(require,module,exports) {
var Emitter = require("3b53aed2141933f5");
var isArray = require("c7d7a0a603fb31f3");
/**
 * Static Log class for YouboraLib
 *
 * @class
 * @static
 * @memberof youbora
 */ var Log = {
    _emitter: new Emitter(),
    /** Exposes {@link youbora.EvenfulObject.on} */ on: function() {
        Log._emitter.on.apply(Log._emitter, arguments);
    },
    /** Exposes {@link youbora.EvenfulObject.off} */ off: function() {
        Log._emitter.off.apply(Log._emitter, arguments);
    },
    /** Exposes {@link youbora.EvenfulObject.emit} */ emit: function() {
        Log._emitter.emit.apply(Log._emitter, arguments);
    },
    /**
   * Enum for log levels
   * @enum
   */ Level: {
        /** No console outputs */ SILENT: 6,
        /** Console will show errors */ ERROR: 5,
        /** Console will show warnings */ WARNING: 4,
        /** Console will show notices (ie: life-cyrcle logs) */ NOTICE: 3,
        /** Console will show debug messages (ie: player events) */ DEBUG: 2,
        /** Console will show verbose messages (ie: Http Requests) */ VERBOSE: 1
    },
    /**
   * Enum for events
   * @enum
   */ Event: {
        /** Sent each time a messaged is issued, even if log level does not handle it. */ LOG: "log"
    },
    /**
   * Only logs of this imporance or higher will be shown.
   * @default youbora.Log.Levels.ERROR
   * @see {@link youbora.Log.Levels}
   */ logLevel: 5,
    /**
   * If true, console logs will always be outputed without colors (for debbugin in devices).
   * @default false
   */ plainLogs: false,
    /**
   * Returns a console message
   *
   * @private
   * @param {(string|error|array)} msg Message string, error object or array of messages.
   * @param {Log.Levels} [level=Log.Levels.NOTICE] Defines the level of the error sent.
   * Only errors with higher or equal level than Log.logLevel will be displayed.
   * @param {string} [color=darkcyan] Color of the header
   * @see {@link Youbora.Log.debugLevel}
   */ report: function(msg, level, color) {
        if (typeof console !== "undefined" && console.log && typeof document !== "undefined") {
            level = level || Log.Level.NOTICE;
            color = color || "darkcyan";
            var letters = {
                5: "e",
                4: "w",
                3: "n",
                2: "d",
                1: "v" // Verbose
            };
            var letter = letters[level];
            var prefix = "[Youbora]" + Log._getCurrentTime() + " " + letter + ":";
            this.emit("log", {
                level: level,
                msg: msg,
                prefix: prefix
            });
            // Show messages in actual console if level is enought
            if (Log.logLevel <= level) {
                if (Log.plainLogs || document.documentMode) // Plain log for IE and devices
                Log._plainReport(msg, prefix);
                else {
                    // choose log method
                    var logMethod;
                    if (level === Log.Level.ERROR && console.error) logMethod = console.error;
                    else if (level === Log.Level.WARNING && console.warn) logMethod = console.warn;
                    else if (level === Log.Level.DEBUG && console.debug) logMethod = console.debug;
                    else logMethod = console.log;
                    // print message
                    prefix = "%c" + prefix;
                    if (isArray(msg)) {
                        msg.splice(0, 0, prefix, "color: " + color);
                        logMethod.apply(console, msg);
                    } else logMethod.call(console, prefix, "color: " + color, msg);
                }
            }
        }
    },
    /**
   * Returns the current time in format hh:mm:ss.mmm (with trailing 0s)
   * @private
   * @return {string} Current time.
   */ _getCurrentTime: function() {
        var d = new Date();
        var hh = ("0" + d.getDate()).slice(-2);
        var mm = ("0" + d.getMinutes()).slice(-2);
        var ss = ("0" + d.getSeconds()).slice(-2);
        var mmm = ("00" + d.getMilliseconds()).slice(-3);
        return "[" + hh + ":" + mm + ":" + ss + "." + mmm + "]";
    },
    /**
   * Returns a console message without style
   *
   * @private
   * @param {(string|object|array)} msg Message string, object or array of messages.
   * @param {string} prefix Prefix of the message.
   */ _plainReport: function(msg, prefix) {
        if (msg instanceof Array) for(var m in msg)Log._plainReport(msg[m], prefix);
        else if (typeof msg === "string") console.log(prefix + " " + msg);
        else {
            console.log(prefix + " <next line>");
            console.log(msg);
        }
    },
    /**
   * Sends an error (level 1) console log.
   * Supports unlimited arguments: ("this", "is", "a", "message")
   * @memberof $YB
   * @see {@link $YB.report}
   */ error: function() {
        Log.report([].slice.call(arguments), Log.Level.ERROR, "darkred");
    },
    /**
   * Sends a warning (level 2) console log.
   * Supports unlimited arguments: ("this", "is", "a", "message")
   * @memberof $YB
   * @see {@link $YB.report}
   */ warn: function() {
        Log.report([].slice.call(arguments), Log.Level.WARNING, "darkorange");
    },
    /**
   * Sends a notice (level 3) console log.
   * Supports unlimited arguments: ("this", "is", "a", "message")
   * @memberof $YB
   * @see {@link $YB.report}
   */ notice: function() {
        Log.report([].slice.call(arguments), Log.Level.NOTICE, "darkgreen");
    },
    /**
   * Sends a debug message (level 4) to console.
   * Supports unlimited arguments: ("this", "is", "a", "message")
   * @memberof $YB
   * @see {@link $YB.report}
   */ debug: function() {
        Log.report([].slice.call(arguments), Log.Level.DEBUG, "indigo");
    },
    /**
   * Sends a verbose message (level 5) to console.
   * Supports unlimited arguments: ("this", "is", "a", "message")
   * @memberof $YB
   * @see {@link $YB.report}
   */ verbose: function() {
        Log.report([].slice.call(arguments), Log.Level.VERBOSE, "navy");
    },
    /**
   * This function is automatically executed at youboralib's init.
   * Will search inside window.location.search for attribute 'youbora-debug=X'.
   * X can have one of these values, that will modify LogLevel.
   * 6: SILENT,
   * 5: ERROR,
   * 4: WARNING,
   * 3: NOTICE,
   * 2: DEBUG,
   * 1: VERBOSE
   *
   * If youbora-console=plain is present, plainLogs will be set to true.
   */ loadLevelFromUrl: function() {
        if (typeof window !== "undefined" && window.location) this._parseLevelFromUrl(window.location.search);
    },
    _parseLevelFromUrl: function(url) {
        if (url) {
            var m = /\?.*&*youbora-debug=(.+)/i.exec(url);
            if (m !== null) Log.logLevel = m[1];
            var m2 = /\?.*&*youbora-debug=plain/i.exec(url);
            if (m2 !== null) Log.plainLogs = true;
        }
    }
};
module.exports = Log;

},{"3b53aed2141933f5":"cuYJd","c7d7a0a603fb31f3":"egFaS"}],"drhpF":[function(require,module,exports) {
var Log = require("e9f131395f38a200");
/**
 * This static class provides utility methods.
 *
 * @class
 * @static
 * @memberof youbora
 */ var Util = {
    /**
     * Strip {protocol}:// and // from the begining of the string.
     *
     * @param {string} url
     * @returns {string} stripped url
     */ stripProtocol: function(url) {
        var strippedUrl = url;
        try {
            strippedUrl = url.replace(/^(.*?:\/\/|\/\/)/i, "");
        } catch (err) {
            Log.warn(err);
        }
        return strippedUrl;
    },
    /**
     * Adds specific protocol. ie: [http://]nqs.nice264.com
     *
     * @param {string} url Domain of the service. Without protocol. ie: 'nqs.nice264.com'.
     * @param {boolean|null} [httpSecure]
     * If true will add https, if false http.
     * Otherwise will add //
     * @return Return the complete service URL.
     */ addProtocol: function(url, httpSecure) {
        var serviceUrl = "http://localhost/";
        try {
            serviceUrl = "http://" + url;
            if (httpSecure || typeof window !== "undefined" && window.location.protocol.indexOf("https") === 0) serviceUrl = "https://" + url;
            else if (typeof window !== "undefined" && window.location.protocol.indexOf("http") === 0) serviceUrl = "//" + url;
        } catch (err) {
            Log.warn(err);
        }
        return serviceUrl;
    },
    /**
     * Return n if it isn't NaN, negative, Infinity, null or undefined.
     * In any other case, return def.
     *
     * @param {mixed} n Number to be parsed.
     * @param {number} def Number to return if n is not correct.
     */ parseNumber: function(n, def) {
        return !isNaN(n) && n >= 0 && n !== Infinity && n !== -Infinity && n !== null && typeof n !== "undefined" ? n : def;
    },
    /**
     * This utility method will add most of the HTML5 common event listeners to the player sent.
     * This common events will be listened: 'canplay', 'buffering', 'waiting', 'ended', 'play',
     * 'playing', 'pause', 'resume', 'error', 'abort', 'seek', 'seeking', 'seeked', 'stalled',
     * 'dispose', 'loadeddata', 'loadstart'.
     *
     * Events will be reported as DEBUG level messages.
     *
     * @param {object|function} o Object to attach the events.
     * @param {array} [extraEvents]
     * An array of extra events to watch. ie:  ['timeupdate', 'progress'].
     * If the first item is null, no common events will be added.
     * @param {function} [report] Callback function called to report events.
     * Default calls Log.debug()
     */ logAllEvents: function(o, extraEvents, report) {
        try {
            if (Log.logLevel <= Log.Level.DEBUG) {
                report = report || function(e) {
                    Log.debug("Event: " + e.type);
                };
                var playerEvents = [
                    "canplay",
                    "buffering",
                    "waiting",
                    "ended",
                    "play",
                    "playing",
                    "pause",
                    "resume",
                    "error",
                    "abort",
                    "seek",
                    "seeking",
                    "seeked",
                    "stalled",
                    "dispose",
                    "loadeddata",
                    "loadstart"
                ];
                if (extraEvents) {
                    if (extraEvents[0] === null) {
                        extraEvents.shift();
                        playerEvents = extraEvents;
                    } else playerEvents = playerEvents.concat(extraEvents);
                }
                for(var i = 0; i < playerEvents.length; i++){
                    if (typeof o === "function") o.call(window, playerEvents[i], report);
                    else if (o.on) o.on(playerEvents[i], report);
                    else if (o.addEventListener) o.addEventListener(playerEvents[i], report);
                }
            }
        } catch (err) {
            Log.error(err);
        }
    },
    /**
     * Builds a string that represents the rendition.
     *
     * The returned string will have the following format: <width>x<height>@bitrate<suffix?>.
     * If either the width or height are < 1, only the bitrate will be returned.
     * If bitrate is < 1, only the dimensions will be returned.
     * If bitrate is < and there is no dimensions, a null will be returned.
     * The bitrate will also have one of the following suffixes dependin on its
     * magnitude: bps, Kbps, Mbps
     *
     * @param {any} width The width of the asset. If only 1 argument is sent, it will be treated
     * as bitrate.
     * @param {any} height The height of the asset.
     * @param {any} bitrate The indicated bitrate (in the manifest) of the asset.
     * @returns {string} A string with the following format: <width>x<height>@<bitrate><suffix>
     */ buildRenditionString: function(width, height, bitrate) {
        if (arguments.length === 1) {
            bitrate = width;
            width = null;
            height = null;
        }
        var ret = null;
        if (width && height) ret = width + "x" + height;
        if (typeof bitrate === "number" && !isNaN(bitrate) && bitrate >= 1) {
            if (ret) ret += "@";
            else ret = "";
            if (bitrate < 1e3) ret += Math.round(bitrate) + "bps";
            else if (bitrate < 1e6) {
                bitrate = Math.round(bitrate / 1e3);
                ret += bitrate + "Kbps";
            } else {
                bitrate = Math.round(bitrate / 1e4) / 1e2;
                ret += bitrate + "Mbps";
            }
        }
        return ret;
    },
    /**
     * Returns a params dictionary with the error values.
     *
     * @param {String|Object} [code] Error Code, if an object is sent, it will be treated as params.
     * @param {String} [msg] Error Message
     * @param {Object} [metadata] Object defining error metadata
     * @param {String} [level] Level of the error. Currently supports 'error' and 'fatal'
     * @returns {Object} Key:value params.
     */ buildErrorParams: function(code, msg, metadata, level) {
        var params = {};
        if (typeof code === "object" && code !== null) params = code;
        else {
            params.errorCode = code || "FAILURE";
            params.msg = msg || params.errorCode;
            params.errorMetadata = metadata;
            params.errorLevel = level;
        }
        return params;
    },
    /**
     * Returns a boolean indicating if more than the desired % of pixels are on screen.
     *
     * @param {Object} [player] Player object
     * @param {Number} [screenPercent] Threshold % of pixels on screen to return true.
     * @returns {Boolean} Its on screen or not.
     */ calculateAdViewability: function(player, screenPercent) {
        var isVisible = true;
        if (typeof window !== "undefined" && player && typeof player.getBoundingClientRect === "function") {
            var box = player.getBoundingClientRect();
            // 100% outside the window cases
            if (box.top >= window.innerHeight || box.bottom <= 0 || box.right <= 0 || box.left >= window.innerWidth) isVisible = false;
            else {
                var pixels = Math.trunc(box.height * box.width);
                var x1 = box.top > 0 ? box.top : 0;
                var x2 = box.bottom > window.innerHeight ? window.innerHeight : box.bottom;
                var y1 = box.left > 0 ? box.left : 0;
                var y2 = box.right > window.innerWidth ? window.innerWidth : box.right;
                var inScreenPixels = (y2 - y1) * (x2 - x1);
                // more than screenPercent of pixels (by default 50%)
                isVisible = inScreenPixels * 100 > pixels * (screenPercent || 50);
            }
        }
        return isVisible;
    },
    getMetricsFrom: function(op1, op2) {
        var metrics = op1 || op2;
        for(var metric in metrics)if (typeof metrics[metric] !== "object" || !metrics[metric].value) {
            var temporal = {};
            // temporal.oper = 'SUM' //default one?
            temporal.value = metrics[metric];
            metrics[metric] = temporal;
        }
        return metrics;
    },
    // The following methods replace core js functionallity to ensure compatibility in old versions.
    assign: require("84df27cf1b2f987a"),
    isArray: require("464eefd95436a6eb")
};
module.exports = Util;

},{"e9f131395f38a200":"8xsxZ","84df27cf1b2f987a":"i2p6U","464eefd95436a6eb":"egFaS"}],"395SH":[function(require,module,exports) {
/* global Streamroot, peer5, teltoo, CdnBalancerStats */ var YouboraObject = require("88c099747f1ba776");
/**
 * This static class provides p2p and cdn network traffic information for
 * Streamroot, Peer5 and EasyBroadcast
 *
 * @constructs YouboraObject
 * @extends youbora.YouboraObject
 * @memberof youbora
 *
 */ var HybridNetowrk = YouboraObject.extend({
    /** Returns CDN traffic bytes using NPAW balancer, streamroot, peer5 or teltoo. Otherwise null */ getCdnTraffic: function() {
        var ret = null;
        if (typeof CdnBalancerStats !== "undefined" && CdnBalancerStats.cdn) ret = CdnBalancerStats.cdn.totalDownloadedBytes;
        else if (typeof Streamroot !== "undefined") ret = this._getStreamrootPeerObject("cdn", false) || this._getStreamrootInstanceObject("cdnDownload");
        else if (typeof peer5 !== "undefined" && peer5.getStats) ret = peer5.getStats().totalHttpDownloaded;
        else if (typeof teltoo !== "undefined" && teltoo.getStats) {
            var stats = teltoo.getStats();
            ret = stats.totalReceivedBytes - stats.p2pReceivedBytes;
        }
        return ret;
    },
    /** Returns CDN traffic when using multiple cdns, available only for NPAW solution. Otherwise null */ getMultiCdnInfo: function() {
        var ret = null;
        if (typeof CdnBalancerStats !== "undefined" && CdnBalancerStats.cdn && CdnBalancerStats.cdn.cdns) {
            var p2p = CdnBalancerStats.p2p;
            ret = {
                P2P: {
                    downloaded_bytes: p2p.downloadedBytes,
                    uploaded_bytes: p2p.uploadedBytes,
                    downloaded_chunks: p2p.downloadedSegments,
                    uploaded_chunks: p2p.uploadedSegments,
                    errors: p2p.failedRequests ? p2p.failedRequests.total : 0,
                    missed_downloaded_chunks: p2p.failedRequests ? p2p.failedRequests.absent : 0,
                    timeout_errors: p2p.failedRequests ? p2p.failedRequests.timeout : 0,
                    other_errors: p2p.failedRequests ? p2p.failedRequests.error : 0,
                    late_uploaded_chunks: p2p.discardedUploadedSegments,
                    late_uploaded_bytes: p2p.discardedUploadedBytes,
                    late_downloaded_bytes: p2p.discardedDownloadedBytes,
                    time: p2p.downloadMillis,
                    active_peers: p2p.activePeers,
                    peers: p2p.totalPeers
                }
            };
            CdnBalancerStats.cdn.cdns.forEach(function(cdn) {
                ret[cdn.name] = {
                    downloaded_bytes: cdn.bytes,
                    downloaded_chunks: cdn.chunks,
                    errors: cdn.failures,
                    time: cdn.downloadMillis
                };
            });
        }
        return ret;
    },
    /** Returns segment duration using NPAW balancer API. Otherwise null */ getSegmentDuration: function() {
        var ret = null;
        if (typeof CdnBalancerStats !== "undefined" && CdnBalancerStats.segmentDuration) return CdnBalancerStats.segmentDuration;
        return ret;
    },
    /** Returns CDN balancer API response id, available only for NPAW solution. Otherwise null */ getBalancerResponseId: function() {
        var ret = null;
        if (typeof CdnBalancerStats !== "undefined" && CdnBalancerStats.cdn) return CdnBalancerStats.cdn.responseUUID;
        return ret;
    },
    /** Returns P2P traffic bytes using NPAW balancer, streamroot, peer5 or teltoo. Otherwise null */ getP2PTraffic: function() {
        var ret = null;
        if (typeof CdnBalancerStats !== "undefined" && CdnBalancerStats.p2p) ret = CdnBalancerStats.p2p.downloadedBytes;
        else if (typeof Streamroot !== "undefined") ret = this._getStreamrootPeerObject("p2p", true) || this._getStreamrootInstanceObject("dnaDownload");
        else if (typeof peer5 !== "undefined" && peer5.getStats) ret = peer5.getStats().totalP2PDownloaded;
        else if (typeof teltoo !== "undefined" && teltoo.getStats) ret = teltoo.getStats().p2pReceivedBytes;
        return ret;
    },
    /** Returns P2P traffic sent in bytes, using NPAW balancer, streamroot or peer5. Otherwise null */ getUploadTraffic: function() {
        var ret = null;
        if (typeof CdnBalancerStats !== "undefined" && CdnBalancerStats.p2p) ret = CdnBalancerStats.p2p.uploadedBytes;
        else if (typeof Streamroot !== "undefined") ret = this._getStreamrootPeerObject("upload", true) || this._getStreamrootInstanceObject("dnaUpload");
        else if (typeof peer5 !== "undefined" && peer5.getStats) ret = peer5.getStats().totalP2PUploaded;
        return ret;
    },
    /** Returns if P2P is enabled, using NPAW balancer, streamroot or peer5. Otherwise null */ getIsP2PEnabled: function() {
        var ret = false;
        if (typeof CdnBalancerStats !== "undefined" && CdnBalancerStats.p2p) ret = CdnBalancerStats.p2p.downloadEnabled;
        else if (typeof Streamroot !== "undefined") {
            if (Streamroot.p2pAvailable && Streamroot.peerAgents) for(var agent in Streamroot.peerAgents)ret = ret || Streamroot.peerAgents[agent].isP2PEnabled;
            else if (Streamroot.instances) Streamroot.instances.forEach(function(instance) {
                ret = ret || instance.dnaDownloadEnabled || instance.dnaUploadEnabled;
            });
        } else if (typeof peer5 !== "undefined" && peer5.isEnabled) ret = peer5.isEnabled();
        else if (typeof teltoo !== "undefined") ret = true;
        return ret;
    },
    _getStreamrootPeerObject: function(objectName, check) {
        var ret = null;
        if (Streamroot.p2pAvailable && Streamroot.peerAgents) for(var agent in Streamroot.peerAgents){
            var agentInst = Streamroot.peerAgents[agent];
            if (agentInst.stats && (!check || agentInst.isP2PEnabled)) ret += agentInst.stats[objectName];
        }
        return ret;
    },
    _getStreamrootInstanceObject: function(objectName) {
        var ret = null;
        if (Streamroot.instances) Streamroot.instances.forEach(function(instance) {
            if (instance.stats && instance.stats.currentContent) ret += instance.stats.currentContent[objectName];
        });
        return ret;
    }
});
module.exports = HybridNetowrk;

},{"88c099747f1ba776":"j7KrE"}],"6HP4E":[function(require,module,exports) {
var YouboraObject = require("152703c82f0d0861");
var Chrono = YouboraObject.extend(/** @lends youbora.Chrono.prototype */ {
    /**
     * This class calculates time lapses between two points in time.
     *
     * @constructs Chrono
     * @extends youbora.YouboraObject
     * @memberof youbora
     */ constructor: function() {
        this.reset();
    },
    /** Reset chrono values. */ reset: function() {
        /** Start time */ this.startTime = 0;
        /** Stop time */ this.stopTime = 0;
        /** Pause time */ this.pauseTime = 0;
        /** Offset to be added to deltaTime and stop. in ms. */ this.offset = 0;
    },
    /**
     * Returns the time between start() and the last stop() in ms. Returns -1 if start wasn't
     * called.
     * @param {boolean} [stop=true] If true, it will force a stop() if it wasn't called before.
     * @return {number} Time lapse in ms.
     */ getDeltaTime: function(stop) {
        var retValue = -1;
        var now = new Date().getTime();
        if (this.startTime) {
            if (stop && !this.stopTime) this.stopTime = now;
            var tempOffset = this.pauseTime ? now - this.pauseTime : 0;
            var tempStop = this.stopTime ? this.stopTime : now;
            retValue = this.offset - tempOffset + (tempStop - this.startTime);
        }
        return retValue;
    },
    /**
     * Starts the chrono.
     */ start: function() {
        this.startTime = new Date().getTime();
        this.stopTime = 0;
        this.offset = 0;
    },
    /**
     * Stops the timer and returns current delta time.
     * @return {number} Returns the delta time
     */ stop: function() {
        if (this.pauseTime) this.resume();
        this.stopTime = new Date().getTime();
        return this.startTime ? this.offset + (this.stopTime - this.startTime) : -1;
    },
    pause: function() {
        this.pauseTime = new Date().getTime();
    },
    resume: function() {
        this.offset -= new Date().getTime() - this.pauseTime;
        this.pauseTime = 0;
    },
    /**
     * Creates a copy of the chrono.
     */ clone: function() {
        var chrono = new Chrono();
        chrono.startTime = this.startTime;
        chrono.stopTime = this.stopTime;
        chrono.offset = this.offset;
        return chrono;
    }
});
module.exports = Chrono;

},{"152703c82f0d0861":"j7KrE"}],"cqNVd":[function(require,module,exports) {
/* global atv */ var YouboraObject = require("331e4433c8fd12a6");
var Chrono = require("a1bd627c12d01452");
var Timer = YouboraObject.extend(/** @lends youbora.Timer.prototype */ {
    /**
     * An Utility class that provides timed events in a defined time interval.
     *
     * @param {function} callback The callback to call every due interval.
     * Callback will receive lapsed ms between calls.
     * @param {int} [interval=5000] Milliseconds between each call.
     *
     * @constructs Timer
     * @extends youbora.YouboraObject
     * @memberof youbora
     */ constructor: function(callback, interval) {
        this.callback = callback;
        this.interval = interval || 5000;
        this.isRunning = false;
        this._timer = null;
        this.chrono = new Chrono();
    },
    /**
     * Starts the timer.
     */ start: function() {
        if (!this.isRunning) {
            this.isRunning = true;
            this._setTick();
        }
    },
    /**
     * Stops the timer.
     */ stop: function() {
        this.isRunning = false;
        if (this._timer) try {
            clearTimeout(this._timer);
            this._timer = null;
        } catch (err) {
            if (typeof atv !== "undefined") {
                atv.clearTimeout(this._timer);
                this._timer = null;
            }
        }
    },
    /**
     * Sets the next tick execution.
     * @private
     */ _setTick: function() {
        if (this.isRunning) {
            this.chrono.start();
            try {
                this._timer = setTimeout((function() {
                    this.callback(this.chrono.stop());
                    this._setTick();
                }).bind(this), this.interval);
            } catch (err) {
                if (typeof atv !== "undefined") this._timer = atv.setTimeout((function() {
                    this.callback(this.chrono.stop());
                    this._setTick();
                }).bind(this), this.interval);
            }
        }
    }
});
module.exports = Timer;

},{"331e4433c8fd12a6":"j7KrE","a1bd627c12d01452":"6HP4E"}],"92xpS":[function(require,module,exports) {
var AdPosition = require("8b1bc9a6f411e30");
var Adapter = require("3adb7d957d5a52a0");
var ManifestError = require("2d51953a240a676");
var RequestMethod = require("d2d692c1a40cd54b");
var Service = require("c2e11efd31033198");
var WillSendEvent = require("5102e2db100a227c");
var AdInsertionType = require("38c571aa233b7738");
/**
 * This static class englobes youbora constants.
 *
 * @class
 * @static
 * @memberof youbora
 */ var Constants = {
    AdPosition: AdPosition,
    ManifestError: ManifestError,
    RequestMethod: RequestMethod,
    Service: Service,
    WillSendEvent: WillSendEvent,
    AdInsertionType: AdInsertionType,
    Adapter: Adapter
};
module.exports = Constants;

},{"8b1bc9a6f411e30":"1F74U","3adb7d957d5a52a0":"4lEQs","2d51953a240a676":"bYqNO","d2d692c1a40cd54b":"ldnfs","c2e11efd31033198":"2iCpE","5102e2db100a227c":"28S4j","38c571aa233b7738":"9JQAd"}],"1F74U":[function(require,module,exports) {
/**
 * List of ad positions
 */ var AdPosition = {
    Preroll: "pre",
    Midroll: "mid",
    Postroll: "post"
};
module.exports = AdPosition;

},{}],"4lEQs":[function(require,module,exports) {
var Event = require("fff6289798254e4");
var Adapter = {
    Event: Event
};
module.exports = Adapter;

},{"fff6289798254e4":"7SEin"}],"7SEin":[function(require,module,exports) {
/**
 * List of events that can be triggered by the adapter
 */ var Event = {
    START: "start",
    JOIN: "join",
    PAUSE: "pause",
    RESUME: "resume",
    SEEK_BEGIN: "seek-begin",
    SEEK_END: "seek-end",
    BUFFER_BEGIN: "buffer-begin",
    BUFFER_END: "buffer-end",
    ERROR: "error",
    STOP: "stop",
    CLICK: "click",
    MANIFEST: "manifest",
    PODSTART: "break-start",
    PODSTOP: "break-stop",
    QUARTILE: "quartile",
    VIDEO_EVENT: "video-event"
};
module.exports = Event;

},{}],"bYqNO":[function(require,module,exports) {
/**
* List of ad manifest errors
*/ var ManifestError = {
    NO_RESPONSE: "NO_RESPONSE",
    EMPTY: "EMPTY_RESPONSE",
    WRONG: "WRONG_RESPONSE"
};
module.exports = ManifestError;

},{}],"ldnfs":[function(require,module,exports) {
/**
 * List of Request Methods
 *   - GET
 *   - POST
 */ var RequestMethod = {
    GET: "get",
    POST: "post"
};
module.exports = RequestMethod;

},{}],"2iCpE":[function(require,module,exports) {
/**
 * List of youbora services.
 *
 * @enum
 */ var Service = {
    DATA: "/data",
    // Video
    INIT: "/init",
    START: "/start",
    JOIN: "/joinTime",
    PAUSE: "/pause",
    RESUME: "/resume",
    SEEK: "/seek",
    BUFFER: "/bufferUnderrun",
    ERROR: "/error",
    STOP: "/stop",
    PING: "/ping",
    VIDEO_EVENT: "/infinity/video/event",
    // Ads
    AD_INIT: "/adInit",
    AD_START: "/adStart",
    AD_JOIN: "/adJoin",
    AD_PAUSE: "/adPause",
    AD_RESUME: "/adResume",
    AD_BUFFER: "/adBufferUnderrun",
    AD_STOP: "/adStop",
    AD_CLICK: "/adClick",
    AD_ERROR: "/adError",
    AD_MANIFEST: "/adManifest",
    AD_POD_START: "/adBreakStart",
    AD_POD_STOP: "/adBreakStop",
    AD_QUARTILE: "/adQuartile",
    // Infinity
    EVENT: "/infinity/session/event",
    SESSION_START: "/infinity/session/start",
    SESSION_STOP: "/infinity/session/stop",
    NAV: "/infinity/session/nav",
    BEAT: "/infinity/session/beat",
    // Offline
    OFFLINE_EVENTS: "/offlineEvents"
};
module.exports = Service;

},{}],"28S4j":[function(require,module,exports) {
/**
 * List of will-send events.
 *
 * @memberof youbora.Plugin
 * @enum
 * @event
 */ var WillSendEvent = {
    WILL_SEND_INIT: "will-send-init",
    WILL_SEND_START: "will-send-start",
    WILL_SEND_JOIN: "will-send-join",
    WILL_SEND_PAUSE: "will-send-pause",
    WILL_SEND_RESUME: "will-send-resume",
    WILL_SEND_SEEK: "will-send-seek",
    WILL_SEND_BUFFER: "will-send-buffer",
    WILL_SEND_ERROR: "will-send-error",
    WILL_SEND_FATAL_ERROR: "will-send-fatal-error",
    WILL_SEND_STOP: "will-send-stop",
    WILL_SEND_PING: "will-send-ping",
    WILL_SEND_VIDEO_EVENT: "will-send-video-event",
    WILL_SEND_AD_START: "will-send-ad-start",
    WILL_SEND_AD_JOIN: "will-send-ad-join",
    WILL_SEND_AD_PAUSE: "will-send-ad-pause",
    WILL_SEND_AD_RESUME: "will-send-ad-resume",
    WILL_SEND_AD_BUFFER: "will-send-ad-buffer",
    WILL_SEND_AD_STOP: "will-send-ad-stop",
    WILL_SEND_AD_CLICK: "will-send-ad-click",
    WILL_SEND_AD_ERROR: "will-send-ad-error",
    WILL_SEND_AD_MANIFEST: "will-send-ad-manifest",
    WILL_SEND_AD_POD_START: "will-send-ad-break-start",
    WILL_SEND_AD_POD_STOP: "will-send-ad-break-stop",
    WILL_SEND_AD_QUARTILE: "will-send-ad-quartile",
    WILL_SEND_SESSION_START: "will-send-session-start",
    WILL_SEND_SESSION_STOP: "will-send-session-stop",
    WILL_SEND_NAV: "will-send-nav",
    WILL_SEND_BEAT: "will-send-beat",
    WILL_SEND_EVENT: "will-send-event",
    WILL_SEND_OFFLINE_EVENTS: "will-send-offline-events"
};
module.exports = WillSendEvent;

},{}],"9JQAd":[function(require,module,exports) {
/**
 * List of ad insertion types
 */ var InsertionType = {
    ClientSide: "csai",
    ServerSide: "ssai"
};
module.exports = InsertionType;

},{}],"6hKtj":[function(require,module,exports) {
/* global  atv, XMLHttpRequest, ActiveXObject */ var YouboraObject = require("ebc90264fc6615be");
var Log = require("e19f3a7aecc6252b");
var Util = require("fef38598beed357e");
var YBRequest = YouboraObject.extend(/** @lends youbora.YBRequest.prototype */ {
    /**
     * YBYBRequest class will wrap XmlHttpRequest and extend its functionality, allowing youbora
     * to manage queues, blockers and retries.
     *
     * @constructs YBRequest
     * @extends youbora.Object
     * @memberof youbora
     *
     * @param {string} host URL of the request. ie: a-fds.youborafds01.com
     * @param {string} [service] Name of the service. ie '/start'
     * @param {Object} [params] Object of key:value params.
     * @param {Object} [options] Object with custom options.
     * @param {string} [options.method="GET"] Specifies the method of the request. ie: "GET", "HEAD".
     * @param {string} [options.requestHeaders] Object with options of requestHeaders.
     * ie: { header: value }.
     * @param {number} [options.retryAfter=5000] Time in ms before sending a failed request again.
     * 0 to disable.
     * @param {number} [options.maxRetries=3] Max number of retries. 0 to disable.
     * @param {bool} [options.cache=false] If false, timestamp will be added to each request to
     * prevent caching.
     */ constructor: function(host, service, params, options) {
        /** Instance of XmlHttpRequest (or the item returned by createXHR method). */ this.xhr = this.createXHR();
        /** Host of the request */ this.host = host || "";
        /** Service of the request */ this.service = service || "";
        /** Object of params of the request */ this.params = params || {};
        /** Options of the current request */ this.options = Util.assign({}, YBRequest.defaultOptions, options);
        /** Number of times this request has failed and retried. */ this.retries = 0;
        /** Define if plugin has enabled to send requests with POST method */ this.sendPostRequest = false;
        this.preparedPostRequest = false;
        // Add timemark
        if (!this.options.cache) this.setParam("timemark", new Date().getTime());
    },
    /**
     * Creates XMLHttpRequest if it is available in the browser.
     * If not, it tries to create an ActiveXObject XMLHTTP item.
     * Override this function for custom environments.
     *
     * @return YBRequest handler.
     */ createXHR: function() {
        var xhr = {};
        try {
            if (XMLHttpRequest) xhr = new XMLHttpRequest();
            else xhr = new ActiveXObject("Microsoft.XMLHTTP");
        } catch (err) {
            Log.error(err);
        }
        return xhr;
    },
    /**
     * Returns xhr object.
     *
     * @return {XmlHttpRequest} object.
     */ getXHR: function() {
        return this.xhr;
    },
    getResponse: function() {
        return this.xhr.response;
    },
    getResponseText: function() {
        return this.xhr.responseText;
    },
    getResponseHeaders: function() {
        return this.xhr.getAllResponseHeaders();
    },
    /** Returns the complete formed url of the request url+service+params. */ getUrl: function() {
        return this.host + this.service + this.getParamString();
    },
    /**
     * Wraps this.getHXR.addEventListener.
     * Accepts a callback that receives (this YBRequest, event)
     */ on: function(event, callback, callbackParams) {
        if (this.xhr.addEventListener) this.xhr.addEventListener(event, callback.bind(this, this, callbackParams));
        else if (event === YBRequest.Event.SUCCESS) this.xhr.onreadystatechange = (function() {
            if (this.xhr.readyState === 4) callback.bind(this, this, callbackParams);
        }).bind(this);
        return this;
    },
    /** Wraps this.getHXR.removeEventListener */ off: function(event, callback) {
        this.xhr.removeEventListener(event, callback);
        return this;
    },
    /**
     * Returns the params of the request, stringified.
     * ie: '?pluginVersion=5.1.0&systemCode=nicetv'.
     * @return {string} Concatenated Params
     */ getParamString: function() {
        try {
            var params = "?";
            for(var key in this.params){
                var param = this.params[key];
                if (param !== null && typeof param === "object") {
                    var string = JSON.stringify(param);
                    if (string !== "{}") params += encodeURIComponent(key) + "=" + encodeURIComponent(string) + "&";
                } else if (param !== null && typeof param !== "undefined" && param !== "") params += encodeURIComponent(key) + "=" + encodeURIComponent(param) + "&";
            }
            return params.slice(0, -1);
        } catch (err) {
            Log.error(err);
            return "";
        }
    },
    /**
     * Returns the value of the given param, or undefined.
     * @param {string} key Name of the param.
     * @return {any}
     */ getParam: function(key) {
        return this.params[key];
    },
    /**
     * Add or set a parameter for the request.
     * ie: if you want to add 'username=user' use setParam('username', 'user').
     * @param {string} key Name of the param.
     * @param {string} value Name of the param.
     * @return this
     */ setParam: function(key, value) {
        this.params[key] = value;
        return this;
    },
    setBody: function(body) {
        this.body = body;
    },
    /**
     * Set if is enabled send requests with POST method
     * @param {boolean} sendPostRequest
     */ setPostRequest: function(sendPostRequest) {
        this.sendPostRequest = sendPostRequest;
    },
    /**
     * Create Params object with the basic get params we need to send to the Data Collector nodes
     * @returns {{}}
     */ getParamsForPostMessages: function() {
        // Creating empty params object
        var params = {};
        try {
            // Get previous params
            var timemark = this.getParam("timemark");
            var code = this.getParam("code");
            var sessionRoot = this.getParam("sessionRoot");
            var sessionId = this.getParam("sessionId");
            // Adding params
            if (timemark) params.timemark = timemark;
            if (code) params.code = code;
            if (sessionRoot) params.sessionRoot = sessionRoot;
            if (sessionId) params.sessionId = sessionId;
        } catch (err) {
            Log.error(err);
        }
        return params;
    },
    /**
     * Sends the request.
     *
     * @return returns xhr.send()
     */ send: function() {
        try {
            try {
                if (this.sendPostRequest && !this.preparedPostRequest) {
                    this.options.method = "POST";
                    this.body = JSON.stringify(this.params);
                    this.params = this.getParamsForPostMessages();
                    this.preparedPostRequest = true;
                }
            } catch (err) {}
            this.xhr.open(this.options.method, this.getUrl(), true);
            // Add custom headers
            if (this.options.requestHeaders) {
                for(var key in this.options.requestHeaders)if (this.options.requestHeaders.hasOwnProperty(key)) this.xhr.setRequestHeader(key, this.options.requestHeaders[key]);
            }
            // Add retries system
            if (this.options.retryAfter > 0 && this.options.maxRetries > 0) {
                var genericError = function() {
                    if (this.retries >= this.options.maxRetries) Log.error('Aborting failed request "' + this.service + '". Max retries reached.');
                    else {
                        Log.warn('YBRequest "' + this.service + '" failed. Retry ' + (this.retries + 1) + " of " + this.options.maxRetries + " in " + this.options.retryAfter + "ms.");
                        try {
                            setTimeout((function() {
                                this.retries += 1;
                                this.send();
                            }).bind(this), this.options.retryAfter);
                        } catch (err) {
                            if (typeof atv !== "undefined") atv.setTimeout((function() {
                                this.retries += 1;
                                this.send();
                            }).bind(this), this.options.retryAfter);
                            else Log.error(err);
                        }
                    }
                };
                if (this.retries === 0) this.on(YBRequest.Event.ERROR, genericError.bind(this));
            }
            // Log XHR
            if (Log.logLevel <= Log.Level.VERBOSE) Log.verbose("XHR Req: " + this.getUrl());
            // Register 'on every' listeners
            for(var event in YBRequest._globalListeners)YBRequest._globalListeners[event].forEach((function(callback) {
                this.on(event, callback);
            }).bind(this));
            // Send
            return this.xhr.send(this.body);
        } catch (err) {
            Log.error(err);
        }
    }
}, /** @lends youbora.YBRequest */ {
    /**
     * List of events that could be fired from XHR
     * @enum
     */ Event: {
        /** Request successful */ SUCCESS: "load",
        /** Request successful */ LOAD: "load",
        /** Request returned error */ ERROR: "error",
        /** Request aborted */ ABORT: "abort"
    },
    /**
     * This static property includes the default values for the options. In case you do not define
     * one of them in the constructor, these values will be used instead.
     *
     * @param {string} [defaultOptions.method="GET"] Specifies the method of the request.
     * ie: "GET", "HEAD".
     * @param {string} [defaultOptions.requestHeaders] Object with options of requestHeaders.
     * ie: { header: value }.
     * @param {number} [defaultOptions.retryAfter=5000] Time in ms before sending a failed request
     * again. 0 to disable.
     * @param {number} [defaultOptions.maxRetries=3] Max number of retries. 0 to disable.
     * @param {bool} [defaultOptions.cache=false] If false, timemark will be added to each request
     * to prevent caching.
     */ defaultOptions: {
        method: "GET",
        requestHeaders: {},
        maxRetries: 3,
        retryAfter: 5000,
        cache: false
    },
    /** @private */ _globalListeners: {},
    /**
     * Adds a callback to every instance.
     * @param {string} event Name of the event.
     * @param {function} callback Callback of the event.
     */ onEvery: function(event, callback) {
        YBRequest._globalListeners[event] = YBRequest._globalListeners[event] || [];
        YBRequest._globalListeners[event].push(callback);
    },
    /**
     * Removes a global callback
     * @param {string} event Name of the event.
     * @param {function} callback Callback of the event.
     */ offEvery: function(event, callback) {
        if (YBRequest._globalListeners[event]) {
            var index = YBRequest._globalListeners[event].indexOf(callback);
            if (index !== -1) YBRequest._globalListeners[event].splice(index, 1);
        }
    }
});
module.exports = YBRequest;

},{"ebc90264fc6615be":"j7KrE","e19f3a7aecc6252b":"8xsxZ","fef38598beed357e":"drhpF"}],"bOkDM":[function(require,module,exports) {
var YouboraObject = require("7414961b1f6d262a");
var Log = require("c7d6b9bfe4acdc51");
var YBRequest = require("4d575eae5c682491");
var Transform = require("91400f81237f0f11");
var Communication = YouboraObject.extend(/** @lends youbora.Communication.prototype */ {
    /**
     * Youbora Communication implements an abstraction layer over API requests.
     * Internally, Communication implements queues of {@link Request} objects.
     * This queue can be blocked using {@link Transform}
     *
     * @constructs Communication
     * @extends youbora.YouboraObject
     * @memberof youbora
     *
     * @param {string} host The fastdata host address.
     * @param {boolean} httpSecure True for https, false for http, undefined for //.
     */ constructor: function(pluginref) {
        /** Array of {@link Transform}, only when the array is empty the request Queues will begin sending. */ this.transforms = [];
        this.pluginRef = pluginref;
        /**
       * Queue of {@link YBRequest}
       * @private
       */ this._requests = [];
    },
    /**
     * Enqueues the request provided.
     *
     * @param {YBRequest} request Request to be enqueued
     * @param {function} [callback] The defined load callback to the Request
     */ sendRequest: function(request, callback, callbackParams) {
        if (request) {
            if (typeof callback === "function") request.on(YBRequest.Event.SUCCESS, callback, callbackParams);
            this._registerRequest(request);
        }
    },
    /**
     * Build a generic request to the given host.
     *
     * @param {string} host Host of the service called.
     * @param {string} service A string with the service to be called. ie: '/data', '/joinTime'...
     * @param {Object} [params] Object of key:value params.
     * @param {function} [callback] The defined load callback to the Request
     */ buildRequest: function(host, service, params, callback) {
        params = params || {};
        var request = new YBRequest(host, service, params);
        if (typeof callback === "function") request.on(YBRequest.Event.SUCCESS, callback);
        this._registerRequest(request);
    },
    /**
     * Adds a Transform to the queue. See {@link Transform}.
     *
     * @param {RequestTransform} transform
     */ addTransform: function(transform) {
        if (transform.parse && transform.isBlocking) {
            this.transforms.push(transform);
            transform.on(Transform.Event.DONE, this._processRequests.bind(this));
        } else Log.warn(transform + " is not a valid RequestTransform.");
    },
    /**
     * Removes a {@link Transform}.
     *
     * @param {RequestTransform} transform Transform object to remove.
     */ removeTransform: function(transform) {
        var pos = this.transforms.indexOf(transform);
        if (pos !== -1) this.transforms.splice(pos, 1);
        else Log.warn("Trying to remove unexisting Transform '" + transform + "'.");
    },
    /**
     * Adds an {@link YBRequest} to the queue of requests.
     *
     * @private
     * @param {YBRequest} request The Request to be queued.
     */ _registerRequest: function(request) {
        if (this.pluginRef) {
            var options = this.pluginRef.options;
            if (options.authToken) request.options.requestHeaders.Authorization = options.authType + " " + options.authToken;
        }
        this._requests.push(request);
        this._processRequests();
    },
    /**
     * Execute pending requests in the queue. Returns rejected ones to the queue.
     * @private
     */ _processRequests: function() {
        var workingQueue = this._requests;
        this._requests = [];
        var rejected = [];
        while(workingQueue.length){
            var request = workingQueue.shift();
            var transformState = this._transform(request);
            if (transformState === Transform.STATE_NO_BLOCKED) {
                if (this.pluginRef) request.host = this.pluginRef.getHost();
                request.send();
            } else if (transformState === Transform.STATE_BLOCKED) rejected.push(request);
             // else { remove }
        }
        while(rejected.length)this._requests.push(rejected.shift());
    },
    /**
     * Pass the given request to each transform.
     * @private
     * @returns {int} STATE_NO_BLOCKED if everything is right. STATE_BLOCKED if some parser rejected it.
     * STATE_OFFLINE if offline transform blocked it.
     */ _transform: function(request) {
        var ret = Transform.STATE_NO_BLOCKED;
        this.transforms.forEach(function(transform) {
            if (transform.isBlocking(request)) {
                ret = Transform.STATE_BLOCKED;
                return;
            } else transform.parse(request);
            if (transform.getState() === Transform.STATE_OFFLINE) ret = Transform.STATE_OFFLINE;
        });
        return ret;
    }
});
module.exports = Communication;

},{"7414961b1f6d262a":"j7KrE","c7d6b9bfe4acdc51":"8xsxZ","4d575eae5c682491":"6hKtj","91400f81237f0f11":"8oBJA"}],"8oBJA":[function(require,module,exports) {
var Emitter = require("a5be0dbe7698d9a4");
var Transform = Emitter.extend(/** @lends youbora.Transform.prototype */ {
    /**
     * Transform classes in YOUBORA help the library parse and work with data.
     *
     * A Transform makes some kind of task that may block requests until it's done, or applies changes
     * to the requests right before they're finally sent.
     *
     * {@link ResourceTransform}, {@link ViewTransform}... all extend from this class.
     *
     * @constructs Transform
     * @extends youbora.Emitter
     * @memberof youbora
     * @abstract
     */ constructor: function() {
        /**
       * Whether the Transform is currently working or not.
       * @private
       */ this._isBusy = true;
        this._sendRequest = true;
        this.transformName = "Transform";
    },
    /**
     * Override this method to transform info.
     *
     * @param {YBRequest} request Request to transform.
     */ parse: function(request) {},
    /**
     * By default this will return true until {@link #done()} is called. This can be overridden
     * in order to block {@link Request}s based on any criteria. For instance its
     * {@link Request#getService()}.
     *
     * @param {YBRequest} request Request to transform.
     * @return {bool} True if queue shall be blocked.
     */ isBlocking: function(request) {
        return this._isBusy;
    },
    /**
     * Emits DONE event
     */ done: function() {
        this._isBusy = false;
        this.emit(Transform.Event.DONE);
    },
    // offline
    hasToSend: function(request) {
        return this._sendRequest;
    },
    getState: function() {
        if (!this._sendRequest) return this.STATE_OFFLINE;
        if (this._isBusy) return this.STATE_BLOCKED;
        return this.STATE_NO_BLOCKED;
    }
}, /** @lends youbora.Transform */ {
    // Static members
    STATE_OFFLINE: 2,
    STATE_BLOCKED: 1,
    STATE_NO_BLOCKED: 0,
    /**
     * List of events that could be fired from this class.
     * @enum
     */ Event: {
        /** Notifies that this Transform is done processing. */ DONE: "done"
    }
});
module.exports = Transform;

},{"a5be0dbe7698d9a4":"cuYJd"}],"hugd5":[function(require,module,exports) {
var YBRequest = require("15836739692e3d5e");
var Transform = require("1c796c9097f65d4d");
var Log = require("858083a5a011bb47");
var Util = require("b3edcb45186550f6");
var Constants = require("8416b7bef37216ae");
var ViewTransform = Transform.extend(/** @lends youbora.ViewTransform.prototype */ {
    /**
     * This class manages Fastdata service and view index.
     *
     * @constructs
     * @extends youbora.Transform
     * @memberof youbora
     *
     * @param {Plugin} plugin Instance of {@link Plugin}
     * @param {string} session If provided, plugin will use this as a FD response.
     */ constructor: function(plugin, session) {
        Transform.prototype.constructor.apply(this, arguments);
        /** /data response */ this.response = {};
        this._viewIndex = new Date().getTime();
        this._session = session;
        this._httpSecure = plugin.options["app.https"];
        this._plugin = plugin;
        this.transformName = "View";
    },
    /**
     * Starts the 'FastData' fetching. This will send the initial request to YOUBORA in order to get
     * the needed info for the rest of the requests.
     *
     * This is an asynchronous process.
     *
     * When the fetch is complete, {@link #fastDataConfig} will contain the parsed info.
     * @see FastDataConfig
     */ init: function() {
        // offline
        if (this._plugin.options && this._plugin.options.offline) {
            // set the options
            this.response.host = "OFFLINE";
            this.response.code = "OFFLINE";
            this.response.pingTime = 60;
            this.response.beatTime = 60;
            this.done();
            return null;
        }
        // reusing old data not expired
        if (this._plugin.storage.isEnabled()) {
            var now = new Date().getTime();
            if (now < this._plugin.sessionExpire + (Number(this._plugin.getDataTime()) || 0) && this._plugin.getStoredData()) {
                this.setData(this._plugin.getStoredData());
                return null;
            }
        }
        // request new data
        var service = Constants.Service.DATA;
        var params = {
            outputformat: "json"
        };
        params = this._plugin.requestBuilder.buildParams(params, service);
        if (params !== null) {
            Log.notice(service + " " + params.system);
            if (params.system === "nicetest") // "nicetest" is the default accountCode.
            // If found here, it's very likely that the customer has forgotten to set it.
            Log.error("No accountCode has been set. Please set your accountCode inside plugin's options.");
            new YBRequest(this._plugin.getHost(), service, params).on(YBRequest.Event.SUCCESS, this._receiveData.bind(this)).on(YBRequest.Event.ERROR, this._failedData.bind(this)).send();
        }
    },
    /**
     * Uses given response to set fastdata response.
     *
     * @param {String} response Fastdata response as json string.
     */ setData: function(response) {
        try {
            var resp = JSON.parse(response);
            if (this._plugin.options["parse.fdsResponseHost"]) {
                response = response.replace(resp.q.h, this._plugin.options["parse.fdsResponseHost"](resp.q.h));
                resp = JSON.parse(response);
            }
            this.response.msg = response;
            this.response.host = Util.addProtocol(resp.q.h, this._httpSecure);
            this.response.code = resp.q.c;
            this.response.pingTime = resp.q.pt || 5;
            this.response.beatTime = resp.q.i ? resp.q.i.bt || 30 : 30;
            this.response.sessionExpire = resp.q.i ? resp.q.i.exp || 300 : 300;
            this._plugin.storage.setLocal("sessionExpire", this.response.sessionExpire);
            this.done();
        } catch (err) {
            Log.error("Fastdata response is invalid.");
        }
    },
    /**
     * Parse the response from the fastData service.
     *
     * @private
     */ _receiveData: function(req, e) {
        var msg = req.getResponse();
        this.setData(msg);
    },
    _failedData: function(req, e) {
        Log.error("Fastdata request has failed.");
    },
    /**
     * This method will increment the view index (timestamp values). The library handles this
     * automatically, but some error flow might need calling this manually.
     * @return {string} new viewcode
     */ nextView: function() {
        this._viewIndex = new Date().getTime();
        return this.getViewCode();
    },
    /**
     * Returns current viewcode
     * @return {string} viewcode
     */ getViewCode: function(viewIndex) {
        if (viewIndex !== null && this._plugin && this._plugin.options && this._plugin.options["session.splitViews"]) return this.response.code + "_" + (viewIndex || this._viewIndex);
        return this.response.code + "_" + this._viewIndex;
    },
    /**
     * Returns the current session
     *
     * @returns {string} Session
     */ getSession: function() {
        return this._session;
    },
    /**
     * Sets the session
     *
     * @param {String} sessionId Sets the session
     */ setSession: function(session) {
        this._session = session;
    },
    /** Sets the host url
    *
    * @param {String} host Sets the host
    */ setHost: function(host) {
        this.response.host = host;
    },
    /**
     * Transform requests
     * @param {youbora.comm.YBRequest} request YBRequest to transform.
     */ parse: function(request) {
        // Host, system and sessionRoot for all
        request.host = request.host || this.response.host;
        request.params.system = this._plugin.getAccountCode();
        request.params.sessionRoot = request.params.sessionRoot || this.getSession();
        // PingTime for ping and start
        if (ViewTransform.EventList.PingTime.indexOf(request.service) !== -1) request.params.pingTime = request.params.pingTime || this.response.pingTime;
        // ViewCode for non infinity events
        if (ViewTransform.EventList.Infinity.indexOf(request.service) === -1) {
            if (this._plugin && this._plugin.options && this._plugin.options["session.splitViews"]) {
                request.params.code = request.params.code || this.getViewCode(request.params.viewIndex);
                delete request.params.viewIndex;
            } else request.params.code = request.params.code || this.getViewCode();
        } else // For infinity events, sessionId
        request.params.sessionId = request.params.sessionRoot;
        // For init error and start, parentId and navContext
        if (ViewTransform.EventList.CreateView.indexOf(request.service) !== -1) {
            if (this._plugin.infinity.infinityStarted || this._plugin.storage.isEnabled() && this._plugin.storage.getLocal("infinityStarted")) {
                request.params.parentId = request.params.sessionRoot;
                request.params.navContext = request.params.navContext || this._plugin.getContext();
            }
        }
    }
}, {
    // Static members
    EventList: {
        CreateView: [
            Constants.Service.START,
            Constants.Service.INIT,
            Constants.Service.ERROR
        ],
        Infinity: [
            Constants.Service.NAV,
            Constants.Service.SESSION_START,
            Constants.Service.SESSION_STOP,
            Constants.Service.EVENT,
            Constants.Service.BEAT
        ],
        PingTime: [
            Constants.Service.START,
            Constants.Service.PING
        ]
    }
});
module.exports = ViewTransform;

},{"15836739692e3d5e":"6hKtj","1c796c9097f65d4d":"8oBJA","858083a5a011bb47":"8xsxZ","b3edcb45186550f6":"drhpF","8416b7bef37216ae":"92xpS"}],"3JgT9":[function(require,module,exports) {
/* global atv */ var Transform = require("8e7025ecbec1b8a3");
var HlsParser = require("18d2b12d2d609dc3");
var CdnParser = require("abc3621d731d67a0");
var CdnSwitch = require("dc0c1e47ec773074");
var DashParser = require("90f78bd262644e39");
var Parser = require("37063861862c0809");
var LocationheaderParser = require("545f3033b76999f1");
var Log = require("2a4f3463bc59f25c");
var Constants = require("b7894af02d627ec8");
var ResourceTransform = Transform.extend(/** @lends youbora.ResourceTransform.prototype */ {
    /**
     * This class parses resource to fetch HLS transportstreams and CDN-related info.
     *
     * @constructs ResourceTransform
     * @extends youbora.Transform
     * @memberof youbora
     *
     * @param {Plugin} plugin Instance of {@link Plugin}
     */ constructor: function(plugin) {
        ResourceTransform.__super__.constructor.apply(this, arguments);
        this._plugin = plugin;
        this._realResource = null;
        this._transportFormat = null;
        this._initResource = null;
        this._cdnName = null;
        this._cdnNodeHost = null;
        this._cdnNodeTypeString = null;
        this._cdnNodeType = null;
        this._responses = {};
        this._isBusy = false;
        this.transformName = "Resource";
    },
    /**
     * Get the resource. If the transform is done, the real (parsed) resource will be returned
     * Otherwise the initial one is returned.
     *
     * @return {string} The initial or parsed resource
     */ getResource: function() {
        return this._realResource;
    },
    _getInitialCdnResource: function() {
        return this._realResource || this._initResource;
    },
    /**
     * Get the transport format. If the transform detected the chunk format it will be returned, if not, null.
     *
     * @return {string} The streaming protocol
     */ getTransportFormat: function() {
        return this._transportFormat;
    },
    /**
     * Get the parsed CDN name.
     *
     * @return {string} The CDN name or null if unknown
     */ getCdnName: function() {
        return this._cdnName;
    },
    /**
     * Get the parsed CDN node.
     *
     * @return {string} The CDN node or null if unknown
     */ getNodeHost: function() {
        return this._cdnNodeHost;
    },
    /**
     * Get the parsed CDN type string, as returned in the cdn header response.
     *
     * @return {string} The CDN type string
     */ getNodeTypeString: function() {
        return this._cdnNodeTypeString;
    },
    /**
     * Get the parsed CDN type, parsed from the type string.
     *
     * @return {string} The CDN type
     */ getNodeType: function() {
        return this._cdnNodeType;
    },
    /**
     * Start the execution. Can be called more than once. If already running, it will be ignored,
     * if ended it will restart.
     * @param {string} resource the original resource
     */ init: function(resource) {
        if (!resource) {
            this.done();
            return;
        }
        if (!this._isBusy) {
            this._isBusy = true;
            this._initResource = resource;
            this._parseManifestEnabled = this._plugin.isParseManifest();
            this._cdnEnabled = this._plugin.isParseCdnNode();
            this._cdnList = this._plugin.getParseCdnNodeList().slice() // clone
            ;
            CdnParser.setBalancerHeaderName(this._plugin.getParseCdnNodeNameHeader(), this._plugin.getParseNodeHeader());
            this._setTimeout();
            if (this._parseManifestEnabled) {
                if (!this._isFinalUrl(this._initResource)) this.parseManifest() // Unknown lastManifest or lastSrc, call without arguments
                ;
                else {
                    this._realResource = this._initResource;
                    this.done();
                }
            } else this._parseCDN();
        }
    },
    _isFinalUrl: function(url) {
        var segmentExtensions = [
            ".ts",
            ".mp4",
            ".m4s",
            ".cmfv"
        ];
        url = url || "";
        for(var i in segmentExtensions){
            var ext = segmentExtensions[i];
            if (url.lastIndexOf(ext) === url.length - ext.length) return true;
        }
        return false;
    },
    // done: function () {
    //  Transform.prototype.done.apply(this, arguments) // super
    // },
    _setTimeout: function() {
        // Abort operation after 3s
        var timeoutComplete = (function() {
            if (this._isBusy) {
                this.done();
                Log.warn("ResourceTransform has exceeded the maximum execution time (3s) and will be aborted.");
            }
        }).bind(this);
        try {
            this._parseTimeout = setTimeout(timeoutComplete, 3000);
        } catch (err) {
            if (typeof atv !== "undefined") this._parseTimeout = atv.setTimeout(timeoutComplete, 3000);
            else Log.error(err);
        }
    },
    parseManifest: function(lastManifest, lastSrc) {
        var headers = this._plugin.options["parse.manifest.auth"];
        var parserArray = [
            new LocationheaderParser(headers),
            new DashParser(headers),
            new HlsParser(headers)
        ];
        this._parseManifest(parserArray, lastManifest, lastSrc || this._initResource);
    },
    _parseManifest: function(parserArray, lastManifest, lastSrc, format) {
        if (parserArray.length > 0) {
            var parser = parserArray[0];
            if (parser.shouldExecute(lastManifest)) {
                parser.on(Parser.Event.DONE, (function() {
                    this._parseManifest(parserArray.slice(1, parserArray.length), parser.getLastManifest(), parser.getResource(), parser.getTransportFormat() || format);
                }).bind(this));
                parser.parse(lastSrc, lastManifest);
            } else this._parseManifest(parserArray.slice(1, parserArray.length), lastManifest, lastSrc, format);
        } else {
            this._transportFormat = format;
            this._realResource = lastSrc;
            this._parseCDN();
        }
    },
    _parseCDN: function() {
        if (this._plugin.isCdnSwitch()) {
            this.switchDetector = new CdnSwitch(this._plugin);
            this.switchDetector.on(CdnSwitch.Events.DONE, (function(resp) {
                this._cdnName = resp.data;
                this.done();
            }).bind(this));
            this.switchDetector.on(CdnSwitch.Events.ERROR, (function() {
                this.done();
            }).bind(this));
            this.switchDetector.init();
        } else if (this._cdnEnabled && this._cdnList.length > 0) {
            var cdn = this._cdnList.shift();
            if (this.getNodeHost()) return; // abort
            var cdnParser = CdnParser.create(cdn);
            if (cdnParser) {
                cdnParser.on(CdnParser.Event.DONE, (function() {
                    this._responses = cdnParser.getResponses();
                    this._cdnName = cdnParser.getParsedCdnName();
                    this._cdnNodeHost = cdnParser.getParsedNodeHost();
                    this._cdnNodeTypeString = cdnParser.getParsedNodeTypeString();
                    this._cdnNodeType = cdnParser.getParsedNodeType();
                    if (this.getNodeHost()) this.done();
                    else this._parseCDN();
                }).bind(this));
                // Run parse
                cdnParser.parse(this._getInitialCdnResource(), this._responses);
            } else this._parseCDN();
        } else this.done();
    },
    /**
     * Replaces the resource and/or Cdn info for the /start service.
     *
     * @param {YBRequest} request YBRequest to transform.
     */ parse: function(request) {
        if (request.service === Constants.Service.START) {
            var lastSent = this._plugin.requestBuilder.lastSent;
            lastSent.parsedResource = request.params.parsedResource = this.getResource() || request.params.parsedResource;
            lastSent.transportFormat = request.params.transportFormat = this.getTransportFormat() || request.params.transportFormat;
            if (this._cdnEnabled) {
                lastSent.cdn = request.params.cdn = request.params.cdn || this.getCdnName();
                lastSent.nodeHost = request.params.nodeHost = this.getNodeHost() || request.params.nodeHost;
                lastSent.nodeType = request.params.nodeType = this.getNodeType() || request.params.nodeType;
                lastSent.nodeTypeString = request.params.nodeTypeString = this.getNodeTypeString() || request.params.nodeTypeString;
            }
        }
    }
});
module.exports = ResourceTransform;

},{"8e7025ecbec1b8a3":"8oBJA","18d2b12d2d609dc3":"4m7oU","abc3621d731d67a0":"dslIv","dc0c1e47ec773074":"1Hdwx","90f78bd262644e39":"8Pt5M","37063861862c0809":"2XeEE","545f3033b76999f1":"i5KqT","2a4f3463bc59f25c":"8xsxZ","b7894af02d627ec8":"92xpS"}],"4m7oU":[function(require,module,exports) {
var YBRequest = require("6ad764fe0602b3e7");
var Parser = require("3debcd72cd09b19e");
var Log = require("23c3c5a12daf37ef");
var TransportFormat = require("28028a44d65510fb");
var HlsParser = Parser.extend(/** @lends youbora.HlsParser.prototype */ {
    /**
     * Starts the HLS parsing from the given resource. The first (outside) call should set the
     * parentResource to null.
     *
     * @param {string} resource Either the resource url or the manifest body.
     * @param {string} parentResource Parent resource in case relative paths are sent.
     */ parse: function(resource, lastManifest, parentResource) {
        parentResource = parentResource || "";
        var matches = null;
        try {
            matches = /((\S*?)(\.m3u8|\.m3u|\.ts|\.m4s|\.mp4|\.cmfv|\.m4a)((\?|;)\S*|\n|\r|$))/i.exec(resource.replaceAll(",URI=", "\n").replaceAll('"', "").replaceAll(",", "\n"));
        } catch (err) {
            Log.warn("Parse HLS Regex failed", err);
            this.done();
        }
        if (matches !== null) {
            var res = matches[1].trim();
            var prevParent = "";
            var index = parentResource.lastIndexOf("/");
            if (res.indexOf("http") !== 0 && index !== -1) {
                // If does not start with http, add parentResource relative route.
                if (res[0] === "/" && res[1] !== "/") {
                    // if its a relative route not using the same path, but the same domain
                    var ind = parentResource.indexOf("/") + 1;
                    ind += parentResource.substr(ind, parentResource.length).indexOf("/") + 1 // Second '/'
                    ;
                    ind += parentResource.substr(ind, parentResource.length).indexOf("/") // Third '/'
                    ;
                    res = parentResource.slice(0, ind) + res;
                } else // if its sharing the (omitted) path
                res = parentResource.slice(0, index) + "/" + res;
                prevParent = parentResource.slice(0, index) + "/";
            }
            if (matches[3] === ".m3u8" || matches[3] === ".m3u") {
                if (!lastManifest) {
                    var request = new YBRequest(res, null, null, {
                        cache: true,
                        requestHeaders: this._headers
                    });
                    request.on(YBRequest.Event.SUCCESS, (function(resp) {
                        this._parseWithManifest(resp, prevParent, matches);
                    }).bind(this));
                    request.on(YBRequest.Event.ERROR, (function(resp) {
                        this.done();
                    }).bind(this));
                    request.send();
                } else this._parseWithManifest(lastManifest, prevParent, matches);
            } else {
                switch(matches[3]){
                    case ".mp4":
                    case ".m4s":
                    case ".m4a":
                        this._transportFormat = TransportFormat.MP4;
                        break;
                    case ".ts":
                        this._transportFormat = TransportFormat.MPEG2;
                        break;
                    case ".cmfv":
                        this._transportFormat = TransportFormat.CMF;
                }
                this._realResource = res;
                this.done();
            }
        } else this.done();
    },
    _parseWithManifest: function(resp, prevParent, matches) {
        this._lastManifest = resp;
        this.parse(resp.getResponseText(), null, prevParent + matches[2]);
    },
    shouldExecute: function(lastManifest) {
        var ret = true;
        if (lastManifest) {
            var response = lastManifest.getResponseText();
            ret = response.indexOf("#EXTM3U") !== -1;
        }
        return ret;
    }
});
module.exports = HlsParser;

},{"6ad764fe0602b3e7":"6hKtj","3debcd72cd09b19e":"2XeEE","23c3c5a12daf37ef":"8xsxZ","28028a44d65510fb":"czE3D"}],"2XeEE":[function(require,module,exports) {
var Emitter = require("dfef3a17911e8768");
var Parser = Emitter.extend(/** @lends youbora.Parser.prototype */ {
    /**
     * Class that asynchronously parses a resource in order to get to the URL.
     *
     * Since the CDN detection is performed with the resource url, it is essential that this
     * resource url is pointing to the CDN that is actually hosting the manifest.
     *
     * @constructs Parser
     * @extends youbora.Emitter
     * @memberof youbora
     */ constructor: function(headers) {
        this._realResource = null;
        this._lastManifest = null;
        this._transportFormat = null;
        this.iterations = 3;
        this._headers = headers;
    },
    /**
     * Emits DONE event
     */ done: function() {
        this.iterations = 3;
        this.emit(Parser.Event.DONE);
    },
    /**
     * Starts the parsing from the given resource.
     *
     * @param {string} resource The resource url.
     * @param {object} lastManifest The manifest request response if parsed previously.
     */ parse: function(resource, lastManifest) {},
    /**
     * Get the parsed resource. Will be null/undefined if parsing is not yet started and can be a partial
     * (an intermediate manifest) result if the parser is still running.
     *
     * @return {string} The parsed resource.
     */ getResource: function() {
        return this._realResource;
    },
    /**
     * Get the transport format. Will be null/undefined if parsing is not yet started or is still running.
     *
     * @return {string} The parsed resource.
     */ getTransportFormat: function() {
        return this._transportFormat;
    },
    /**
     * Get the last request manifest response object used to parse the resource.
     * Will be null/undefined if parsing is not yet started and can be a partial
     * (an intermediate manifest) result if the parser is still running.
     *
     * @return {object} The last manifest request response used to parse the resource.
     */ getLastManifest: function() {
        return this._lastManifest;
    },
    /**
     * Get the result of checking a previous manifest to detect if the parser should be used or not.
     *
     * @param {string} resource The resource url.
     * @return {object} The last manifest request response used to parse the resource.
     */ shouldExecute: function(lastManifest) {
        return true;
    }
}, /** @lends youbora.Parser */ {
    // Static members
    /**
     * List of events that could be fired from this class.
     * @enum
     */ Event: {
        /** Notifies that this DashParser is done processing. */ DONE: "done"
    }
});
module.exports = Parser;

},{"dfef3a17911e8768":"cuYJd"}],"czE3D":[function(require,module,exports) {
/**
 * List of transport formats
 *   - TS (MPEG-2 TS)
 *   - MP4 (Fragmented MP4)
 *   - CMF
 */ var TransportFormat = {
    MP4: "MP4",
    MPEG2: "TS",
    CMF: "CMF"
};
module.exports = TransportFormat;

},{}],"dslIv":[function(require,module,exports) {
var Emitter = require("81d470bcb602330e");
var Log = require("aeb7779ea10895fb");
var Util = require("f57842a37ad7fc67");
var YBRequest = require("2353f380042a266e");
var CdnParser = Emitter.extend(/** @lends youbora.CdnParser.prototype */ {
    /**
         * Class that asynchronously tries to get information about the CDN where a given resource is
         * hosted.
         *
         * The info we care about is the CDN code itself, the node host and node type.
         *
         * The CDN is queried with http HEAD requests. This only will work if the CDN has been properly
         * configured.
         *
         * When HEAD requests are performed against the resources, the CDN returns a set of headers that
         * contain info about the cdn header and/or cdn type.
         *
         * Each CDN is different; some require special headers to be set when the HEAD request is
         * performed and others don't. Also, the info can come back in any fashion of ways, sometimes
         * both type and host come in the same response header while sometimes they're in different
         * headers. The format of these response headers is also different from CDN to CDN, so a
         * different regex is used for each CDN.
         *
         * Lastly, as the values indicating the CDN type are also different, we need a specific mapping
         * for each one.
         *
         * Every instance of this class will represent a 'way' of parsing the HEAD response. So an
         * instance should be created for Level3, Akamai, Highwinds, etc...
         *
         * @constructs CdnParser
         * @extends youbora.Emitter
         * @memberof youbora
         *
         * @param {object} options This object represents the configuration of a certain CDN parsing
         * methodology.
         * @param {string} options.cdnName see {@link CdnParser#setCdnName}.
         * @param {array} options.parsers see {@link CdnParser#addParser}.
         * @param {array} options.requestMethod see {@link CdnParser#setRequestMethod}.
         * @param {array} options.requestHeaders see {@link CdnParser#setRequestHeader}.
         * @param {function} options.parseType see {@link CdnParser#setParseType}.
         */ constructor: function(options) {
        this._options = Util.assign({
            cdnName: null,
            parsers: [],
            requestMethod: "HEAD",
            requestHeaders: {},
            parseType: function() {
                return 0;
            }
        }, options);
        this._responses = {};
    },
    /**
         * Emits DONE event
         */ done: function() {
        this.emit(CdnParser.Event.DONE);
    },
    /**
         * Adds an object that represents a parse step of the headers.
         *
         * Each parser item will define the element parsed (whether if it is a host, a type, both...)
         * a headerName to parse (ie: x-cache) and a regex to execute over that header.
         *
         * @param {object} parser
         * @param {string} parser.element Which element will be parsed from the request.
         * Use {@link CdnParser.ElementType} enum.
         * @param {string} parser.headerName Name of the header to parse.
         * @param {regex} parser.regex Regex to match against the header content.
         *
         * @return itself to chain method calls
         */ addParser: function(parser) {
        this._options.parsers.push(parser);
        return this;
    },
    /**
         * Sets the cdn name. Note that this names are provided by Youbora and must coincede with the
         * ones offered here: {@link http://mapi.youbora.com:8081/cdns}.
         *
         * @return itself to chain method calls
         */ setCdnName: function(name) {
        this._options.cdnName = name;
        return this;
    },
    /**
         * Sets the method of the request. HEAD by default.
         *
         * @return itself to chain method calls
         */ setRequestMethod: function(method) {
        this._options.requestMethod = method;
        return this;
    },
    /**
         * if this CDN requires special headers to be set in order to respond with the info we want,
         * add them using this method.
         *
         * @param {string} key Name of the header.
         * @param {string} value Content of the header.
         *
         * @return itself to chain method calls
         */ setRequestHeader: function(key, value) {
        this._options.requestHeaders[key] = value;
        return this;
    },
    /**
         * Adds a parsing function for parsing the type (hit or miss) of the request.
         *
         * Parser fucntion will receive a string parsed from a type header (see
         * {@link CdnParser#addParser}). Should return 1 in case of HIT, 2 in case of MISS and
         * 0 otherwise.
         *
         * @param {function} parser Parsing function
         *
         * @return itself to chain method calls
         */ setParseType: function(parser) {
        this._options.parseType = parser;
        return this;
    },
    /**
         * Get parsed CDN name.
         *
         * @return {string} The CDN name or null if unknown
         */ getParsedCdnName: function() {
        return this._cdnName;
    },
    /**
         * Get the parsed CDN node.
         *
         * @return {string} The CDN node or null if unknown
         */ getParsedNodeHost: function() {
        return this._cdnNodeHost;
    },
    /**
         * Get the parsed CDN type string, as returned in the cdn header response.
         *
         * @return {string} The CDN type string
         */ getParsedNodeTypeString: function() {
        return this._cdnNodeTypeString;
    },
    /**
         * Get the parsed CDN type, parsed from the type string.
         *
         * @return {string} The CDN type
         */ getParsedNodeType: function() {
        return this._cdnNodeType;
    },
    /**
         * Returns the request responses from this CdnParser.
         * This is filled with the responses from the constructor, or created empty if null.
         * Then the performed request response (if any) is added to this map.
         * Call this method after "using" the CdnParser and pass the responses to the following
         * CdnParser so it can use the responses if it applies.
         * @return the request responses
         */ getResponses: function() {
        return this._responses;
    },
    /**
         * Parses given headers to check for matches.
         */ parse: function(url, responses) {
        this._responses = responses || {};
        var headerString = JSON.stringify(this._options.requestHeaders);
        if (this._responses[headerString]) this._parseResponse(this._responses[headerString]);
        else this._requestResponse(url);
    },
    _requestResponse: function(url) {
        var headerString = JSON.stringify(this._options.requestHeaders);
        var useheaders = headerString !== "{}";
        var request = new YBRequest(url, null, null, {
            method: this._options.requestMethod,
            maxRetries: 0,
            requestHeaders: this._options.requestHeaders,
            cache: true
        });
        request.on(YBRequest.Event.SUCCESS, (function(resp) {
            this._responses[headerString] = resp.getResponseHeaders();
            this._parseResponse(this._responses[headerString]);
        }).bind(this));
        request.on(YBRequest.Event.ERROR, (function(resp) {
            if (useheaders) {
                this._options.requestHeaders = {};
                this._requestResponse(url);
            } else this.done();
        }).bind(this));
        request.send();
    },
    /**
     *
     * @param headers
     * @private
     */ _parseResponse: function(headers) {
        this._options.parsers.forEach((function(parser) {
            if (typeof parser.headerName === "string") this._parseHeaderResponse(headers, parser, parser.headerName);
            else if (Array.isArray(parser.headerName)) for(var i = 0, len = parser.headerName.length; i < len; i++){
                var headerNameElement = parser.headerName[i];
                if (typeof headerNameElement === "string") this._parseHeaderResponse(headers, parser, headerNameElement);
            }
        }).bind(this));
        this.done();
    },
    /**
     *
     * @param headers
     * @param parser
     * @param parser
     * @private
     */ _parseHeaderResponse: function(headers, parser, headerName) {
        if (headerName) {
            headerName = headerName ? headerName.toLowerCase() : "";
            headers.split("\n").forEach((function(line) {
                var index = line.indexOf(":");
                if (index !== -1) {
                    var key = line.slice(0, index).toLowerCase();
                    if (key === headerName) this._executeParser(parser, line.slice(index + 1));
                }
            }).bind(this));
        }
    },
    _executeParser: function(parser, value) {
        try {
            var matches = parser.regex.exec(value.trim());
            if (matches !== null) {
                if (this._options.cdnName) this._cdnName = this._options.cdnName;
                switch(parser.element){
                    case CdnParser.ElementType.HOST:
                        this._cdnNodeHost = matches[1];
                        break;
                    case CdnParser.ElementType.TYPE:
                        this._cdnNodeTypeString = matches[1];
                        this._cdnNodeType = this._options.parseType(this._cdnNodeTypeString);
                        break;
                    case CdnParser.ElementType.HOST_AND_TYPE:
                        this._cdnNodeHost = matches[1];
                        this._cdnNodeTypeString = matches[2];
                        this._cdnNodeType = this._options.parseType(this._cdnNodeTypeString);
                        break;
                    case CdnParser.ElementType.TYPE_AND_HOST:
                        this._cdnNodeTypeString = matches[1];
                        this._cdnNodeType = this._options.parseType(this._cdnNodeTypeString);
                        this._cdnNodeHost = matches[2];
                        break;
                    case CdnParser.ElementType.NAME:
                        this._cdnName = matches[1].toUpperCase();
                        break;
                }
            }
        } catch (err) {
            Log.warn("CDN parsing for " + this._options.cdnName + " could not parse header value " + value);
        }
    },
    shouldExecute: function() {
        return true;
    }
}, /** @lends youbora.CdnParser */ {
    // Static members
    /**
         * List of events that could be fired from this class.
         *
         * @enum
         */ Event: {
        /** Notifies that this CdnParser is done processing. */ DONE: "done"
    },
    /**
         * Possible different bits of info we can get from a header.
         *
         * @enum
         */ ElementType: {
        HOST: "host",
        TYPE: "type",
        HOST_AND_TYPE: "host+type",
        TYPE_AND_HOST: "type+host",
        NAME: "name"
    },
    /**
         * List of available CDN parsers.
         * @private
         */ _cdnConfigs: {},
    /**
         * This is a special case. The BalancerCdnParser is a custom CDN definition
         * that tries to get the CDN name directly from one of the headers. This method can be used
         * as a shortcut to creating a new CDN definition.
         *
         * This is usually used with DNS-based load balance services, such as Cedexis.
         *
         * Youboralib will use this method by itself using the configuration passed in the
         * {@link Options}.
         *
         * @param {string} cdnNameHeader the header response name where to get the CDN name from.
         * @param {string} cdnNodeNameHeader the header response name where to get the host name from.
         */ setBalancerHeaderName: function(name, nodename) {
        CdnParser._cdnConfigs.Balancer.parsers[0].headerName = name;
        CdnParser._cdnConfigs.Balancer.parsers[1].headerName = nodename;
    },
    /**
         * Create one of the pre-defined CDN parsers. This method will be called with the keys passed
         * to {@link Options#'parse.CdnNode.list'}.
         *
         * Before using this method, configs must be added first using {@link CdnParser.add}.
         *
         * @param {string} cdnName Name of the CDN
         * @return {CdnParser} An instance or undefined if the names does not match any CDN.
         */ create: function(key) {
        if (CdnParser._cdnConfigs[key]) return new CdnParser(CdnParser._cdnConfigs[key]);
        else Log.warn("Tried to create an unexisting CdnParser named " + key);
    },
    /**
         * Adds the given CdnParser's config to the available list. Objects sent must comply with
         * CdnParser constructor.
         *
         * @param {string} key The name that will identify the CDN.
         * @param {Object} config The parser that defines the CDN.
         */ add: function(key, config) {
        CdnParser._cdnConfigs[key] = config;
    }
});
// Adding built-in parsers
CdnParser.add("Level3", require("e8027afd1dcbe323"));
CdnParser.add("Cloudfront", require("b79e1bee9416f062"));
CdnParser.add("Akamai", require("5d5fef852ee86226"));
CdnParser.add("Highwinds", require("22afa54592a77d09"));
CdnParser.add("Fastly", require("8e4d8cec86d34415"));
CdnParser.add("Telefonica", require("ca027a09894003b5"));
CdnParser.add("Amazon", require("2c239fa83c42255e"));
CdnParser.add("Edgecast", require("31300c8ea690db85"));
CdnParser.add("Balancer", require("4e96919afde9b4a"));
CdnParser.add("NosOtt", require("361b42091266cf17"));
module.exports = CdnParser;

},{"81d470bcb602330e":"cuYJd","aeb7779ea10895fb":"8xsxZ","f57842a37ad7fc67":"drhpF","2353f380042a266e":"6hKtj","e8027afd1dcbe323":"1QL9q","b79e1bee9416f062":"2hPgo","5d5fef852ee86226":"6caXc","22afa54592a77d09":"5VVNG","8e4d8cec86d34415":"jsgg9","ca027a09894003b5":"3Hlkj","2c239fa83c42255e":"9ZP2I","31300c8ea690db85":"1lUp9","4e96919afde9b4a":"imOXI","361b42091266cf17":"hhP75"}],"1QL9q":[function(require,module,exports) {
// {@see CdnParser}
module.exports = {
    cdnName: "LEVEL3",
    parsers: [
        {
            element: "host+type",
            headerName: "X-WR-Diag",
            regex: /Host:(.+)\sType:(.+)/
        }
    ],
    requestHeaders: {
        "X-WR-Diag": "host"
    },
    parseType: function(type) {
        if (type) {
            if (type.indexOf("TCP_HIT") === 0 || type.indexOf("TCP_MEM_HIT") === 0 || type.indexOf("TCP_IMS_HIT") === 0) return 1;
            else if (type.indexOf("TCP_MISS") === 0) return 2;
        }
        return 0;
    }
};

},{}],"2hPgo":[function(require,module,exports) {
// {@see CdnParser}
module.exports = {
    cdnName: "CLOUDFRT",
    parsers: [
        {
            element: "host",
            headerName: "X-Amz-Cf-Id",
            regex: /(.+)/
        },
        {
            element: "type",
            headerName: "X-Cache",
            regex: /(\S+)\s.+/
        }
    ],
    parseType: function(type) {
        switch(type){
            case "Hit":
                return 1;
            case "Miss":
                return 2;
            default:
                return 0;
        }
    }
};

},{}],"6caXc":[function(require,module,exports) {
// {@see CdnParser}
module.exports = {
    cdnName: "AKAMAI",
    // requestMethod: 'GET',
    parsers: [
        {
            element: "type+host",
            headerName: "X-Cache",
            regex: /(.+)\sfrom.+AkamaiGHost\/(.+)\).+/
        },
        {
            element: "host",
            headerName: "akamai-mon-iucid-del",
            regex: /(.*)/
        },
        {
            element: "type",
            headerName: "akamai-cache-status",
            regex: /(.+)\sfrom\schild/
        }
    ],
    requestHeaders: {
        Pragma: "akamai-x-cache-on"
    },
    parseType: function(type) {
        var t = type.toLowerCase();
        if (t.indexOf("hit") !== -1) return 1;
        else if (t.indexOf("miss") !== -1) return 2;
        return 0;
    }
};

},{}],"5VVNG":[function(require,module,exports) {
// {@see CdnParser}
module.exports = {
    cdnName: "HIGHNEGR",
    parsers: [
        {
            element: "host+type",
            headerName: "X-HW",
            regex: /.+,[0-9]+\.(.+)\.(.+)/
        }
    ],
    parseType: function(type) {
        switch(type){
            case "c":
            case "x":
                return 1;
            default:
                return 2;
        }
    }
};

},{}],"jsgg9":[function(require,module,exports) {
// {@see CdnParser}
module.exports = {
    cdnName: "FASTLY",
    parsers: [
        {
            element: "host",
            headerName: "X-Served-By",
            regex: /([^,\s]+)$/
        },
        {
            element: "type",
            headerName: "X-Cache",
            regex: /([^,\s]+)$/
        }
    ],
    parseType: function(type) {
        switch(type){
            case "HIT":
                return 1;
            case "MISS":
                return 2;
            default:
                return 0;
        }
    }
};

},{}],"3Hlkj":[function(require,module,exports) {
// {@see CdnParser}
module.exports = {
    cdnName: "TELEFO",
    parsers: [
        {
            element: "host+type",
            headerName: "x-tcdn",
            regex: /Host:(.+)\sType:(.+)/
        }
    ],
    requestHeaders: {
        "x-tcdn": "host"
    },
    parseType: function(type) {
        if (type) {
            if (type.indexOf("p") !== -1 || type.indexOf("c") !== -1) return 1;
            else if (type.indexOf("i") !== -1 || type.indexOf("m") !== -1) return 2;
        }
        return 0;
    }
};

},{}],"9ZP2I":[function(require,module,exports) {
// {@see CdnParser}
module.exports = {
    cdnName: "AMAZON",
    parsers: [
        {
            element: "host",
            headerName: "x-amz-cf-pop",
            regex: /(.+)/
        },
        {
            element: "type",
            headerName: "x-cache",
            regex: /(.+)\sfrom.+/
        }
    ],
    parseType: function(type) {
        if (type.toLowerCase().indexOf("hit") !== -1) return 1;
        else if (type.toLowerCase().indexOf("miss") !== -1) return 2;
        return 0;
    }
};

},{}],"1lUp9":[function(require,module,exports) {
// {@see CdnParser}
module.exports = {
    cdnName: "EDGECAST",
    parsers: [
        {
            element: "host",
            headerName: "Server",
            regex: /\((.+)\/.+\)/
        },
        {
            element: "type",
            headerName: "X-Cache",
            regex: /(.+)/
        }
    ],
    parseType: function(type) {
        switch(type){
            case "HIT":
                return 1;
            case "MISS":
            default:
                return 2;
        }
    }
};

},{}],"imOXI":[function(require,module,exports) {
// {@see CdnParser}
module.exports = {
    parsers: [
        {
            element: "name",
            headerName: null,
            regex: /(.+)/
        },
        {
            element: "host",
            headerName: null,
            regex: /(.+)/
        }
    ]
};

},{}],"hhP75":[function(require,module,exports) {
// {@see CdnParser}
module.exports = {
    cdnName: "NOSOTT",
    parsers: [
        {
            element: "host",
            headerName: "X-NOS-Server",
            regex: /(.+)/
        },
        {
            element: "type",
            headerName: "X-Cache",
            regex: /(.*)/
        }
    ],
    parseType: function(type) {
        switch(type){
            case "Hit":
                return 1;
            case "Miss":
                return 2;
            default:
                return 0;
        }
    }
};

},{}],"1Hdwx":[function(require,module,exports) {
var Emitter = require("11431be4e718a3d1");
var Log = require("6a8f1aac1ac8550");
var YBRequest = require("31d375b02ee2cb9c");
var CdnSwitch = Emitter.extend({
    constructor: function(plugin) {
        this.plugin = plugin;
        this.headerName = "x-cdn";
    },
    init: function() {
        var url = null;
        if (this.plugin) {
            if (this.plugin.getAdapter() && this.plugin.getAdapter().getURLToParse()) url = this.plugin.getAdapter().getURLToParse();
            else url = this.plugin.getResource();
        }
        if (this.plugin && this.plugin.getAdapter() && this.plugin.getAdapter().flags.isStarted) this._request(url);
    },
    done: function(data) {
        this.emit(CdnSwitch.Events.DONE, data);
    },
    error: function() {
        this.emit(CdnSwitch.Events.ERROR);
    },
    _successfulRequest: function(resp) {
        setTimeout(this.init.bind(this), parseInt(this.plugin.options["parse.cdnTTL"]) * 1000);
        var headers = resp.getResponseHeaders().split("\n");
        var cdn = null;
        for(var i in headers){
            var line = headers[i];
            var index = line.indexOf(this.headerName);
            if (index > -1) cdn = line.substring(index + this.headerName.length + 1, line.length - 1).replace(" ", "");
        }
        this.done(cdn);
    },
    _failedRequest: function() {
        setTimeout(this.init.bind(this), parseInt(this.plugin.options["parse.cdnTTL"]) * 1000);
        Log.warn("CDN switch detection request failed");
        this.error();
    },
    _request: function(url) {
        var request = new YBRequest(url, null, null, {
            method: "HEAD",
            cache: true
        });
        request.on(YBRequest.Event.SUCCESS, this._successfulRequest.bind(this));
        request.on(YBRequest.Event.ERROR, this._failedRequest.bind(this));
        request.send();
    }
}, {
    Events: {
        DONE: "done",
        ERROR: "error"
    }
});
module.exports = CdnSwitch;

},{"11431be4e718a3d1":"cuYJd","6a8f1aac1ac8550":"8xsxZ","31d375b02ee2cb9c":"6hKtj"}],"8Pt5M":[function(require,module,exports) {
var YBRequest = require("8c1a52510e28022");
var Parser = require("82b18220a4b5952c");
var Log = require("4f3fa2fea628837");
var TransportFormat = require("361b71b64a25f876");
var DashParser = Parser.extend(/** @lends youbora.DashParser.prototype */ {
    /**
     * Starts the Dash parsing from the given resource. The first (outside) call should set the
     * parentResource to null.
     *
     * @param {string} resource The resource url.
     */ parse: function(resource, lastManifest) {
        if (!lastManifest) {
            var request = new YBRequest(resource, null, null, {
                cache: true,
                requestHeaders: this._headers
            });
            request.on(YBRequest.Event.SUCCESS, (function(resp) {
                this.parseLocation(resp, resource);
            }).bind(this));
            request.on(YBRequest.Event.ERROR, (function(resp) {
                this.done();
            }).bind(this));
            request.send();
        } else this.parseLocation(lastManifest, resource);
    },
    parseLocation: function(lastManifest, resource) {
        this.iterations--;
        var locationRegexp = new RegExp(/<Location>([\s\S]+)<\/Location>/);
        try {
            this._lastManifest = lastManifest;
            var manifest = lastManifest.getResponseText();
            var matches = locationRegexp.exec(manifest);
            if (matches && matches[1]) var newRes = this._htmlDecode(matches[1].replace("\n", ""));
            if (newRes && newRes !== resource && this.iterations > 0) this.parse(newRes);
            else this.parseFinalResource(manifest, resource);
        } catch (err) {
            Log.warn("Dash parse failed");
            this.done();
        }
    },
    _htmlDecode: function(input) {
        if (typeof document !== "undefined" && typeof document.createElement === "function") {
            var e = document.createElement("textarea");
            e.innerHTML = input;
            return e.childNodes && e.childNodes.length ? e.childNodes[0].nodeValue : input;
        }
        return input;
    },
    parseFinalResource: function(manifest, resource) {
        var baseUrlRegexp = new RegExp(/<BaseURL>[\r\n]*(.*?)[\r\n]*<\/BaseURL>/);
        var segmentUrlRegexp = new RegExp(/<SegmentURL[\s\S]*media="([^"]+)/);
        var segmentTemplateRegexp = new RegExp(/<SegmentTemplate[\s\S]*media="([^"]+)/);
        var matches = null;
        // first: base url, second: segment url, third: segment template
        try {
            matches = baseUrlRegexp.exec(manifest) || segmentTemplateRegexp.exec(manifest) || segmentUrlRegexp.exec(manifest);
            this._getManifestMetadata(manifest);
            if (matches && matches[1] && this._isFullUrl(matches[1])) {
                if (matches[1].indexOf('"') > 0) this._realResource = matches[1].substr(0, matches[1].indexOf('"')).replace("\n", "");
                else this._realResource = matches[1].replace("\n", "");
            } else this._realResource = resource;
        } catch (err) {
            Log.warn("Dash manifest parse failed");
        }
        this.done();
    },
    _getManifestMetadata: function(manifest) {
        try {
            var transportFormatRegexp = new RegExp(/<AdaptationSet[\s\S]*mimeType="video\/([^"]+)/);
            var matches = transportFormatRegexp.exec(manifest);
            var ret = null;
            switch(matches[1]){
                case "mp4":
                case "m4s":
                    ret = TransportFormat.MP4;
                    break;
                case "mp2t":
                    ret = TransportFormat.MPEG2;
                    break;
                case "cmfv":
                    ret = TransportFormat.CMF;
                    break;
            }
            this._transportFormat = ret;
        } catch (err) {
            Log.warn("Couldnt find the transport format");
        }
    },
    _isFullUrl: function(url) {
        return url.indexOf("http") !== -1;
    },
    shouldExecute: function(lastManifest) {
        var ret = true;
        if (lastManifest) {
            var response = lastManifest.getResponseText();
            ret = response.indexOf("<MPD") !== -1;
        }
        return ret;
    }
});
module.exports = DashParser;

},{"8c1a52510e28022":"6hKtj","82b18220a4b5952c":"2XeEE","4f3fa2fea628837":"8xsxZ","361b71b64a25f876":"czE3D"}],"i5KqT":[function(require,module,exports) {
var YBRequest = require("2e3732f01168e810");
var Parser = require("32d0a2115da225d");
var LocationheaderParser = Parser.extend(/** @lends youbora.LocationheaderParser.prototype */ {
    /**
     * Parses given header to check.
     */ parse: function(url, lastManifest) {
        if (!lastManifest) {
            this._realResource = url;
            var request = new YBRequest(url, null, null, {
                cache: true,
                requestHeaders: this._headers
            });
            request.on(YBRequest.Event.SUCCESS, (function(resp) {
                this._parseWithManifest(resp);
            }).bind(this));
            request.on(YBRequest.Event.ERROR, (function(resp) {
                this.done();
            }).bind(this));
            request.send();
        } else this._parseWithManifest(lastManifest);
    },
    _parseWithManifest: function(resp) {
        this._lastManifest = resp;
        var response = resp.getResponseHeaders();
        var found = false;
        if (resp && resp.xhr && resp.xhr.responseURL && resp.xhr.responseURL !== this._realResource) {
            this._realResource = resp.xhr.responseURL;
            this.parse(this._realResource);
            found = true;
        } else response.split("\n").forEach((function(line) {
            if (line.startsWith("Location:")) {
                this._realResource = line.slice(10);
                this.parse(this._realResource);
                found = true;
            }
        }).bind(this));
        if (!found) this.done();
    }
});
module.exports = LocationheaderParser;

},{"2e3732f01168e810":"6hKtj","32d0a2115da225d":"2XeEE"}],"9eqxK":[function(require,module,exports) {
var Transform = require("ed6d214769145b4f");
var OfflineTransform = Transform.extend(/** @lends youbora.OfflineTransform.prototype */ {
    /**
     * This class manages Fastdata service and view index.
     *
     * @constructs
     * @extends youbora.Transform
     * @memberof youbora
     *
     * @param {Plugin} plugin Instance of {@link Plugin}
     * @param {string} session If provided, plugin will use this as a FD response.
     */ constructor: function(plugin, session) {
        this._sendRequest = false;
        this._isBusy = false;
        this.plugin = plugin;
        this.session = session;
        this.transformName = "Offline";
    },
    /**
     * Transform requests
     * @param {youbora.comm.YBRequest} request YBRequest to transform.
     */ parse: function(request) {
        if (request && this.plugin.offlineStorage) this.plugin.offlineStorage.addEvent(request.service, request.params);
    },
    hasToSend: function(request) {
        return false;
    },
    getState: function() {
        return Transform.STATE_OFFLINE;
    }
});
module.exports = OfflineTransform;

},{"ed6d214769145b4f":"8oBJA"}],"f2zFO":[function(require,module,exports) {
var YouboraObject = require("2ae1c4f37d9a38ba");
var DeprecatedOptions = require("4239f4aad72e93c0");
var Log = require("78c79b1aff37b944");
var TransportFormat = require("ab6ae67ae2ceb853");
var StreamingProtocol = require("d1cc89687ecfbfb5");
var RequestMethod = require("6a1bc31e754b6103");
var Options = YouboraObject.extend(/** @lends youbora.Options.prototype */ {
    /**
     * This Class store youbora configuration settings.
     * Any value specified in this class, if set, will override the info the plugin is able to get
     * on its own.
     *
     * @constructs Options
     * @param {Object|Options} [options] A literal containing values.
     * @extends youbora.YouboraObject
     * @memberof youbora
     */ constructor: function(options) {
        /** @prop {boolean} [enabled=true] If false, the plugin won't send NQS requests. */ this.enabled = true;
        /** @prop {string} [host='a-fds.youborafds01.com'] Host of the Fastdata service. */ this.host = "a-fds.youborafds01.com";
        /**
      * @prop {string} [accountCode='nicetest']
      * NicePeopleAtWork account code that indicates the customer account.
      */ this.accountCode = "nicetest";
        /**
       * @prop {string} [authToken]
       * Optional auth token to validate all the requests
       */ this.authToken = null;
        /**
       * @prop {string} [authType]
       * Optional auth type. Used if authToken is set.
       * 'Bearer' by default.
       */ this.authType = "Bearer";
        /**
      *  @prop {boolean} [preventZombieViews=true]
      * If true, the plugin will check if the last event
      * was sent more than 10 mins ago
      * so it will not send more events to the same view
      */ this.preventZombieViews = true;
        /**
      * @prop {boolean} [offline=false]
      * If true the plugin will store the events and send them later when there's connection
      */ this.offline = false;
        /** @prop {string} [referer] Site url.
      *  By default window.location.href */ this.referer = null;
        /** @prop {string} [referral] Previous site url.
      *  By default document.referrer */ this.referral = null;
        /**
      * @prop {boolean} [disableCookies]
      * To disable cookies storage fallback after local/sessionstorage
      * True by default
      */ this.disableCookies = true;
        /**
      * @prop {boolean} [forceCookies]
      * To force the use of cookies storage instead of local/sessionstorage
      * False by default
      */ this.forceCookies = false;
        /**
      * @prop {boolean} [disableStorage]
      * To disable all possible storages usage (cookies, localStorage, sessionStorage)
      * CAUTION: enabling this option session tracking may stop to work properly
      * False by default
      */ this.disableStorage = false;
        // USER
        /**
      * @prop {string} [user.email]
      * User email.
      */ this["user.email"] = null;
        /**
      * @prop {string} [user.type]
      * User type.
      */ this["user.type"] = null;
        /**
      * @prop {string} [user.name]
      * User ID value inside your system.
      */ this["user.name"] = null;
        /**
      *  @prop {boolean} [user.obfuscateIp=false]
      * If true, the view will have the IP obfuscated
      */ this["user.obfuscateIp"] = false;
        /**
      * @prop {string} [user.anonymousId]
      * Anonymous identifyer of the user provided by the customer.
      */ this["user.anonymousId"] = null;
        /**
      * @prop {string} [user.privacyProtocol]
      * Privacy protocol to be used, nothing by default.
      * Possible values are "optin" and "optout"
      */ this["user.privacyProtocol"] = null;
        // PARSERS
        /**
      * @prop {boolean} [parse.manifest=false]
      * If true the plugin will look for location value in manifest header to retrieve the actual resource,
      * will parse HLS files to use the first .ts file found as resource and
      * will look for location and segment values inside DASH manifest to retrieve the actual resource
      * It might slow performance down.
      */ this["parse.manifest"] = false;
        /**
      * @prop {object} [parse.manifest.auth={}]
      * If parse.manifest enabled, it adds extra headers to the request of the content.
      * Use this if for example, the player needs to include authentication headers to request the content,
      * so the plugin needs it to access to the manifest files too.
      */ this["parse.manifest.auth"] = {};
        /**
       * @prop {array<string>} [parse.CdnNameHeader]
       * If defined, resource parse will try to fetch the CDN code from the custom header defined
       * by this property. ie: '[x-cdn-forward]'
       */ this["parse.cdnNameHeader"] = [
            "x-cdn-forward"
        ];
        /**
      * @prop {string} [parse.CdnNodeHeader]
      * If defined, resource parse will try to fetch the CDN node name from the custom header defined
      * by this property. ie: 'x-node'
      */ this["parse.cdnNodeHeader"] = "";
        /**
      * @prop {boolean} [parse.CdnNode=false]
      * If true the plugin will query the CDN to retrieve the node name.
      * It might slow performance down.
      */ this["parse.cdnNode"] = false;
        /**
      * @prop {array<string>} [parse.CdnNode.list=false]
      * If true the plugin will query the CDN to retrieve the node name.
      * It might slow performance down.
      */ this["parse.cdnNode.list"] = [
            "Akamai",
            "Amazon",
            "Cloudfront",
            "Level3",
            "Fastly",
            "Highwinds",
            "Telefonica",
            "Edgecast",
            "NosOtt"
        ];
        /**
       * @prop {function} [parse.fdsResponseHost=null]
       * Parses fastdata response to modify the host where the requests will be sent
       */ this["parse.fdsResponseHost"] = null;
        /**
       * @prop {function} [parse.cdnSwitchHeader=false]
       * Parses a video chunk or manifest every x seconds to read the x-cdn header and report it
       */ this["parse.cdnSwitchHeader"] = false;
        /**
       * @prop {function} [parse.cdnTTL=60]
       * if parse.cdnSwitchHeader enabled, the time between new requests
       */ this["parse.cdnTTL"] = 60;
        // NETWORK
        /** @prop {string} [network.ip] IP of the viewer/user. ie= '100.100.100.100'. */ this["network.ip"] = null;
        /** @prop {string} [network.isp] Name of the internet service provider of the viewer/user. */ this["network.isp"] = null;
        /**
      * @prop {string} [network.connectionType]
      * Type of connection used
      */ this["network.connectionType"] = null;
        // DEVICE
        /**
       * @prop {string} [device.id]
       * Unique identifyer of the device. If set it will consider the value as the device id.
       * By default the plugin tries to generate a unique id based on exposed information on the browser.
       * It wont be sent if 'device.isAnonymous option' is set to true.
       */ this["device.id"] = null;
        /**
      * @prop {string} [device.code]
      * Youbora's device code. If specified it will rewrite info gotten from user agent.
      * See a list of codes in {@link http://mapi.youbora.com/devices}
      */ this["device.code"] = null;
        /**
      * @prop {string} [device.model]
      * Device model name
      */ this["device.model"] = null;
        /**
      * @prop {string} [device.brand]
      * Device vendor name
      */ this["device.brand"] = null;
        /**
      * @prop {string} [device.type]
      * Device type (pc, smartphone, stb, tv, etc.)
      */ this["device.type"] = null;
        /**
      * @prop {string} [device.name]
      * Device name. It must exist in NPAW database.
      */ this["device.name"] = null;
        /**
      * @prop {string} [device.osName]
      * OS name.
      */ this["device.osName"] = null;
        /**
      * @prop {string} [device.osVersion]
      * OS version.
      */ this["device.osVersion"] = null;
        /**
      * @prop {string} [device.browserName]
      * Browser name.
      */ this["device.browserName"] = null;
        /**
      * @prop {string} [device.browserVersion]
      * Browser version.
      */ this["device.browserVersion"] = null;
        /**
      * @prop {string} [device.browserType]
      * Browser type.
      */ this["device.browserType"] = null;
        /**
      * @prop {string} [device.browserEngine]
      * Browser engine.
      */ this["device.browserEngine"] = null;
        /**
      * @prop {string} [device.EDID]
      * Connected screen EDID.
      * The expected format is a hex value
      */ this["device.EDID"] = null;
        /**
      * @prop {bool} [device.isAnonymous]
      * If true, it blocks 'deviceUUID' parameter in requests.
      */ this["device.isAnonymous"] = false;
        // CONTENT
        /** @prop {string} [content.transactionCode] Custom unique code to identify the view. */ this["content.transactionCode"] = null;
        /** @prop {string} [content.resource] URL/path of the current media resource. */ this["content.resource"] = null;
        /** @prop {boolean} [content.isLive] True if the content is live false if VOD. */ this["content.isLive"] = null;
        /** @prop {boolean} [content.isLive.noSeek] True if the player seeks automatically when resumed or ending buffer. Only for live content. False by default */ this["content.isLive.noSeek"] = false;
        /** @prop {boolean} [content.isLive.noMonitor] True if the player returns non consistent values for the playhead on live, so playhead monitor wont work to detect buffers and seeks. False by default. */ this["content.isLive.noMonitor"] = false;
        /** @prop {string} [content.title] Title of the media. */ this["content.title"] = null;
        /** @prop {string} [content.program] Secondary title of the media */ this["content.program"] = null;
        /** @prop {number} [content.duration] Duration of the media. */ this["content.duration"] = null;
        /** @prop {number} [content.fps] Frames per second of the content in the current moment. */ this["content.fps"] = null;
        /** @prop {number} [content.segmentDuration] Video segment length in milliseconds. */ this["content.segmentDuration"] = null;
        /** @prop {number} [content.bitrate] Bitrate of the content in bits per second. */ this["content.bitrate"] = null;
        /** @prop {number} [content.totalBytes] Total downloaded bytes of the content. */ this["content.totalBytes"] = null;
        /** @prop {bool} [content.sendTotalBytes] Additionaly report totalbytes or not, default false. */ this["content.sendTotalBytes"] = false;
        /** @prop {number} [content.throughput] Throughput of the client bandwith in bits per second. */ this["content.throughput"] = null;
        /** @prop {string} [content.rendition] Name of the current rendition of the content. */ this["content.rendition"] = null;
        /**
       * @prop {string} [content.cdn]
       * Codename of the CDN where the content is streaming from.
       * See a list of codes in {@link http://mapi.youbora.com/cdns}
       * */ this["content.cdn"] = null;
        /** @prop {string} [content.cdnNode] CDN node id */ this["content.cdnNode"] = null;
        /**
       * @prop {number} [content.cdnType] CDN node content access type
       * It defines if the content request hits the cache or not
       * TCP_HIT / HIT: 1
       * TCP_MISS / MISS: 2
       * TCP_MEM_HIT: 3
       * TCP_IMS_HIT: 4
       */ this["content.cdnType"] = null;
        /**
       * @prop {object} [content.metadata]
       * Item containing mixed extra information about the content like: director, parental rating,
       * device info or the audio channels.This object may store any serializable key:value info.
       */ this["content.metadata"] = {};
        /**
       * @prop {object} [content.metrics]
       * Item containing metrics in json format. Reported every ping if the values change
       */ this["content.metrics"] = {};
        /** @prop {string} [content.streamingProtocol] Name of the streaming media protocol.
       * Can be:
       *   - HDS (Adobe HDS)
       *   - HLS (Apple HLS)
       *   - MSS (Microsoft Smooth Streaming)
       *   - DASH (MPEG-DASH)
       *   - RTMP (Adobe RTMP)
       *   - RTP (RTP)
       *   - RTSP (RTSP)
       *   - MULTICAST (Multicast)
       *   - DVB (DVB)
       *   - DVBC (DVB-C)
       *   - DVBT (DVB-T)
       *   - DVBT2 (DVB-T2)
       */ this["content.streamingProtocol"] = null;
        /** @prop {string} [content.transportFormat] Name of the transport format.
       * Can be:
       *   - TS (MPEG-2 TS)
       *   - MP4 (Fragmented MP4)
       */ this["content.transportFormat"] = null;
        /** @prop {number} [content.package] Package of the media. */ this["content.package"] = null;
        /** @prop {number} [content.saga] Saga of the media. */ this["content.saga"] = null;
        /** @prop {number} [content.tvShow] TV Show of the media. */ this["content.tvShow"] = null;
        /** @prop {number} [content.season] Season of the media. */ this["content.season"] = null;
        /** @prop {number} [content.episodeTitle] Episode title of the media. */ this["content.episodeTitle"] = null;
        /** @prop {number} [content.channel] Channel name of the media. */ this["content.channel"] = null;
        /** @prop {number} [content.id] ID of the media. */ this["content.id"] = null;
        /** @prop {number} [content.imdbId] IMDB id of the media. */ this["content.imdbId"] = null;
        /** @prop {number} [content.gracenoteId] Gracenote id of the media. */ this["content.gracenoteId"] = null;
        /** @prop {number} [content.type] Type of the media. */ this["content.type"] = null;
        /** @prop {number} [content.genre] Genre of the media. */ this["content.genre"] = null;
        /** @prop {number} [content.language] Language of the media. */ this["content.language"] = null;
        /** @prop {boolean} [content.autodetect.language] Auto detect change languages value. */ this["content.autodetect.language"] = true;
        /** @prop {number} [content.subtitles] Subtitles of the media. */ this["content.subtitles"] = null;
        /** @prop {boolean} [content.autodetect.subtitles] Auto detect change subtitles value. */ this["content.autodetect.subtitles"] = true;
        /** @prop {number} [content.contractedResolution] Contracted Resolution of the media. */ this["content.contractedResolution"] = null;
        /** @prop {number} [content.cost] Cost of the media. */ this["content.cost"] = null;
        /** @prop {number} [content.price] Price of the media. */ this["content.price"] = null;
        /** @prop {number} [content.playbackType] Type of the media. Can be Vod, Live, catch-up or offline */ this["content.playbackType"] = null;
        /** @prop {number} [content.drm] DRM of the media. */ this["content.drm"] = null;
        // Encoding
        /** @prop {number} [content.encoding.videoCodec] Video codec of the media. */ this["content.encoding.videoCodec"] = null;
        /** @prop {number} [content.encoding.audioCodec] Audio codec of the media. */ this["content.encoding.audioCodec"] = null;
        /** @prop {number} [content.encoding.codecSettings] Codec settings of the media. */ this["content.encoding.codecSettings"] = null;
        /** @prop {number} [content.encoding.codecProfile] Codec profile of the media. */ this["content.encoding.codecProfile"] = null;
        /** @prop {number} [content.encoding.containerFormat] Container format of the media. */ this["content.encoding.containerFormat"] = null;
        // ADS
        /**
      * @prop {object} [ad.metadata]
      * Item containing mixed extra information about ads like: request url.
      * This object may store any serializable key:value info.
      */ this["ad.metadata"] = {};
        /**
      * @prop {string} [ad.campaign]
      * String containing the name of the campaign
      */ this["ad.campaign"] = null;
        /**
      * @prop {string} [ad.creativeId]
      * String containing the id of the creative
      */ this["ad.creativeId"] = null;
        /**
      * @prop {string} [ad.provider]
      * String containing the provider of the ad
      */ this["ad.provider"] = null;
        /**
      * @prop {string} [ad.resource]
      * String containing the ad resource
      */ this["ad.resource"] = null;
        /**
      * @prop {string} [ad.title]
      * String containing the title of the campaign
      */ this["ad.title"] = null;
        /**
      * @prop {duration} [ad.duration]
      * Duration of the ad in seconds
      */ this["ad.duration"] = null;
        /**
      * @prop {object} [ad.expectedPattern]
      * Json with the position of the breaks expected.
      * Arrays are the number of breaks, and the numbers in them, the number of ads for each break
      *
      * Example:
      * {pre: [1],
      * mid: [1,2],
      * post: [1]}
      * Would be a view with 1 preroll break with 1 ad, 2 midroll breaks, one with 1 ad and
      * the other with 2, and one postroll break with 1 ad.
      */ this["ad.expectedPattern"] = null;
        /**
      * @prop {string} [ad.givenAds]
      * Number of ads given by the adserver for this break
      */ this["ad.givenAds"] = null;
        /**
      * @prop {number[]} [ad.breaksTime]
      * Array of numbers for the time position of adbreaks
      */ this["ad.breaksTime"] = null;
        /**
      * @prop {string} [ad.expectedBreaks]
      * Number of breaks expected for the view
      */ this["ad.expectedBreaks"] = null;
        /**
      * @prop {number} [ad.givenBreaks]
      * Number of breaks given by the adserver for the view
      */ this["ad.givenBreaks"] = null;
        /**
      * @prop {boolean} [ad.ignore]
      * False by default.
      * If true, youbora blocks ad events and calculates jointime ignoring ad time.
      */ this["ad.ignore"] = false;
        /**
      * @prop {boolean} [ad.blockerDetected]
      * Null (notified as false) by default.
      * Sets if an adblocker has been detected
      */ this["ad.blockerDetected"] = null;
        // APP
        /**
      * @prop {string} [app.name]
      * String containing the name of the app
      */ this["app.name"] = null;
        /**
      * @prop {string} [app.releaseVerson]
      * String containing the app version
      */ this["app.releaseVersion"] = null;
        /**
      * @prop {boolean} [app.https=null]
      * Define the security of NQS calls.
      * If true it will use 'https://',
      * if false it will use 'http://',
      * if null/undefined it will use '//'.
      */ this["app.https"] = false;
        // BACKGROUND
        /**
      *  @prop {boolean} [background.enabled=false]
      * If true, plugin will send background/foreground events
      * Different device behaviour is settable in background.settings
      */ this["background.enabled"] = true;
        /**
      *  @prop {string} [background.settings]
      * Action to do when the browser goes to background.
      * Options are 'stop', 'pause', and '' for no action.
      * stop will be used to stop the view and track post-foreground events in a new view
      * pause will be used when after foreground event, an action like pressing play button is expected to resume the content
      * '' will be used if the content can be played in background
      * If not defined, specific device options will be used
      * background.setings.android / background.settings.iOS / background.settings.desktop / background.settings.tv
      * Default specific device values are stop for android and iphone, nothing for desktop.
      */ this["background.settings"] = null;
        /**
      *  @prop {string} [background.settings.android='stop']
      * If background.settings is not defined, action to do when the browser goes to background if
      * the device is android type.
      * Options are 'stop', 'pause', and '' or not defined for no action.
      * bg by default
      */ this["background.settings.android"] = "stop";
        /**
      *  @prop {string} [background.settings.iOS='stop']
      * If background.settings is not defined, action to do when the browser goes to background if
      * the device is iphone type.
      * Options are 'stop', 'pause', and '' or not defined for no action.
      * bg by default
      */ this["background.settings.iOS"] = "stop";
        /**
      *  @prop {string} [background.settings.desktop=null]
      * If background.settings is not defined, action to do when the browser goes to background if
      * the device is desktop type.
      * Options are 'stop', 'pause', and '' or not defined for no action.
      * Null by default
      */ this["background.settings.desktop"] = null;
        /**
      *  @prop {string} [background.settings.tv='stop']
      * If background.settings is not defined, action to do when the browser goes to background if
      * the device is smartTV type.
      * Options are 'stop', 'pause', and '' or not defined for no action.
      * bg by default
      */ this["background.settings.tv"] = "stop";
        /**
      *  @prop {string} [background.settings.playstation='stop']
      * If background.settings is not defined, action to do when the browser goes to background if
      * the device is playstation type.
      * Options are 'stop', 'pause', and '' or not defined for no action.
      * Null by default
      */ this["background.settings.playstation"] = "stop";
        // CDN BALANCER
        /**
      *  @prop {string} [cdnbalancer.uuid]
      * CDN Balancer Response UUID
      * null by default
      */ this["cdnbalancer.uuid"] = null;
        // EXTRAPARAMS // CUSTOM DIMENSIONS
        /** @prop {object} [content.customDimensions] Custom dimensions object. */ this["content.customDimensions"] = {};
        /** @prop {string} [content.customDimension.1] Custom parameter 1. */ this["content.customDimension.1"] = null;
        /** @prop {string} [content.customDimension.2] Custom parameter 2. */ this["content.customDimension.2"] = null;
        /** @prop {string} [content.customDimension.3] Custom parameter 3. */ this["content.customDimension.3"] = null;
        /** @prop {string} [content.customDimension.4] Custom parameter 4. */ this["content.customDimension.4"] = null;
        /** @prop {string} [content.customDimension.5] Custom parameter 5. */ this["content.customDimension.5"] = null;
        /** @prop {string} [content.customDimension.6] Custom parameter 6. */ this["content.customDimension.6"] = null;
        /** @prop {string} [content.customDimension.7] Custom parameter 7. */ this["content.customDimension.7"] = null;
        /** @prop {string} [content.customDimension.8] Custom parameter 8. */ this["content.customDimension.8"] = null;
        /** @prop {string} [content.customDimension.9] Custom parameter 9. */ this["content.customDimension.9"] = null;
        /** @prop {string} [content.customDimension.10] Custom parameter 10. */ this["content.customDimension.10"] = null;
        /** @prop {string} [content.customDimension.11] Custom parameter 11. */ this["content.customDimension.11"] = null;
        /** @prop {string} [content.customDimension.12] Custom parameter 12. */ this["content.customDimension.12"] = null;
        /** @prop {string} [content.customDimension.13] Custom parameter 13. */ this["content.customDimension.13"] = null;
        /** @prop {string} [content.customDimension.14] Custom parameter 14. */ this["content.customDimension.14"] = null;
        /** @prop {string} [content.customDimension.15] Custom parameter 15. */ this["content.customDimension.15"] = null;
        /** @prop {string} [content.customDimension.16] Custom parameter 16. */ this["content.customDimension.16"] = null;
        /** @prop {string} [content.customDimension.17] Custom parameter 17. */ this["content.customDimension.17"] = null;
        /** @prop {string} [content.customDimension.18] Custom parameter 18. */ this["content.customDimension.18"] = null;
        /** @prop {string} [content.customDimension.19] Custom parameter 19. */ this["content.customDimension.19"] = null;
        /** @prop {string} [content.customDimension.20] Custom parameter 20. */ this["content.customDimension.20"] = null;
        /** @prop {string} [ad.customDimension.1] Ad custom parameter 1. */ this["ad.customDimension.1"] = null;
        /** @prop {string} [ad.customDimension.2] Ad custom parameter 2. */ this["ad.customDimension.2"] = null;
        /** @prop {string} [ad.customDimension.3] Ad custom parameter 3. */ this["ad.customDimension.3"] = null;
        /** @prop {string} [ad.customDimension.4] Ad custom parameter 4. */ this["ad.customDimension.4"] = null;
        /** @prop {string} [ad.customDimension.5] Ad custom parameter 5. */ this["ad.customDimension.5"] = null;
        /** @prop {string} [ad.customDimension.6] Ad custom parameter 6. */ this["ad.customDimension.6"] = null;
        /** @prop {string} [ad.customDimension.7] Ad custom parameter 7. */ this["ad.customDimension.7"] = null;
        /** @prop {string} [ad.customDimension.8] Ad custom parameter 8. */ this["ad.customDimension.8"] = null;
        /** @prop {string} [ad.customDimension.9] Ad custom parameter 9. */ this["ad.customDimension.9"] = null;
        /** @prop {string} [ad.customDimension.10] Ad custom parameter 10. */ this["ad.customDimension.10"] = null;
        /** @prop {bool} [forceInit] Forces init to be sent instead of start, use it when mediaduration,
      *  title, source or is live is reported with a wrong value by the player until jointime happens */ this.forceInit = false;
        /**
      * @prop {object} [session.metrics]
      * Item containing metrics in json format. Reported every beat if the values change
      */ this["session.metrics"] = {};
        /**
      * @prop {bool} [session.context]
      * Boolean to choose to report context or not. False by default
      */ this["session.context"] = false;
        /**
      * @prop {array<string>} [errors.fatal=[]]
      * If it has elements on it, all the errors matching this code will fire the stop event to end the view
      */ this["errors.fatal"] = [];
        /**
      * @prop {array<string>} [errors.nonFatal=[]]
      * If it has elements on it, all the errors matching this code won't fire a stop event to end the view
      */ this["errors.nonFatal"] = [];
        /**
      * @prop {array<string>} [errors.ignore=[]]
      * If it has elements on it, all the errors matching this code wont be reported
      */ this["errors.ignore"] = [];
        /**
       * @prop {string} linkedViewId
       * String to send on start events to link views with previous session events
       */ this.linkedViewId = null;
        /**
      * @prop {bool} [waitForMetadata]
      * Boolean to delay the start event. Use with `pendingMetadata`
      */ this.waitForMetadata = false;
        /**
      * @prop {array<string>} [pendingMetadata]
      * List of values that should be ready to send in start event. Use with `waitForMetadata` set to True.
      */ this.pendingMetadata = [];
        /**
       * @prop {string} method
       * Method used to send request to backend side
       *  Options are 'get' or 'post'
       *  'get' by default
       */ this.method = RequestMethod.GET;
        /**
       * @prop {bool} [playhead.monitor]
       * Method to enabled/disable support for playhead monitor method
       */ this["playhead.monitor"] = true;
        /**
       * @prop {bool} [network.monitor]
       * Method to enabled/disable support for readyState monitor method
       */ this["readyState.monitor"] = true;
        /**
       * @prop {bool} [splitViews]
       * Method to enabled/disable the view splitting when some errors are stashed in the request
       */ this["session.splitViews"] = false;
        this.setOptions(options);
    },
    /**
    * Recursively sets the properties present in the params object.
    * ie: this.username = params.username.
    *
    * @param {Object} options A literal or another Data containing values.
    * @param {Object} [base=this] Start point for recursion.
    */ setOptions: function(options, base) {
        var isInBase = false;
        if (base === undefined) {
            base = this;
            isInBase = true;
            var deprecatedOptions = new DeprecatedOptions();
        }
        if (typeof options !== "undefined") for(var key in options){
            var deprecated = false;
            var newKey = null;
            if (isInBase) {
                if (!this.hasOwnProperty(key)) {
                    if (deprecatedOptions.exists(key)) {
                        newKey = deprecatedOptions.getNewName(key);
                        deprecated = true;
                    } else Log.warn('The option "' + key + '" does not exist, so it cannot be set');
                }
            }
            if (typeof base[key] === "object" && base[key] !== null && !Array.isArray(base[key]) && key === "parse.cdnNode.list") this.setOptions(options[key], base[key]);
            else if (deprecated) base[newKey] = options[key];
            else base[key] = options[key];
        }
    },
    /**
    * Sets all the values given in an array as extraparams. Limit is 20
    * @param {array<string>} paramsArray array of extraparam strings
    * */ setExtraParams: function(paramsArray) {
        var maxLength = 20;
        if (typeof paramsArray !== "object" || !paramsArray.length) return;
        if (paramsArray.length >= maxLength) paramsArray = paramsArray.slice(0, maxLength);
        while(paramsArray.length < maxLength)paramsArray.push(null);
        paramsArray.forEach((function(param, index) {
            this["content.customDimension." + (index + 1).toString()] = param;
        }).bind(this));
    },
    /**
    * @alias youbora.options.prototype.setExtraParams.
    */ setCustomDimensions: function() {
        Options.prototype.setExtraParams.apply(this, arguments);
    },
    /**
    * Sets all the values given in an array as extraparams. Limit is 10
    * @param {array<string>} paramsArray array of extraparam strings
    * */ setAdExtraParams: function(paramsArray) {
        var maxLength = 10;
        if (typeof paramsArray !== "object" || !paramsArray.length) return;
        if (paramsArray.length >= maxLength) paramsArray = paramsArray.slice(0, maxLength);
        while(paramsArray.length < maxLength)paramsArray.push(null);
        paramsArray.forEach((function(param, index) {
            this["ad.customDimension." + (index + 1).toString()] = param;
        }).bind(this));
    },
    /**
    * @alias youbora.options.prototype.setAdExtraParams.
    */ setAdCustomDimensions: function() {
        Options.prototype.setAdExtraParams.apply(this, arguments);
    }
}, {
    // Constants
    StreamingProtocol: StreamingProtocol,
    TransportFormat: TransportFormat,
    RequestMethod: RequestMethod
});
module.exports = Options;

},{"2ae1c4f37d9a38ba":"j7KrE","4239f4aad72e93c0":"69SPL","78c79b1aff37b944":"8xsxZ","ab6ae67ae2ceb853":"czE3D","d1cc89687ecfbfb5":"iIpwU","6a1bc31e754b6103":"ldnfs"}],"69SPL":[function(require,module,exports) {
var YouboraObject = require("746230d48a8f5252");
var Log = require("4c38ef3254c567bd");
var DeprecatedOptions = YouboraObject.extend({
    exists: function(optionName) {
        return DeprecatedOptions.Dictionary.hasOwnProperty(optionName) // eslint-disable-line no-prototype-builtins
        ;
    },
    getNewName: function(optionName) {
        var newName = DeprecatedOptions.Dictionary[optionName];
        Log.warn('The option "' + optionName + '" is deprecated, use "' + newName + '" instead');
        return newName;
    }
}, {
    // Keys are old option names
    // Values are new option names
    Dictionary: {
        httpSecure: "app.https",
        username: "user.name",
        anonymousUser: "user.anonymousId",
        obfuscateIp: "user.obfuscateIp",
        userType: "user.type",
        "content.title2": "content.program",
        "background.settings.iphone": "background.settings.iOS",
        "parse.hls": "parse.manifest",
        "parse.dash": "parse.manifest",
        "parse.locationHeader": "parse.manifest",
        "extraparam.1": "content.customDimension.1",
        "extraparam.2": "content.customDimension.2",
        "extraparam.3": "content.customDimension.3",
        "extraparam.4": "content.customDimension.4",
        "extraparam.5": "content.customDimension.5",
        "extraparam.6": "content.customDimension.6",
        "extraparam.7": "content.customDimension.7",
        "extraparam.8": "content.customDimension.8",
        "extraparam.9": "content.customDimension.9",
        "extraparam.10": "content.customDimension.10",
        "extraparam.11": "content.customDimension.11",
        "extraparam.12": "content.customDimension.12",
        "extraparam.13": "content.customDimension.13",
        "extraparam.14": "content.customDimension.14",
        "extraparam.15": "content.customDimension.15",
        "extraparam.16": "content.customDimension.16",
        "extraparam.17": "content.customDimension.17",
        "extraparam.18": "content.customDimension.18",
        "extraparam.19": "content.customDimension.19",
        "extraparam.20": "content.customDimension.20",
        "ad.extraparam.1": "ad.customDimension.1",
        "ad.extraparam.2": "ad.customDimension.2",
        "ad.extraparam.3": "ad.customDimension.3",
        "ad.extraparam.4": "ad.customDimension.4",
        "ad.extraparam.5": "ad.customDimension.5",
        "ad.extraparam.6": "ad.customDimension.6",
        "ad.extraparam.7": "ad.customDimension.7",
        "ad.extraparam.8": "ad.customDimension.8",
        "ad.extraparam.9": "ad.customDimension.9",
        "ad.extraparam.10": "ad.customDimension.10"
    }
});
module.exports = DeprecatedOptions;

},{"746230d48a8f5252":"j7KrE","4c38ef3254c567bd":"8xsxZ"}],"iIpwU":[function(require,module,exports) {
/**
 * List of streaming protocols
 *   - HDS (Adobe HDS)
 *   - HLS (Apple HLS)
 *   - MSS (Microsoft Smooth Streaming)
 *   - DASH (MPEG-DASH)
 *   - RTMP (Adobe RTMP)
 *   - RTP (RTP)
 *   - RTSP (RTSP)
 *   - MULTICAST (Multicast)
 *   - DVB (DVB)
 *   - DVBC (DVB-C)
 *   - DVBT (DVB-T)
 *   - DVBT2 (DVB-T2)
 */ var StreamingProtocol = {
    HDS: "HDS",
    HLS: "HLS",
    MSS: "MSS",
    DASH: "DASH",
    RTMP: "RTMP",
    RTP: "RTP",
    RTSP: "RTSP",
    DVB: "DVB",
    DVBC: "DVB-C",
    DVBT: "DVB-T",
    DVBT2: "DVB-T2",
    MULTICAST: "MULTICAST"
};
module.exports = StreamingProtocol;

},{}],"2BjVJ":[function(require,module,exports) {
var Emitter = require("a73a39ff36187434");
var Timer = require("4ba045209c7f5325");
var Chrono = require("df7385db96ace45d");
var Constants = require("e1a51c743b9f1cf5");
var Util = require("d414e1a910885970");
var YBRequest = require("19a58c3b596dfc32");
var Communication = require("3cd9ec2038014d4f");
var FlowTransform = require("bf919b97b3710a10");
var ViewTransform = require("8851d1626cf4e2b2");
var ResourceTransform = require("8953138f46bb016f");
var OfflineTransform = require("750977780c656631");
var Options = require("80b221041472b9a9");
var YouboraStorage = require("199d1ed26b76911a");
var OfflineStorage = require("5713735b69856f4e");
var RequestBuilder = require("b116f8422c651721");
var YouboraInfinity = require("61acf46cd6b313c5");
var ProductAnalytics = require("a883b3fb24ad3ae5");
var HybridNetwork = require("d032b8e1aca0d266");
var BrowserLoadTimes = require("3752d6c8bd5df622");
var BackgroundDetector = require("65e48f9c6a349dfa");
var DeviceDetector = require("b3507adf5b8049ae");
var ResizeScrollDetector = require("c6503ed265d28c01");
var UUIDGenerator = require("2069bbfdfff7cf77");
var Plugin = Emitter.extend(/** @lends youbora.Plugin.prototype */ {
    /**
     * This is the main class of video analytics. You may want to have one instance for each video
     * you want to track. Will need {@link Adapter}s for both content and ads.
     *
     * @constructs Plugin
     * @extends youbora.Emitter
     * @memberof youbora
     *
     * @param {Options} [options] An object complying with {@link Options} constructor.
     * @param {Adapter} [adapter] If an adapter is provided, setAdapter will be immediately called.
     * @param {object} [dataReq] If a data response is given, it wont request to /data anything and will use this one instead.
     */ constructor: function(options, adapter, dataReq) {
        if (typeof adapter === "string" && !dataReq) {
            dataReq = adapter;
            adapter = null;
        }
        /** Reference to {@link youbora.YouboraStorage} */ this.storage = new YouboraStorage();
        /** UUIDGenerator manager */ this.uuidGenerator = new UUIDGenerator(this);
        /** Instance of youbora infinity. */ this.infinity = new YouboraInfinity(this);
        /** Instance of youbora Product Analytics. */ this.productAnalytics = new ProductAnalytics(this);
        /** This flags indicates that /init has been called. */ this.isInitiated = false;
        /** This flags indicates that /adManifest has been called. */ this.isAdsManifestSent = false;
        /** Postroll counter to fix plugins reporting stop before postrolls */ this.playedPostrolls = 0;
        /** This flags indicates if an ad break is started */ this.isBreakStarted = false;
        /** Chrono for init times. */ this.initChrono = new Chrono();
        /** Stored {@link Options} of the session. */ this.options = new Options(options);
        /** Reference to {@link youbora.YouboraStorage} */ this.storage = new YouboraStorage(null, this.options.disableCookies, this.options.forceCookies, this.options.disableStorage);
        /** Reference to {@link youbora.OfflineStorage} */ if (!this.options.disableStorage) this.offlineStorage = new OfflineStorage();
        this._adapter = null;
        this._adsAdapter = null;
        this._ping = new Timer(this._sendPing.bind(this), 5000);
        this._beat = new Timer(this._sendBeat.bind(this), 30000);
        this._refreshData = new Timer(this._checkOldData.bind(this), 3600000) // 1h
        ;
        this._refreshData.start();
        this.sessionExpire = Number(this.storage.getLocal("sessionExpire")) * 1000 || 180000;
        this.requestBuilder = new RequestBuilder(this);
        this.resourceTransform = new ResourceTransform(this);
        this.lastEventTime = null;
        this.restartViewTransform(dataReq);
        this._initInfinity();
        this.hybridNetwork = new HybridNetwork();
        this.browserLoadTimes = new BrowserLoadTimes(this);
        this.deviceDetector = new DeviceDetector();
        this.backgroundDetector = new BackgroundDetector(this);
        this.resizeScrollDetector = new ResizeScrollDetector(this);
        if (this.options["background.enabled"]) this.backgroundDetector.startDetection();
        if (adapter) this.setAdapter(adapter);
    },
    _checkOldData: function() {
        if (this._adapter && this._adapter.flags.isStarted) return;
        if (this.infinity.infinityStarted) return;
        this.restartViewTransform();
    },
    restartViewTransform: function(response) {
        // FastData
        this.viewTransform = new ViewTransform(this);
        this.viewTransform.on(ViewTransform.Event.DONE, this._receiveData.bind(this));
        // External response
        if (response) {
            this.viewTransform.setData(response);
            return;
        }
        if (this.getIsDataExpired() || !this.getStorageHost() || this.storage.getLocal("accCode") !== this.options.accountCode && this.storage.getSession("accCode") !== this.options.accountCode) {
            this.storage.removeStorages("data");
            this.storage.removeStorages("session");
            this.storage.removeLocal("infinityStarted");
            this.viewTransform.init() // request a new data
            ;
        } else this.viewTransform.setData(this.getStoredData()) // use stored data
        ;
    },
    /**
    * This callback is called when a correct data response is received.
    *
    * @param {any} e Response from fastdata
    */ _receiveData: function(e) {
        this._ping.interval = e.target.response.pingTime * 1000;
        this._beat.interval = e.target.response.beatTime * 1000;
        this.sessionExpire = e.target.response.sessionExpire * 1000;
        this.storage.setStorages("data", e.target.response.msg);
        this.storage.setStorages("dataTime", new Date().getTime());
        this.storage.setStorages("accCode", this.options.accountCode);
        if (this.getIsSessionExpired()) {
            this.viewTransform.setSession(this.viewTransform.response.code);
            this.storage.setStorages("session", this.viewTransform.response.code);
            this.storage.setStorages("host", this.viewTransform.response.host);
        } else {
            this.viewTransform.setSession(this.getSession());
            this.viewTransform.setHost(this.getStorageHost());
        }
    },
    /**
    * Reset all variables and stop all timers
    * @private
    */ _reset: function() {
        this._stopPings();
        this.resourceTransform = new ResourceTransform(this);
        if (this._adapter) this._adapter.flags.reset();
        this.isInitiated = false;
        this.isStarted = false;
        this.startDelayed = false;
        this.isAdsManifestSent = false;
        this.initChrono.reset();
        this._totalPrerollsTime = 0;
        this.requestBuilder.lastSent.breakNumber = 0;
        this.requestBuilder.lastSent.adNumber = 0;
        this._savedAdManifest = null;
        this._savedAdError = null;
        this.playedPostrolls = 0;
        this.isBreakStarted = false;
    },
    /**
    * Creates and enqueues related request using {@link Communication#sendRequest}.
    * It will fire will-send-events.
    *
    * @param {string} willSendEvent Name of the will-send event. Use {@link Plugin.Event} enum.
    * @param {string} service Name of the service. Use {@link Constants.Service} enum.
    * @param {Object} params Params of the request
    * @param {Object} body Body of the request, if it is a POST request
    * @param {string} method Request method. GET by default
    * @param {function} callback Callback method for successful request
    * @param {Object} callbackParams Json with params for callback call
    * @private
    */ _send: function(willSendEvent, service, params, body, method, callback, callbackParams) {
        var now = new Date().getTime();
        if (this.options.preventZombieViews && this.lastEventTime && now > this.lastEventTime + 600000) // if last event was sent more than 10 minutes ago, it will use new view code
        this.viewTransform.nextView();
        this.lastEventTime = service === Constants.Service.STOP ? null : now;
        params = this.requestBuilder.buildParams(params, service);
        if (this.getIsLive()) {
            params.mediaDuration = this.options["content.duration"];
            params.playhead = undefined;
        }
        var data = {
            params: params,
            plugin: this,
            adapter: this.getAdapter(),
            adsAdapter: this.getAdsAdapter()
        };
        this.emit(willSendEvent, data);
        if (this._comm && (params !== null || typeof method !== "undefined") && this.options.enabled) {
            this.lastServeiceSent = service;
            var options = {};
            if (typeof method !== "undefined" && method !== "GET") options.method = method;
            var request = new YBRequest(null, service, params, options);
            if (body) request.setBody(body);
            if (this.isMethodPostEnabled()) request.setPostRequest(true);
            this._comm.sendRequest(request, callback, callbackParams);
        }
    },
    /**
    * Initializes comm and its transforms.
    * @private
    */ _initComm: function() {
        var resource = this._getResourceForTransform();
        this.resourceTransform.init(resource);
        this._comm = new Communication();
        this._comm.addTransform(new FlowTransform());
        this._comm.addTransform(this.viewTransform);
        if (this.options && this.options.offline) this._comm.addTransform(new OfflineTransform(this));
        else this._comm.addTransform(this.resourceTransform);
    },
    _getResourceForTransform: function() {
        var resource = this.getResource();
        if (this._adapter && this._adapter.getURLToParse()) resource = this._adapter.getURLToParse();
        return resource;
    },
    /**
    * Returns the current {@link youbora.Communication} instance.
    *
    * @returns {youbora.Communication} communication instance
    */ getComm: function() {
        return this._comm;
    },
    /**
    * Modifies current options. See {@link Options.setOptions}.
    *
    * @param {any} options
    */ setOptions: function(options) {
        if (options) {
            this.options.setOptions(options);
            if (typeof options["background.enabled"] === "boolean") {
                if (options["background.enabled"]) this.backgroundDetector.startDetection();
                else this.backgroundDetector.stopDetection();
            }
        }
    },
    /**
    * Get fastdata response to set it in another plugin instance
    */ getFastDataConfig: function() {
        return this.viewTransform.response.msg;
    },
    /**
    * Disable request sending.
    */ disable: function() {
        this.setOptions({
            enabled: false
        });
    },
    /**
    * Re-enable request sending.
    */ enable: function() {
        this.setOptions({
            enabled: true
        });
    }
}, /** @lends youbora.Plugin */ {
    // Static Memebers //
    /**
    * List of events that could be fired
    * @enum
    * @event
    */ Event: Constants.WillSendEvent
});
// Apply Mixins
// Plugin is actually a big class, I decided to separate the logic into
// different mixin files to ease the maintainability of each file.
// Filename convention will be plugin+xxxxx.js where xxxxx is the added functionality.
Util.assign(Plugin.prototype, require("c39a0b165febcfb0"));
Util.assign(Plugin.prototype, require("4eb75933912d0493"));
Util.assign(Plugin.prototype, require("87064776742b3519"));
Util.assign(Plugin.prototype, require("5b4d6fd933b2525b"));
Util.assign(Plugin.prototype, require("9a35d7c629671aaa"));
Util.assign(Plugin.prototype, require("50d012f26f6a63a2"));
Util.assign(Plugin.prototype, require("fa968ccb7ba6b108"));
Util.assign(Plugin.prototype, require("538626ed710c1379"));
Util.assign(Plugin.prototype, require("81db47989594f3f4"));
module.exports = Plugin;

},{"a73a39ff36187434":"cuYJd","4ba045209c7f5325":"cqNVd","df7385db96ace45d":"6HP4E","e1a51c743b9f1cf5":"92xpS","d414e1a910885970":"drhpF","19a58c3b596dfc32":"6hKtj","3cd9ec2038014d4f":"bOkDM","bf919b97b3710a10":"4dpt2","8851d1626cf4e2b2":"hugd5","8953138f46bb016f":"3JgT9","750977780c656631":"9eqxK","80b221041472b9a9":"f2zFO","199d1ed26b76911a":"9mqvX","5713735b69856f4e":"8pSK4","b116f8422c651721":"fouWB","61acf46cd6b313c5":"7fbyw","a883b3fb24ad3ae5":"f3wLd","d032b8e1aca0d266":"395SH","3752d6c8bd5df622":"7oOQI","65e48f9c6a349dfa":"eFDAY","b3507adf5b8049ae":"32dVf","c6503ed265d28c01":"f2Pza","2069bbfdfff7cf77":"7v7Id","c39a0b165febcfb0":"5HS6h","4eb75933912d0493":"isPjX","87064776742b3519":"jhZAm","5b4d6fd933b2525b":"eOAEJ","9a35d7c629671aaa":"aAyw0","50d012f26f6a63a2":"68M1M","fa968ccb7ba6b108":"4mj8g","538626ed710c1379":"kYvTu","81db47989594f3f4":"ezfuK"}],"4dpt2":[function(require,module,exports) {
var Transform = require("2e760139f8d684aa");
var Constants = require("24254afdb23d73e8");
/**
 * This transform ensures that no requests will be sent before an /init or /start request.
 * As these are the two possible first requests that the API expects for a view.
 *
 * @constructs
 * @extends youbora.Transform
 * @memberof youbora
 * @name FlowTransform
 *
 * @param {Plugin} plugin Instance of {@link Plugin}
 */ var FlowTransform = Transform.extend(/** @lends youbora.FlowTransform.prototype */ {
    _services: [
        Constants.Service.INIT,
        Constants.Service.START,
        Constants.Service.OFFLINE_EVENTS
    ],
    /**
     * Returns if transform is blocking.
     *
     * @param {YBRequest} request Request to transform.
     * @return {bool} True if queue shall be blocked.
     */ isBlocking: function(request) {
        if (this._isBusy && request != null) {
            if (this._services.indexOf(request.service) !== -1) this.done();
            else if (request.service === Constants.Service.ERROR) return false;
        }
        return Transform.prototype.isBlocking.apply(this, arguments);
    }
});
module.exports = FlowTransform;

},{"2e760139f8d684aa":"8oBJA","24254afdb23d73e8":"92xpS"}],"9mqvX":[function(require,module,exports) {
/* global localStorage, sessionStorage, location */ var YouboraObject = require("1f572766d95ca2a7");
var Log = require("61bb6d06bd4bafdd");
/**
 * This class manages data sotrage in the browser memory.
 *
 * @extends youbora.Emitter
 * @memberof youbora
 */ var YouboraStorage = YouboraObject.extend(/** @lends youbora.YouboraStorage.prototype */ {
    /**
     *
     * @constructs YouboraStorage
     * @extends YouboraObject
     * @memberof youbora
     *
     * @param {String} [prefix] Optional. Sets the prefix for saved objects in storages or cookies. 'youbora' by default.
     * @param {Boolean} [disableCookies] Optional. Set to true to disable cookies fallback. True by default.
     */ constructor: function(prefix, disableCookies, forceCookies, disable) {
        this.prefix = prefix || "youbora";
        this.disableCookies = disableCookies;
        this.forceCookies = forceCookies;
        this.disabled = disable;
    },
    /**
     * Returns if storages are available or not
     *
     */ isEnabled: function() {
        if (this.disabled) return false;
        var ret = true;
        if (!this.forceCookies) try {
            localStorage.setItem(this.prefix + "." + "test", "true");
            localStorage.removeItem(this.prefix + "." + "test");
        } catch (err) {
            ret = false;
        }
        return ret;
    },
    /**
     * Saves in localStorage or equivalent
     *
     * @param {string} key Key of the value. Prefix will be appended.
     * @param {string} value Value.
     */ setLocal: function(key, value) {
        if (this.disabled) return null;
        var ret = null;
        try {
            if (this.forceCookies || (typeof localStorage === "undefined" || !localStorage) && !this.disableCookies) ret = this._setCookie(this.prefix + ".local." + key, value);
            else ret = localStorage.setItem(this.prefix + "." + key, value);
        } catch (err) {
            Log.error("Youbora Infinity needs localStorage or cookies, not supported by your browser.");
        }
        return ret;
    },
    /**
     * Reads from localStorage or equivalent
     *
     * @param {string} key Key of the value. prefix will be appended.
     */ getLocal: function(key) {
        if (this.disabled) return null;
        return this._localGetRemove("getItem", "_getCookie", key);
    },
    /**
     * Removes from localStorage or equivalent
     *
     * @param {string} key Key of the value. prefix will be appended.
     */ removeLocal: function(key) {
        if (this.disabled) return null;
        return this._localGetRemove("removeItem", "_removeCookie", key);
    },
    _localGetRemove: function(storageMethod, cookieMethod, key) {
        var ret = null;
        try {
            if (this.forceCookies || (typeof localStorage === "undefined" || !localStorage) && !this.disableCookies) ret = this[cookieMethod](this.prefix + ".local." + key);
            else ret = localStorage[storageMethod](this.prefix + "." + key);
        } catch (err) {
            Log.error("Youbora Infinity needs localStorage or cookies, not supported by your browser.");
        }
        return ret;
    },
    /**
     * Saves in sessionStorage or equivalent
     *
     * @param {string} key Key of the value. prefix will be appended.
     * @param {string} value Value.
     */ setSession: function(key, value) {
        if (this.disabled) return null;
        var ret = null;
        try {
            if (this.forceCookies || (typeof sessionStorage === "undefined" || !sessionStorage) && !this.disableCookies) ret = this._setCookie(this.prefix + ".session." + key, value);
            else ret = sessionStorage.setItem(this.prefix + "." + key, value);
        } catch (err) {
            Log.error("Youbora Infinity needs sessionStorage or cookies, not supported by your browser.");
        }
        return ret;
    },
    /**
     * Reads from sessionStorage or equivalent
     *
     * @param {string} key Key of the value. prefix will be appended.
     */ getSession: function(key) {
        if (this.disabled) return null;
        return this._sessionGetRemove("getItem", "_getCookie", key);
    },
    /**
   * Removes from sessionStorage or equivalent
   *
   * @param {string} key Key of the value. prefix will be appended.
   */ removeSession: function(key) {
        if (this.disabled) return null;
        return this._sessionGetRemove("removeItem", "_removeCookie", key);
    },
    _sessionGetRemove: function(storageMethod, cookieMethod, key) {
        var ret = null;
        try {
            if (this.forceCookies || (typeof sessionStorage === "undefined" || !sessionStorage) && !this.disableCookies) ret = this[cookieMethod](this.prefix + ".session." + key);
            else ret = sessionStorage[storageMethod](this.prefix + "." + key);
        } catch (err) {
            Log.error("Youbora Infinity needs sessionStorage or cookies, not supported by your browser.");
        }
        return ret;
    },
    /**
     * Calls getSession and getLocal for the same key
     * @param {string} key Key of the value. prefix will be appended.
     */ getStorages: function(key) {
        return this.getSession(key) || this.getLocal(key);
    },
    /**
     * Calls getSession and getLocal with the same key and value
     * @param {string} key Key of the value. prefix will be appended.
     * @param {string} value Value.
     */ setStorages: function(key, value) {
        this.setSession(key, value);
        this.setLocal(key, value);
    },
    /**
     * Calls getSession and getLocal for the same key
     * @param {string} key Key of the value. prefix will be appended.
     */ removeStorages: function(key) {
        this.removeSession(key);
        this.removeLocal(key);
    },
    // Private cookies methods
    /**
   * Sets a cookie value
   *
   * @param {string} cname Key of the value.
   * @param {Object} cvalue Value.
   */ _setCookie: function(cname, cvalue) {
        if (typeof document !== "undefined") {
            var domain = ";";
            if (typeof location !== "undefined") domain += "domain=" + location.host.split(".").reverse().splice(0, 2).reverse().join(".") + ";path=/;";
            document.cookie = cname + "=" + cvalue + domain;
        }
    },
    /**
   * Gets a cookie value
   *
   * @param {string} cname Key of the value.
   */ _getCookie: function(cname) {
        if (typeof document !== "undefined") {
            var name = cname + "=";
            var decodedCookie = decodeURIComponent(document.cookie);
            var ca = decodedCookie.split(";");
            for(var i = 0; i < ca.length; i++){
                var c = ca[i];
                while(c.charAt(0) === " ")c = c.substring(1);
                if (c.indexOf(name) === 0) return c.substring(name.length, c.length);
            }
        }
        return null;
    },
    /**
   * Removes a cookie
   *
   * @param {string} cname Key of the value.
   */ _removeCookie: function(cname) {
        this._setCookie(cname, "");
    }
});
module.exports = YouboraStorage;

},{"1f572766d95ca2a7":"j7KrE","61bb6d06bd4bafdd":"8xsxZ"}],"8pSK4":[function(require,module,exports) {
var YouboraObject = require("7a345a8689a964cb");
var Storage = require("68a41be559697719");
/**
 * This class manages data storage for offline events in an storage.
 *
 * @extends youbora.Emitter
 * @memberof youbora
 */ var OfflineStorage = YouboraObject.extend({
    constructor: function() {
        this.storage = new Storage("youboraOffline", true) // No cookies for offline
        ;
        this.actualView = null;
        this.viewList = [];
        this.givenIds = [];
        this._getOldViewList();
    },
    _newView: function() {
        // search for first unused id
        var viewId = this._getValidId();
        // create empty view
        this.storage.setLocal(viewId, "");
        // add to viewlist
        this.viewList.push(viewId);
        this.storage.setLocal("views", this.viewList);
        // save the id
        this.actualView = viewId;
    },
    addEvent: function(event, params) {
        // if event is start, create new view
        if (event === "/start") this._newView();
        // if event is init, ignore
        if (event === "/init") return null;
        // if we have no view discard
        if (!this.actualView) return null;
        // create event object
        var fullEvent = '{"request":"' + event.slice(1) + '",' // {"request":"start",
        ;
        fullEvent += '"unixtime":' + Date.now() + "," // "unixtime":1499876515,
        ;
        for(var param in params){
            if (params[param] === undefined) break;
            fullEvent += '"' + param + '":' // "aParam":
            ;
            if (param === "code") fullEvent += '"CODE_PLACEHOLDER",' // "CODE_PLACEHOLDER",
            ;
            else if (param === "sessionId") fullEvent += '"SESSION_PLACEHOLDER",' // "SESSION_PLACEHOLDER",
            ;
            else if (param === "sessionRoot") fullEvent += '"ROOT_PLACEHOLDER",' // "ROOT_PLACEHOLDER",
            ;
            else if (typeof params[param] === "string") fullEvent += '"' + params[param] + '",' // "aStringValue",
            ;
            else if (typeof params[param] === "object") fullEvent += '"' + JSON.stringify(params[param]).replace(/"/g, '\\"') + '",' // json object
            ;
            else fullEvent += params[param] + "," // 123, for example
            ;
        }
        fullEvent = fullEvent.slice(0, -1) // remove the last comma
        ;
        fullEvent += "}";
        // get accumulated view object
        var temp = this.storage.getLocal(this.actualView);
        if (temp !== "") temp = temp + "," // comma between events
        ;
        // add the event
        this.storage.setLocal(this.actualView, temp + fullEvent);
    },
    getView: function() {
        if (this.viewList.length > this.givenIds.length) {
            var position = 0;
            while(true){
                var idToSend = this.viewList[position];
                if (this.givenIds.indexOf(idToSend) < 0) {
                    this.givenIds.push(idToSend);
                    return [
                        "[" + this.storage.getLocal(idToSend) + "]",
                        idToSend
                    ];
                }
                position++;
            }
        }
        return [
            null,
            null
        ];
    },
    removeView: function(id) {
        this.storage.removeLocal(id);
        var position = this.viewList.indexOf(id);
        if (position !== -1) this.viewList.splice(position, 1);
        position = this.givenIds.indexOf(id);
        if (position !== -1) this.givenIds.splice(position, 1);
        this.storage.setLocal("views", this.viewList.toString());
        if (id === this.actualView) this.actualView = null;
    },
    _getOldViewList: function() {
        var stringList = "";
        if (this.storage.getLocal("views")) stringList = this.storage.getLocal("views");
        else this.storage.setLocal("views", "");
        if (stringList === "") this.viewList = [];
        else if (typeof stringList.split === "function") this.viewList = stringList.split(",");
    },
    _getValidId: function() {
        // get a value not in the list
        var id = Math.floor(Math.random() * 1e8).toString();
        if (this.viewList.indexOf(id) >= 0) return this._getValidId();
        return id;
    },
    sent: function() {
        this.givenIds = [];
    }
});
module.exports = OfflineStorage;

},{"7a345a8689a964cb":"j7KrE","68a41be559697719":"9mqvX"}],"fouWB":[function(require,module,exports) {
var YouboraObject = require("749c20a0eb38c8e5");
var Log = require("2cd69da9cb9841a3");
var startParams = [
    "accountCode",
    "username",
    "anonymousUser",
    "rendition",
    "deviceInfo",
    "player",
    "title",
    "title2",
    "live",
    "segmentDuration",
    "mediaDuration",
    "mediaResource",
    "parsedResource",
    "transactionCode",
    "properties",
    "cdn",
    "playerVersion",
    "param1",
    "param2",
    "param3",
    "param4",
    "param5",
    "param6",
    "param7",
    "param8",
    "param9",
    "param10",
    "param11",
    "param12",
    "param13",
    "param14",
    "param15",
    "param16",
    "param17",
    "param18",
    "param19",
    "param20",
    "dimensions",
    "playerStartupTime",
    "obfuscateIp",
    "privacyProtocol",
    "p2pEnabled",
    "pluginVersion",
    "pluginInfo",
    "isp",
    "connectionType",
    "ip",
    "referer",
    "userType",
    "streamingProtocol",
    "transportFormat",
    "householdId",
    "adsBlocked",
    "adsExpected",
    "deviceUUID",
    "libVersion",
    "nodeHost",
    "nodeType",
    "appName",
    "appReleaseVersion",
    "package",
    "saga",
    "tvshow",
    "season",
    "titleEpisode",
    "channel",
    "imdbID",
    "gracenoteID",
    "contentType",
    "genre",
    "contentLanguage",
    "subtitles",
    "cost",
    "price",
    "playbackType",
    "email",
    "drm",
    "videoCodec",
    "audioCodec",
    "codecSettings",
    "codecProfile",
    "containerFormat",
    "contentId",
    "contractedResolution",
    "linkedViewId",
    "edid",
    "cdnBalancerResponseUUID",
    "triggeredEvents"
];
var adStartParams = [
    "player",
    "playhead",
    "adTitle",
    "position",
    "adDuration",
    "adCampaign",
    "adCreativeId",
    "adProvider",
    "adResource",
    "adPlayerVersion",
    "adProperties",
    "adAdapterVersion",
    "adInsertionType",
    "extraparam1",
    "extraparam2",
    "extraparam3",
    "extraparam4",
    "extraparam5",
    "extraparam6",
    "extraparam7",
    "extraparam8",
    "extraparam9",
    "extraparam10",
    "fullscreen",
    "audio",
    "skippable",
    "adNumber",
    "adNumberInBreak",
    "breakNumber"
];
var RequestBuilder = YouboraObject.extend(/** @lends youbora.RequestBuilder.prototype */ {
    /**
     * This class helps building params associated with each event: /start, /joinTime...
     *
     * @constructs RequestBuilder
     * @extends youbora.YouboraObject
     * @memberof youbora
     *
     * @param {Plugin} plugin A Plugin instance
     */ constructor: function(plugin) {
        this._plugin = plugin;
        this._adNumber = 0;
        this._adNumberInBreak = 0;
        /** Stores a list of the last params fetched */ this.lastSent = {};
    },
    /**
     * Adds to params all the entities specified in paramList, unless they are already set.
     *
     * @param {Object} params Object of params key:value.
     * @param {Array.string} paramList A list of params to fetch.
     * @param {bool} onlyDifferent If true, only fetches params that have changed
     */ fetchParams: function(params, paramList, onlyDifferent) {
        params = params || {};
        paramList = paramList || [];
        for(var i = 0; i < paramList.length; i++){
            var param = paramList[i];
            if (params[param]) continue;
            var getterName = RequestBuilder.getters[param];
            if (this._plugin[getterName]) {
                var value = this._plugin[getterName]();
                if (value !== null && (!onlyDifferent || this.lastSent[param] !== value)) {
                    params[param] = value;
                    this.lastSent[param] = value;
                }
            } else Log.warn("Trying to call undefined getter " + param + ":" + getterName);
        }
        return params;
    },
    getGetters: function() {
        return RequestBuilder.getters;
    },
    buildBody: function(service) {
        var body = null;
        return this.fetchParams(body, RequestBuilder.bodyParams[service], false);
    },
    /**
     * Adds to params object all the entities specified in paramList, unless they are already set.
     *
     * @param {Object} params Object of params key:value.
     * @param {string} service The name of the service. Use {@link Plugin.Service} enum.
     */ buildParams: function(params, service) {
        params = params || {};
        this.fetchParams(params, RequestBuilder.params[service], false);
        this.fetchParams(params, RequestBuilder.differentParams[service], true);
        return params;
    },
    /**
     * Creates an adnumber if it does not exist and stores it in lastSent. If it already exists,
     * it is incremented by 1.
     *
     * @returns {number} adNumber
     */ getNewAdNumber: function() {
        var adNumber = this.lastSent.adNumber;
        if (adNumber && this.lastSent.position === this._plugin.getAdPosition()) adNumber += 1;
        else adNumber = 1;
        this.lastSent.adNumber = adNumber;
        return adNumber;
    },
    /**
     * Creates an adnumberinbreak incrementing by 1.
     *
     * @returns {number} adNumber
     */ getNewAdNumberInBreak: function() {
        this._adNumberInBreak++;
        this.lastSent.adNumberInBreak = this._adNumberInBreak;
        return this._adNumberInBreak;
    },
    /**
     * Creates an breaknumber if it does not exist and stores it in lastSent. If it already exists,
     * it is incremented by 1.
     * Also resets adnumberinbreak
     * @returns {number} breakNumber
     */ getNewBreakNumber: function() {
        var breakNumber = 1;
        this._adNumberInBreak = 0;
        if (this.lastSent.breakNumber) breakNumber = this.lastSent.breakNumber + 1;
        this.lastSent.breakNumber = breakNumber;
        return breakNumber;
    },
    /**
     * Return changed entities since last check
     *
     * @returns {Object} params
     */ getChangedEntities: function() {
        return this.fetchParams({}, RequestBuilder.differentParams.entities, true);
    }
}, /** @lends youbora.RequestBuilder */ {
    // Static Members
    /** List of params used by each service */ params: {
        "/data": [
            "system",
            "pluginVersion",
            "requestNumber",
            "username"
        ],
        "/init": startParams,
        "/start": startParams,
        "/joinTime": [
            "joinDuration",
            "playhead",
            "bitrate",
            "triggeredEvents"
        ],
        "/pause": [
            "playhead",
            "triggeredEvents"
        ],
        "/resume": [
            "pauseDuration",
            "playhead",
            "triggeredEvents"
        ],
        "/seek": [
            "seekDuration",
            "playhead",
            "triggeredEvents"
        ],
        "/bufferUnderrun": [
            "bufferDuration",
            "playhead",
            "triggeredEvents"
        ],
        "/error": [
            "player",
            "playhead",
            "triggeredEvents"
        ].concat(startParams),
        "/stop": [
            "bitrate",
            "totalBytes",
            "playhead",
            "pauseDuration",
            "metrics",
            "cdnDownloadedTraffic",
            "multiCdnInfo",
            "p2pDownloadedTraffic",
            "uploadTraffic",
            "triggeredEvents"
        ],
        "/infinity/video/event": [
            "playhead"
        ],
        "/adInit": adStartParams,
        "/adStart": adStartParams,
        "/adJoin": [
            "playhead",
            "position",
            "adJoinDuration",
            "adPlayhead",
            "adNumber",
            "adNumberInBreak",
            "breakNumber"
        ],
        "/adPause": [
            "playhead",
            "position",
            "adPlayhead",
            "adNumber",
            "adNumberInBreak",
            "breakNumber"
        ],
        "/adResume": [
            "playhead",
            "position",
            "adPlayhead",
            "adPauseDuration",
            "adNumber",
            "adNumberInBreak",
            "breakNumber"
        ],
        "/adBufferUnderrun": [
            "playhead",
            "position",
            "adPlayhead",
            "adBufferDuration",
            "adNumber",
            "adNumberInBreak",
            "breakNumber"
        ],
        "/adStop": [
            "playhead",
            "position",
            "adPlayhead",
            "adBitrate",
            "adTotalDuration",
            "pauseDuration",
            "adViewedDuration",
            "adViewability",
            "adNumber",
            "adNumberInBreak",
            "breakNumber"
        ],
        "/adClick": [
            "playhead",
            "position",
            "adPlayhead",
            "adNumber",
            "adNumberInBreak",
            "breakNumber"
        ],
        "/adError": [
            "playhead"
        ].concat(adStartParams),
        "/adManifest": [
            "givenBreaks",
            "expectedBreaks",
            "expectedPattern",
            "breaksTime"
        ],
        "/adBreakStart": [
            "position",
            "givenAds",
            "expectedAds",
            "breakNumber",
            "adInsertionType"
        ],
        "/adBreakStop": [
            "position",
            "breakNumber"
        ],
        "/adQuartile": [
            "position",
            "adViewedDuration",
            "adViewability",
            "adNumber",
            "adNumberInBreak",
            "breakNumber"
        ],
        "/ping": [
            "droppedFrames",
            "playrate",
            "cdnDownloadedTraffic",
            "multiCdnInfo",
            "p2pDownloadedTraffic",
            "uploadTraffic",
            "latency",
            "packetLoss",
            "packetSent",
            "metrics",
            "totalBytes",
            "segmentDuration"
        ],
        "/infinity/session/start": [
            "accountCode",
            "username",
            "userType",
            "anonymousUser",
            "route",
            "page",
            "referer",
            "referral",
            "screenResolution",
            "language",
            "deviceInfo",
            "adsBlocked",
            "deviceUUID",
            "libVersion",
            "appName",
            "appReleaseVersion",
            "isp",
            "connectionType",
            "ip",
            "obfuscateIp",
            "privacyProtocol",
            "dimensions",
            "param1",
            "param2",
            "param3",
            "param4",
            "param5",
            "param6",
            "param7",
            "param8",
            "param9",
            "param10",
            "param11",
            "param12",
            "param13",
            "param14",
            "param15",
            "param16",
            "param17",
            "param18",
            "param19",
            "param20",
            "edid"
        ],
        "/infinity/session/stop": [
            "sessionMetrics"
        ],
        "/infinity/session/nav": [
            "route",
            "page",
            "scrollDepth"
        ],
        "/infinity/session/beat": [
            "sessionMetrics"
        ],
        "/infinity/session/event": [
            "accountCode"
        ],
        "/offlineEvents": {}
    },
    /** Values for request body */ bodyParams: {
        "/offlineEvents": [
            "viewJson"
        ]
    },
    /** List of params used by each service (only if they are different) */ differentParams: {
        entities: [
            "rendition",
            "title",
            "title2",
            "param1",
            "param2",
            "param3",
            "param4",
            "param5",
            "param6",
            "param7",
            "param8",
            "param9",
            "param10",
            "param11",
            "param12",
            "param13",
            "param14",
            "param15",
            "param16",
            "param17",
            "param18",
            "param19",
            "param20",
            "cdn",
            "nodeHost",
            "nodeType",
            "nodeTypeString",
            "subtitles",
            "contentLanguage",
            "contentId"
        ]
    },
    /** List of params and its related getter */ getters: {
        requestNumber: "getRequestNumber",
        playhead: "getPlayhead",
        playrate: "getPlayrate",
        fps: "getFramesPerSecond",
        segmentDuration: "getSegmentDuration",
        droppedFrames: "getDroppedFrames",
        mediaDuration: "getDuration",
        bitrate: "getBitrate",
        totalBytes: "getTotalBytes",
        throughput: "getThroughput",
        rendition: "getRendition",
        title: "getTitle",
        title2: "getTitle2",
        live: "getIsLive",
        mediaResource: "getResource",
        parsedResource: "getParsedResource",
        transactionCode: "getTransactionCode",
        properties: "getMetadata",
        playerVersion: "getPlayerVersion",
        player: "getPlayerName",
        cdn: "getCdn",
        pluginVersion: "getPluginVersion",
        libVersion: "getLibVersion",
        userType: "getUserType",
        streamingProtocol: "getStreamingProtocol",
        transportFormat: "getTransportFormat",
        obfuscateIp: "getObfuscateIp",
        privacyProtocol: "getPrivacyProtocol",
        householdId: "getHouseholdId",
        latency: "getLatency",
        packetLoss: "getPacketLoss",
        packetSent: "getPacketSent",
        metrics: "getVideoMetrics",
        dimensions: "getCustomDimensions",
        param1: "getExtraparam1",
        param2: "getExtraparam2",
        param3: "getExtraparam3",
        param4: "getExtraparam4",
        param5: "getExtraparam5",
        param6: "getExtraparam6",
        param7: "getExtraparam7",
        param8: "getExtraparam8",
        param9: "getExtraparam9",
        param10: "getExtraparam10",
        param11: "getExtraparam11",
        param12: "getExtraparam12",
        param13: "getExtraparam13",
        param14: "getExtraparam14",
        param15: "getExtraparam15",
        param16: "getExtraparam16",
        param17: "getExtraparam17",
        param18: "getExtraparam18",
        param19: "getExtraparam19",
        param20: "getExtraparam20",
        extraparam1: "getAdExtraparam1",
        extraparam2: "getAdExtraparam2",
        extraparam3: "getAdExtraparam3",
        extraparam4: "getAdExtraparam4",
        extraparam5: "getAdExtraparam5",
        extraparam6: "getAdExtraparam6",
        extraparam7: "getAdExtraparam7",
        extraparam8: "getAdExtraparam8",
        extraparam9: "getAdExtraparam9",
        extraparam10: "getAdExtraparam10",
        position: "getAdPosition",
        adNumber: "getAdNumber",
        adNumberInBreak: "getAdNumberInBreak",
        breakNumber: "getBreakNumber",
        adPlayhead: "getAdPlayhead",
        adDuration: "getAdDuration",
        adCampaign: "getAdCampaign",
        adCreativeId: "getAdCreativeId",
        adBitrate: "getAdBitrate",
        adTitle: "getAdTitle",
        adResource: "getAdResource",
        adPlayerVersion: "getAdPlayerVersion",
        adProperties: "getAdMetadata",
        adAdapterVersion: "getAdAdapterVersion",
        givenBreaks: "getGivenBreaks",
        expectedBreaks: "getExpectedBreaks",
        expectedPattern: "getExpectedPattern",
        breaksTime: "getBreaksTime",
        givenAds: "getGivenAds",
        expectedAds: "getExpectedAds",
        adsExpected: "getAdsExpected",
        adViewedDuration: "getAdViewedDuration",
        adViewability: "getAdViewability",
        fullscreen: "getIsFullscreen",
        audio: "getAudioEnabled",
        skippable: "getIsSkippable",
        adProvider: "getAdProvider",
        adInsertionType: "getAdInsertionType",
        pluginInfo: "getPluginInfo",
        isp: "getIsp",
        connectionType: "getConnectionType",
        ip: "getIp",
        deviceInfo: "getDeviceInfo",
        edid: "getEDID",
        system: "getAccountCode",
        accountCode: "getAccountCode",
        username: "getUsername",
        anonymousUser: "getAnonymousUser",
        joinDuration: "getJoinDuration",
        bufferDuration: "getBufferDuration",
        seekDuration: "getSeekDuration",
        pauseDuration: "getPauseDuration",
        adJoinDuration: "getAdJoinDuration",
        adBufferDuration: "getAdBufferDuration",
        adPauseDuration: "getAdPauseDuration",
        adTotalDuration: "getAdTotalDuration",
        referer: "getReferer",
        referral: "getReferral",
        language: "getLanguage",
        screenResolution: "getScreenResolution",
        nodeHost: "getNodeHost",
        nodeType: "getNodeType",
        nodeTypeString: "getNodeTypeString",
        route: "getReferer",
        page: "getPageName",
        playerStartupTime: "getPlayerStartupTime",
        pageLoadTime: "getPageLoadTime",
        cdnDownloadedTraffic: "getCdnTraffic",
        multiCdnInfo: "getMultiCdnInfo",
        p2pDownloadedTraffic: "getP2PTraffic",
        p2pEnabled: "getIsP2PEnabled",
        uploadTraffic: "getUploadTraffic",
        cdnBalancerResponseUUID: "getBalancerResponseId",
        viewJson: "getOfflineView",
        deviceUUID: "getDeviceUUID",
        sessionMetrics: "getSessionMetrics",
        scrollDepth: "getScrollDepth",
        adsBlocked: "getIsBlocked",
        linkedViewId: "getLinkedViewId",
        appName: "getAppName",
        appReleaseVersion: "getAppReleaseVersion",
        package: "getPackage",
        saga: "getSaga",
        tvshow: "getTvShow",
        season: "getSeason",
        titleEpisode: "getEpisodeTitle",
        channel: "getChannel",
        drm: "getDRM",
        videoCodec: "getVideoCodec",
        audioCodec: "getAudioCodec",
        codecSettings: "getCodecSettings",
        codecProfile: "getCodecProfile",
        containerFormat: "getContainerFormat",
        contentId: "getID",
        imdbID: "getImdbId",
        gracenoteID: "getGracenoteID",
        contentType: "getType",
        genre: "getGenre",
        contentLanguage: "getVideoLanguage",
        subtitles: "getSubtitles",
        contractedResolution: "getContractedResolution",
        cost: "getCost",
        price: "getPrice",
        playbackType: "getPlaybackType",
        email: "getEmail"
    }
});
module.exports = RequestBuilder;

},{"749c20a0eb38c8e5":"j7KrE","2cd69da9cb9841a3":"8xsxZ"}],"7fbyw":[function(require,module,exports) {
var Emitter = require("a9c40b8b10f4f8b7");
var Comm = require("93cffaa32f3933e7");
var WrongTransform = require("3f0caa2d5c277fe2");
var Util = require("922bf836955c1dae");
var YouboraInfinity = Emitter.extend(/** @lends youbora.Infinity.prototype */ {
    /**
     * This class is the base of youbora infinity. Every plugin will have an instance.
     *
     * @param {youbora.Plugin} plugin Parent plugin.
     *
     * @constructs youbora.Infinity
     * @extends youbora.Emitter
     * @memberof youbora
     */ constructor: function(plugin) {
        /** Parent {@link youbora.Plugin} reference. */ this._plugin = plugin;
        this.infinityStopped = false;
        this.infinityStarted = false;
    },
    /**
     * @alias youbora.Infinity.prototype.begin.
     */ andBeyond: function() {
        YouboraInfinity.prototype.begin.apply(this, arguments);
    },
    /**
     * This method will start infinity logic, setting storage as needed.
     * Will call fireSessionStart the first time and fireNav for every subsequent route change.
     *
     * @param {Object} [params] Object of key:value params to add to the request.
     * @param {boolean} [forceNewSession] boolean to force open a new session.
     */ begin: function(dimensions, forceNewSession) {
        forceNewSession = forceNewSession || false;
        if (forceNewSession) {
            this._plugin.storage.removeStorages("infinityStarted");
            this._plugin.storage.removeStorages("data");
            this._plugin.restartViewTransform();
        }
        this._comm = new Comm(this._plugin);
        this._comm.addTransform(this._plugin.viewTransform);
        this._comm.addTransform(new WrongTransform(this._plugin));
        if (this._plugin && this._plugin.storage && typeof this._plugin.storage.getLocal === "function") this._registeredProperties = this._plugin.storage.getLocal("inifnityRegisteredProperties");
        // Retrieve infinityStarted state. Otherwise it will always be false (at this stage) and session will always be started.
        this.infinityStarted = this._plugin.storage.getLocal("infinityStarted") === "true";
        if (this.infinityStopped || !this.infinityStarted) // send start session with navigation information at beginning
        this.fireSessionStart(dimensions);
        else {
            // if plugin is previously initiated (appAnalyticsStarted), fire Navigation directly
            this.fireNav(dimensions);
            this._sendExtraBeat();
        }
    },
    _setLastActive: function() {
        if (!this._firstActive) this._firstActive = this.getFirstActive();
        this._plugin.storage.setStorages("lastactive", new Date().getTime());
    },
    getFirstActive: function() {
        return Number(this._plugin.getLastActive()) || 0;
    },
    /**
     * Returns the current {@link youbora.Communication} instance.
     *
     * @returns {youbora.Communication} communication instance
     */ getComm: function() {
        return this._comm;
    },
    // Fire
    /**
     * Emits session start request.
     *
     * @param {Object} [params] Object of key:value params to add to the request.
     */ fireSessionStart: function(dimensions) {
        if (this.infinityStopped) {
            this._plugin.restartViewTransform();
            this._comm = new Comm(this._plugin);
            this._comm.addTransform(this._plugin.viewTransform);
            this._comm.addTransform(new WrongTransform(this._plugin));
            this.infinityStopped = false;
        }
        if (!this.infinityStarted) {
            this._plugin.storage.setLocal("infinityStarted", "true");
            this.infinityStarted = true;
            this.emit(YouboraInfinity.Event.SESSION_START, this._getParamsJson(dimensions, null, null, true, true));
            this._setLastActive();
        }
    },
    /**
     * Emits session start request.
     *
     * @param {Object} [params] Object of key:value params to add to the request.
     */ fireSessionStop: function(params) {
        if (this.infinityStarted) {
            this.infinityStopped = true;
            this.infinityStarted = false;
            this._plugin.storage.removeStorages("infinityStarted");
            this.emit(YouboraInfinity.Event.SESSION_STOP, params);
            this._plugin.storage.removeStorages("data");
            this._plugin.storage.removeStorages("session");
            this._plugin.storage.removeStorages("lastactive");
        }
    },
    /**
     * Stops the session and creates a new one
     *
     * @param {Object} [params] Object of key:value params to add to the request.
     */ newSession: function(options, params) {
        if (this.isActive()) {
            if (this.infinityStarted) this.fireSessionStop();
            else {
                this._plugin.storage.removeStorages("infinityStarted");
                this._plugin.storage.removeStorages("data");
                if (this._comm) this._comm.removeTransform(this._plugin.viewTransform);
                this._plugin.restartViewTransform();
                if (this._comm) this._comm.addTransform(this._plugin.viewTransform);
            }
        }
        this._plugin.setOptions(options);
        this.begin(params);
    },
    /**
     * Emits session start request.
     *
     * @param {Object} [params] Object of key:value params to add to the request.
     */ fireNav: function(dimensions) {
        if (this.isActive()) {
            this.infinityStarted = true;
            this.emit(YouboraInfinity.Event.NAV, this._getParamsJson(dimensions, null, null, true));
        }
    },
    _sendExtraBeat: function() {
        if (this._plugin && this._plugin._beat) {
            var now = new Date().getTime();
            var time = this._plugin._beat.chrono.startTime ? now - this._plugin._beat.chrono.startTime : 0;
            this._plugin._sendBeat(time);
            this._plugin._beat.chrono.startTime = now;
        }
        this._setLastActive();
    },
    /**
     * Emits session start request.
     *
     * @param {Object} [params] Object of key:value params to add to the request.
     */ fireEvent: function(eventName, dimensions, values, topLevelDimensions) {
        if (this.infinityStarted) {
            var builtParams = this._getParamsJson(dimensions, values, eventName);
            Util.assign(builtParams.params, topLevelDimensions || {});
            this.emit(YouboraInfinity.Event.EVENT, builtParams);
            this._setLastActive();
        }
    },
    /** Register properties sent by the User, to send in all the events
    *
    * @memberof youbora.Infinity.prototype
    */ register: function(dimensions, values) {
        this._registeredProperties = {
            dimensions: dimensions,
            values: values
        };
        this._plugin.storage.setLocal("inifnityRegisteredProperties", JSON.stringify(this._registeredProperties));
    },
    /** Calls register if registeredProperties is empty
    *
    * @memberof youbora.Infinity.prototype
    */ registerOnce: function(dimensions, values) {
        if (!this._registeredProperties) this.register(dimensions, values);
    },
    /** Unregister properties registered with register()
    *
    * @memberof youbora.Infinity.prototype
    */ unregister: function() {
        this._registeredProperties = null;
        this._plugin.storage.removeLocal("inifnityRegisteredProperties");
    },
    /**
     * Splits params in dimensions (strings) and values (numbers)
     *
     * @param {Object} [params] Object of key:value params to split before adding to request.
     */ _getParamsJson: function(dimensions, values, eventName, isNavigaton, isStart) {
        var returnparams = {};
        if (eventName) returnparams.name = eventName;
        returnparams.dimensions = dimensions || {};
        returnparams.values = values || {};
        if (this._registeredProperties) {
            for(var key in this._registeredProperties.dimensions)returnparams.dimensions[key] = this._registeredProperties.dimensions[key];
            for(var key2 in this._registeredProperties.values)returnparams.values[key2] = this._registeredProperties.values[key2];
        }
        var paramsObject = {
            params: returnparams
        };
        if (isNavigaton) {
            if (paramsObject.params.dimensions.page) {
                paramsObject.params.page = paramsObject.params.dimensions.page;
                delete paramsObject.params.dimensions.page;
            }
            if (paramsObject.params.dimensions.route) {
                paramsObject.params.route = paramsObject.params.dimensions.route;
                delete paramsObject.params.dimensions.route;
            }
            if (!isStart) delete paramsObject.params.dimensions;
            delete paramsObject.params.values;
        }
        return paramsObject;
    },
    isActive: function() {
        var started = this._plugin.storage.getLocal("infinityStarted");
        if (this.infinityStarted || started && started !== "false") return true;
        var now = new Date().getTime();
        if (Number(this._plugin.getLastActive()) + this._plugin.sessionExpire > now) return true;
        return false;
    }
}, /** @lends youbora.Plugin */ {
    // Static Memebers //
    /**
     * List of events that could be fired
     * @enum
     * @event
     */ Event: {
        NAV: "nav",
        SESSION_START: "sessionStart",
        SESSION_STOP: "sessionStop",
        BEAT: "beat",
        EVENT: "event"
    }
});
module.exports = YouboraInfinity;

},{"a9c40b8b10f4f8b7":"cuYJd","93cffaa32f3933e7":"bOkDM","3f0caa2d5c277fe2":"7rzhF","922bf836955c1dae":"drhpF"}],"7rzhF":[function(require,module,exports) {
var Transform = require("8c4bd4d9442d22d7");
/**
 * This transform ensures that no requests will be sent without sessionId when is required
 *
 * @constructs
 * @extends youbora.Transform
 * @memberof youbora
 * @name WrongTransform
 *
 * @param {Plugin} plugin Instance of {@link Plugin}
 */ var WrongTransform = Transform.extend(/** @lends youbora.WrongTransform.prototype */ {
    /**
   * Returns if transform is blocking.
   *
   * @param {YBRequest} request Request to transform.
   * @return {bool} True if queue shall be blocked.
   */ isBlocking: function(request) {
        if (!request.params.sessionId) return true;
        return false;
    }
});
module.exports = WrongTransform;

},{"8c4bd4d9442d22d7":"8oBJA"}],"f3wLd":[function(require,module,exports) {
var YouboraObject = require("3ace13a69f5a57a3");
var Log = require("f8cfe275d6f81b3e");
var ProductAnalyticsConfig = require("247513191699224a");
var ProductAnalyticsUserState = require("3aadbdd5d6949c6b");
var YouboraProductAnalytics = YouboraObject.extend(/** @lends youbora.ProductAnalytics.prototype */ {
    /**
     * This class is the base of productanalytics. Every plugin will have an instance.
     *
     * @param {youbora.Plugin} plugin Parent plugin.
     *
     * @constructs youbora.ProductAnalytics
     * @extends youbora.Emitter
     * @memberof youbora
     */ constructor: function(plugin) {
        /** Parent {@link youbora.Plugin} reference. */ this._plugin = typeof plugin === "undefined" ? null : plugin;
        this._infinity = this._plugin && this._plugin.infinity ? this._plugin.infinity : null;
        this._initialized = false;
        // Product analytics attributes
        this._productAnalyticsSettingsDefault = {
            autoTrackNavigation: true,
            autoTrackAttribution: true,
            highlightContentAfter: 1000,
            enableStateTracking: false,
            activeStateTimeout: 30000,
            activeStateDimension: 9,
            pageRules: []
        };
        this._productAnalyticsSettings = Object.assign({}, this._productAnalyticsSettingsDefault);
        this._page = null;
        this._userState = null;
        this._config = null;
        this._searchQuery = null;
        this._location = typeof window === "undefined" || typeof window.location === "undefined" ? null : window.location;
        this._contentHighlighted = null;
        this._contentHighlightTimeout = null;
        if (!this._plugin) Log.warn("Plugin reference unset.");
        if (!this._infinity) Log.warn("Infinity reference unset.");
        if (!this._location) Log.warn("Location reference unset.");
    },
    /**
      * Initializes product analytics
      * @param {Object} productAnalyticsSettings product analytics settings
      * @param {Object} [npawtmConfigValue] configuration settings
      */ initialize: function(productAnalyticsSettings) {
        var query;
        // Load settings
        this._productAnalyticsSettings = Object.assign({}, this._productAnalyticsSettingsDefault);
        if (typeof productAnalyticsSettings === "object") Object.assign(this._productAnalyticsSettings, productAnalyticsSettings);
        // Validate settings
        if (typeof this._productAnalyticsSettings.autoTrackNavigation !== "boolean") this._productAnalyticsSettings.autoTrackNavigation = this._productAnalyticsSettingsDefault.autoTrackNavigation;
        if (typeof this._productAnalyticsSettings.autoTrackAttribution !== "boolean") this._productAnalyticsSettings.autoTrackAttribution = this._productAnalyticsSettingsDefault.autoTrackAttribution;
        if (typeof this._productAnalyticsSettings.highlightContentAfter !== "number") this._productAnalyticsSettings.highlightContentAfter = this._productAnalyticsSettingsDefault.highlightContentAfter;
        else if (this._productAnalyticsSettings.highlightContentAfter < 1000) {
            Log.warn("Invalid higlightContentAfter value. Using default value instead.");
            this._productAnalyticsSettings.highlightContentAfter = this._productAnalyticsSettingsDefault.highlightContentAfter;
        }
        if (typeof this._productAnalyticsSettings.enableStateTracking !== "boolean") this._productAnalyticsSettings.enableStateTracking = this._productAnalyticsSettingsDefault.enableStateTracking;
        if (typeof this._productAnalyticsSettings.activeStateTimeout !== "number") this._productAnalyticsSettings.activeStateTimeout = this._productAnalyticsSettingsDefault.activeStateTimeout;
        if (typeof this._productAnalyticsSettings.activeStateDimension !== "number" || this._productAnalyticsSettings.activeStateDimension < 1 || this._productAnalyticsSettings.activeStateDimension > 9) this._productAnalyticsSettings.activeStateDimension = this._productAnalyticsSettingsDefault.activeStateDimension;
        if (typeof this._productAnalyticsSettings.pageRules === "undefined" || !Array.isArray(this._productAnalyticsSettings.pageRules)) this._productAnalyticsSettings.pageRules = this._productAnalyticsSettingsDefault.pageRules;
        // Identify current page
        this._config = new ProductAnalyticsConfig(this._fireEvent.bind(this));
        this._identify();
        // Set as initialized
        this._initialized = true;
        // Track navigation
        if (this._productAnalyticsSettings.autoTrackNavigation) this._trackNavigation();
        // Track attribution
        if (this._productAnalyticsSettings.autoTrackAttribution) {
            query = this._location === null ? "" : this._location.search;
            this._trackAttribution(new URLSearchParams(query));
        }
    },
    /**
     * Identify current page
     * @private
     */ _identify: function() {
        var regex;
        var r;
        var i;
        // Try to identify using config approach
        if (this._config === null) this._page = null;
        else this._page = this._config.identify(this._location);
        // Try to identify using pageRules setting
        for(i = 0; i < this._productAnalyticsSettings.pageRules.length && this._page === null && this._location !== null; i++){
            r = this._productAnalyticsSettings.pageRules[i];
            if (typeof r.rule !== "undefined" && typeof r.page !== "undefined") {
                try {
                    regex = new RegExp(r.rule);
                } catch (ex) {
                    regex = null;
                    Log.warn("Error processing rule", r.rule, r.page);
                }
                if (regex !== null && this._location.pathname.match(regex) !== null) this._page = this._location.pathname.replace(regex, r.page);
            }
        }
        // If identication has failed, set pathname as page name
        if (this._page === null && this._location !== null) this._page = this._location.pathname;
    },
    // -------------------------------------------------------------------------------------------
    // ADAPTER
    // -------------------------------------------------------------------------------------------
    /**
      * Track adapter start
      * @private
      */ _adapterTrackStart: function() {
        if (this._initialized) this.trackPlayerInteraction("start", {}, {}, true);
    },
    /**
      * Execute after adapter is set to plugin
      */ adapterAfterSet: function() {
        var adapter;
        if (this._initialized) {
            // Set active state
            if (this._productAnalyticsSettings.enableStateTracking) {
                if (this._userState !== null) Log.warn("userState is already initialized.");
                if (!this._plugin) Log.warn("Cannot track user state since plugin is unavailable.");
                else if (!this._plugin.setOptions) Log.warn("Cannot track user state since plugin options are unavailable.");
                else this._userState = new ProductAnalyticsUserState(this._productAnalyticsSettings.activeStateDimension, this._productAnalyticsSettings.activeStateTimeout, this._fireAdapterEvent.bind(this), this._plugin.setOptions.bind(this._plugin));
            } else this._userState = null;
            // Track player interaction
            adapter = this._adapterGet();
            if (adapter) adapter.on("start", this._adapterTrackStart.bind(this));
            else Log.warn("Cannot bind adapter start since it is unavailable.");
        }
    },
    /**
      * Execute before removing adapter from plugin
      */ adapterBeforeRemove: function() {
        var adapter;
        adapter = this._adapterGet();
        if (adapter) adapter.off("start", this._adapterTrackStart);
        else if (this._initialized) Log.warn("Cannot unbind adapter start since it is unavailable.");
        this._userState = null;
    },
    /**
      * Get adapter
      * @private
      */ _adapterGet: function() {
        var adapter;
        if (!this._plugin) adapter = null;
        else if (typeof this._plugin.getAdapter !== "function") adapter = null;
        else adapter = this._plugin.getAdapter();
        return typeof adapter === "undefined" ? null : adapter;
    },
    // ------------------------------------------------------------------------------------------------------------------------------
    // SESSION
    // ------------------------------------------------------------------------------------------------------------------------------
    /**
      * New user session
      */ newSession: function() {
        var executed = false;
        if (!this._initialized) Log.warn("Cannot start a new session since Product Analytics is uninitialized.");
        else if (!this._infinity) Log.warn("Cannot start a new session since infinity is unavailable.");
        else {
            this._infinity.newSession();
            executed = true;
        }
        return executed;
    },
    /**
      * Ends user session
      */ endSession: function() {
        var executed = false;
        if (!this._initialized) Log.warn("Cannot end session since Product Analytics is uninitialized.");
        else if (!this._infinity) Log.warn("Cannot end session since infinity is unavailable.");
        else {
            this._infinity.fireSessionStop();
            executed = true;
        }
        return executed;
    },
    // ------------------------------------------------------------------------------------------------------------------------------
    // NAVIGATION
    // ------------------------------------------------------------------------------------------------------------------------------
    /**
      * Tracks navigation
      * @param {string} pageName The unique name to identify a page of the application.
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      */ trackNavigation: function(pageName, dimensions, metrics) {
        if (!this._initialized) Log.warn("Cannot track navigation since Product Analytics is uninitialized.");
        else if (typeof pageName !== "string" || pageName === "") Log.warn("Cannot track navigation since page has not been supplied.");
        else {
            this._page = pageName;
            this._trackNavigation(dimensions, metrics);
        }
    },
    /**
      * Tracks navigation (either manually or automatically)
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      * @private
      */ _trackNavigation: function(dimensions, metrics) {
        var route;
        var path;
        var host;
        // Get UTM Options
        if (this._location === null) {
            route = "";
            path = "";
            host = "";
        } else {
            route = this._location.href;
            path = this._location.pathname;
            host = this._location.hostname;
        }
        if (!this._initialized) Log.warn("Cannot track navigation since Product Analytics is uninitialized.");
        else if (!this._infinity) Log.warn("Cannot track navigation since infinity is unavailable.");
        else {
            this._infinity.begin({
                route: route,
                page: this._page
            });
            Log.notice("[NAV]", this._page);
            this._fireEvent("[NAV] " + this._page, {
                eventType: "Navigation",
                route: path,
                routeDomain: host,
                fullRoute: route
            }, dimensions, metrics);
        }
    },
    // ------------------------------------------------------------------------------------------------------------------------------
    // ATTRIBUTION
    // ------------------------------------------------------------------------------------------------------------------------------
    /**
      * Tracks attribution
      * @param {string} utmSource The UTM Source parameter. It is commonly used to identify a search engine, newsletter, or other source (i.e., Google, Facebook, etc.).
      * @param {string} utmMedium The UTM Medium parameter. It is commonly used to identify a medium such as email or cost-per-click (cpc).
      * @param {string} utmCampaign The UTM Campaign parameter. It is commonly used for campaign analysis to identify a specific product promotion or strategic campaign (i.e., spring sale).
      * @param {string} utmTerm The UTM Term parameter. It is commonly used with paid search to supply the keywords for ads (i.e., Customer, NonBuyer, etc.).
      * @param {string} utmContent The UTM Content parameter. It is commonly used for A/B testing and content-targeted ads to differentiate ads or links that point to the same URL (i.e., Banner1, Banner2, etc.)
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      */ trackAttribution: function(utmSource, utmMedium, utmCampaign, utmTerm, utmContent, dimensions, metrics) {
        if (!this._initialized) Log.warn("Cannot track attribution since Product Analytics is uninitialized.");
        else if (this._productAnalyticsSettings.autoTrackAttribution) Log.warn("Automatic attribution tracking is enabled: this request won't be processed.");
        else {
            var params;
            params = {};
            if (typeof utmSource !== "undefined") params.utm_source = utmSource;
            if (typeof utmMedium !== "undefined") params.utm_medium = utmMedium;
            if (typeof utmCampaign !== "undefined") params.utm_campaign = utmCampaign;
            if (typeof utmTerm !== "undefined") params.utm_term = utmTerm;
            if (typeof utmContent !== "undefined") params.utm_content = utmContent;
            this._trackAttribution(new URLSearchParams(params), dimensions, metrics);
        }
    },
    /**
      * Tracks attribution (either manually or automatically)
      * @param {URLSearchParams} params Object where to look for UTM params.
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      * @private
      */ _trackAttribution: function(params, dimensions, metrics) {
        // Get UTM parameters
        var utmParams = this._getUTMParams(params);
        var url = this._location === null ? "" : this._location.href;
        // Track attribution
        if (!this._initialized) Log.warn("Cannot track attribution since Product Analytics is uninitialized.");
        else if (utmParams) {
            Log.notice("ATTRIBUTION");
            this._fireEvent("ATTRIBUTION", Object.assign({
                eventType: "Attribution",
                url: url
            }, utmParams), dimensions, metrics);
        }
    },
    /**
     * Retrieves UTM params from querystring (utm_source, utm_medium, utm_campaign, utm_term, utm_content) and returns an object containing them but
     * with key formatted as specified by utmFormatDot.
     * @param {URLSearchParams} params Object where to look for UTM params
     * @returns {{}}
     * @private
     */ _getUTMParams: function(params) {
        var utmParams;
        var keySplitted;
        var keyIndex;
        var keys;
        var key;
        keys = [
            "utm_source",
            "utm_medium",
            "utm_campaign",
            "utm_term",
            "utm_content"
        ];
        utmParams = {};
        // Look for UTM params and add them to the newly constructed object converting key as specified by utmFormatDot
        params.forEach(function(paramValue, paramKey) {
            keyIndex = keys.indexOf(paramKey.toLowerCase());
            if (keyIndex !== -1) {
                key = keys[keyIndex];
                keySplitted = key.split("_");
                if (keySplitted.length > 1) key = keySplitted[0] + keySplitted[1].charAt(0).toUpperCase() + keySplitted[1].slice(1);
                utmParams[key] = paramValue;
            }
        });
        return Object.keys(utmParams).length > 0 ? utmParams : null;
    },
    // ------------------------------------------------------------------------------------------------------------------------------
    // SECTION
    // ------------------------------------------------------------------------------------------------------------------------------
    /**
      * Section goes into viewport.
      * @param {string} section The section title. It is commonly used to indicate the section title presented over a grid layout (e.g. Recommended Movies, Continue Watching, etc).
      * @param {Number} sectionOrder The section order within the page.
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      */ trackSectionIn: function(section, sectionOrder, dimensions, metrics) {
        if (!this._initialized) Log.warn("Cannot track section-in since Product Analytics is uninitialized.");
        else if (typeof section !== "string" || section === "") Log.warn("Cannot track section-in since no section has been supplied.");
        else if (typeof sectionOrder !== "number" || sectionOrder < 1) Log.warn("Cannot track section-in since sectionOrder is invalid.");
        else {
            Log.notice("[SECTION] In");
            this._fireEvent("SECTION IN", {
                eventType: "SectionVisibility",
                sectionOrder: sectionOrder,
                section: section
            }, dimensions, metrics);
        }
    },
    /**
      * Section goes out of viewport.
      * @param {string} section The section title. It is commonly used to indicate the section title presented over a grid layout (e.g. Recommended Movies, Continue Watching, etc).
      * @param {Number} sectionOrder The section order within the page.
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      */ trackSectionOut: function(section, sectionOrder, dimensions, metrics) {
        if (!this._initialized) Log.warn("Cannot track section-out since Product Analytics is uninitialized.");
        else if (typeof section !== "string" || section === "") Log.warn("Cannot track section-out since no section has been supplied.");
        else if (typeof sectionOrder !== "number" || sectionOrder < 1) Log.warn("Cannot track section-out since sectionOrder is invalid.");
        else {
            Log.notice("[SECTION] Out");
            this._fireEvent("SECTION OUT", {
                eventType: "SectionVisibility",
                sectionOrder: sectionOrder,
                section: section
            }, dimensions, metrics);
        }
    },
    // ------------------------------------------------------------------------------------------------------------------------------
    // CONTENT
    // ------------------------------------------------------------------------------------------------------------------------------
    /**
      * Sends a content highlight event if content is focused during, at least, highlightContentAfter ms.
      * @param {string} section The section title. It is commonly used to indicate the section title presented over a grid layout (e.g. Recommended Movies, Continue Watching, etc).
      * @param {Number} sectionOrder The section order within the page.
      * @param {integer} column Used to indicate the column number where content is placed in a grid layout The first column is number 1.
      * @param {integer} row Used to indicate the row number where content is placed in a grid layout. The first row is number 1. In the case of a horizontal list instead of a grid, the row parameter should be set to 1.
      * @param {string} contentID The unique content identifier of the content linked.
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      */ contentFocusIn: function(section, sectionOrder, column, row, contentID, dimensions, metrics) {
        this.contentFocusOut();
        if (!this._initialized) Log.warn("Cannot track content highlight since Product Analytics is uninitialized.");
        else if (typeof section !== "string" || section === "") Log.warn("Cannot track content highlight since no section has been supplied.");
        else if (typeof sectionOrder !== "number" || sectionOrder < 1) Log.warn("Cannot track content highlight since sectionOrder is invalid.");
        else if (typeof column !== "number" || column < 1) Log.warn("Cannot track content highlight since column is invalid.");
        else if (typeof row !== "number" || row < 1) Log.warn("Cannot track content highlight since row is invalid.");
        else if (typeof contentID !== "string" || contentID === "") Log.warn("Cannot track content highlight since no contentID has been supplied.");
        else {
            this._contentHighlighted = {
                sectionOrder: sectionOrder,
                section: section,
                column: column,
                row: row,
                contentID: contentID,
                dimensions: dimensions,
                metrics: metrics
            };
            this._contentHighlightTimeout = setTimeout(this._trackContentHiglight.bind(this), this._productAnalyticsSettings.highlightContentAfter);
        }
    },
    /**
      * Content loses focus
      * @private
      */ contentFocusOut: function() {
        if (this._contentHighlightTimeout !== null) clearTimeout(this._contentHighlightTimeout);
        this._contentHighlighted = null;
        this._contentHighlightTimeout = null;
    },
    /**
      * Sends a content highlight event using selected content info
      * @private
      */ _trackContentHiglight: function() {
        if (this._contentHighlighted) {
            Log.notice("CONTENT HIGHLIGHT");
            this._fireEvent("CONTENT HIGHLIGHT", {
                eventType: "ContentHighlight",
                sectionOrder: this._contentHighlighted.sectionOrder,
                section: this._contentHighlighted.section,
                column: this._contentHighlighted.column,
                row: this._contentHighlighted.row,
                contentId: this._contentHighlighted.contentID
            }, this._contentHighlighted.dimensions, this._contentHighlighted.metrics);
        } else Log.warn("Cannot highlight content since no content is selected");
    },
    /**
      * Tracks the location of user clicks.
      * @param {string} section The section title. It is commonly used to indicate the section title presented over a grid layout (e.g. Recommended Movies, Continue Watching, etc).
      * @param {Number} sectionOrder The section order within the page.
      * @param {integer} column Used to indicate the column number where content is placed in a grid layout The first column is number 1.
      * @param {integer} row Used to indicate the row number where content is placed in a grid layout. The first row is number 1. In the case of a horizontal list instead of a grid, the row parameter should be set to 1.
      * @param {string} contentID The unique content identifier of the content linked.
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      */ trackContentClick: function(section, sectionOrder, column, row, contentID, dimensions, metrics) {
        if (!this._initialized) Log.warn("Cannot track content click since Product Analytics is uninitialized.");
        else if (typeof section !== "string" || section === "") Log.warn("Cannot track content click since no section has been supplied.");
        else if (typeof sectionOrder !== "number" || sectionOrder < 1) Log.warn("Cannot track content click since sectionOrder is invalid.");
        else if (typeof column !== "number" || column < 1) Log.warn("Cannot track content click since column is invalid.");
        else if (typeof row !== "number" || row < 1) Log.warn("Cannot track content click since row is invalid.");
        else if (typeof contentID !== "string" || contentID === "") Log.warn("Cannot track content click since no contentID has been supplied.");
        else {
            Log.notice("CONTENT CLICK");
            this._fireEvent("CONTENT CLICK", {
                eventType: "ContentClick",
                sectionOrder: sectionOrder,
                section: section,
                column: column,
                row: row,
                contentId: contentID
            }, dimensions, metrics);
        }
    },
    // ------------------------------------------------------------------------------------------------------------------------------
    // CONTENT PLAYBACK
    // ------------------------------------------------------------------------------------------------------------------------------
    /**
      * Tracks when a content starts playing be it automatically or through a user interaction.
      * @param {string} contentID The unique content identifier of the content being played.
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      */ trackPlay: function(contentID, dimensions, metrics) {
        if (!this._initialized) Log.warn("Cannot track play since Product Analytics is uninitialized.");
        else if (typeof contentID !== "string" || contentID === "") Log.warn("Cannot track play since no contentID has been supplied.");
        else {
            Log.notice("[PLAYER] Play");
            this._fireAdapterEvent("[PLAYER] Play", {
                eventType: "ContentPlayback",
                contentId: contentID
            }, dimensions, metrics);
            if (this._userState !== null) this._userState.setActive("Play");
        }
    },
    /**
      * Tracks content watching events.
      * TODO: add (2nd) argument to tell whether user state must be updated or not
      * @param {string} eventName The name of the interaction (i.e., Pause, Seek, Skip Intro, Skip Ads, Switch Language, etc.).
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      * @param {boolean} [playerStarted] Internal param informing that current interaction is responsible of first player start
      */ trackPlayerInteraction: function(eventName, dimensions, metrics, playerStarted) {
        if (!this._initialized) Log.warn("Cannot track player interaction since Product Analytics is uninitialized.");
        else if (typeof eventName !== "string" || eventName === "") Log.warn("Cannot track player interaction since no interaction name has been supplied.");
        else {
            Log.notice("[PLAYER]", eventName);
            this._fireAdapterEvent("[PLAYER] " + eventName, {
                eventType: "ContentPlayback"
            }, dimensions, metrics);
            if (this._userState !== null) this._userState.setActive(eventName, playerStarted);
        }
    },
    // ------------------------------------------------------------------------------------------------------------------------------
    // CONTENT SEARCH
    // ------------------------------------------------------------------------------------------------------------------------------
    /**
      * Tracks search query events.
      * @param {string} searchQuery The search term entered by the user.
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      */ trackSearchQuery: function(searchQuery, dimensions, metrics) {
        if (!this._initialized) Log.warn("Cannot track search query since Product Analytics is uninitialized.");
        else if (typeof searchQuery !== "string" || searchQuery === "") Log.warn("Cannot track search query since no searchQuery has been supplied.");
        else {
            Log.notice("[SEARCH] Query", searchQuery);
            this._searchQuery = searchQuery;
            this._fireEvent("[SEARCH] Query", {
                eventType: "ContentSearch",
                query: this._searchQuery
            }, dimensions, metrics);
        }
    },
    /**
      * Tracks search result events.
      * @param {integer} resultCount The number of search results returned by a search query.
      * @param {String} [searchQuery] The search term entered by the user.
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      */ trackSearchResult: function(resultCount, searchQuery, dimensions, metrics) {
        if (!this._initialized) Log.warn("Cannot track search result since Product Analytics is uninitialized.");
        else if (typeof resultCount !== "number") Log.warn("Cannot track search result since no resultCount has been supplied.");
        else {
            var query = typeof searchQuery === "string" && searchQuery !== "" ? searchQuery : this._searchQuery;
            Log.notice("[SEARCH] Results", resultCount);
            this._fireEvent("[SEARCH] Results", {
                eventType: "ContentSearch",
                query: query,
                resultCount: resultCount
            }, dimensions, metrics);
        }
    },
    /**
      * Tracks user interactions with search results.
      * @param {integer} column The content placement column. It is commonly used to indicate the column number where content is placed in a grid layout (i.e.1, 2, etc..).
      * @param {integer} row The content placement row. It is commonly used to indicate the row number where content is placed in a grid layout (i.e.1, 2, etc..).
      * @param {string} contentID The content identifier. It is used for internal content unequivocally identification (i.e., AAA000111222).
      * @param {String} [searchQuery] The search term entered by the user.
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      */ trackSearchClick: function(column, row, contentID, searchQuery, dimensions, metrics) {
        if (!this._initialized) Log.warn("Cannot track search click since Product Analytics is uninitialized.");
        else if (typeof column !== "number") Log.warn("Cannot track search click since no column has been supplied.");
        else if (typeof row !== "number") Log.warn("Cannot track search click since no row has been supplied.");
        else if (typeof contentID !== "string" || contentID === "") Log.warn("Cannot track search click since no contentID has been supplied.");
        else {
            var query = typeof searchQuery === "string" && searchQuery !== "" ? searchQuery : this._searchQuery;
            Log.notice("[SEARCH] Result Click");
            this._fireEvent("[SEARCH] Result Click", {
                eventType: "ContentSearch",
                query: query,
                column: column,
                row: row,
                contentId: contentID
            }, dimensions, metrics);
        }
    },
    // ------------------------------------------------------------------------------------------------------------------------------
    // EXTERNAL APPLICATIONS
    // ------------------------------------------------------------------------------------------------------------------------------
    /**
      * Tracks external app start events.
      * @param {string} appName The name of the application being used to deliver the content to the end-user (i.e., Netflix).
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      */ trackExternalAppLaunch: function(appName, dimensions, metrics) {
        if (!this._initialized) Log.warn("Cannot track external application launch since Product Analytics is uninitialized.");
        else if (typeof appName !== "string" || appName === "") Log.warn("Cannot track external application launch since no appName has been supplied.");
        else {
            Log.notice("APP LAUNCH", appName);
            this._fireEvent("APP LAUNCH", {
                eventType: "ExternalApplications",
                appName: appName
            }, dimensions, metrics);
        }
    },
    /**
      * Tracks external app stop events.
      * @param {string} appName The name of the application being used to deliver the content to the end-user (i.e., Netflix).
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      */ trackExternalAppExit: function(appName, dimensions, metrics) {
        if (!this._initialized) Log.warn("Cannot track external application exit since Product Analytics is uninitialized.");
        else if (typeof appName !== "string" || appName === "") Log.warn("Cannot track external application exit since no appName has been supplied.");
        else {
            Log.notice("APP EXIT", appName);
            this._fireEvent("APP EXIT", {
                eventType: "ExternalApplications",
                appName: appName
            }, dimensions, metrics);
        }
    },
    // ------------------------------------------------------------------------------------------------------------------------------
    // ENGAGEMENT
    // ------------------------------------------------------------------------------------------------------------------------------
    /**
      * Tracks engagement events.
      * @param {string} eventName The name of the engagement event (i.e., Share, Save, Rate, etc.).
      * @param {string} contentID The unique content identifier of the content the user is engaging with.
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      */ trackEngagementEvent: function(eventName, contentID, dimensions, metrics) {
        if (!this._initialized) Log.warn("Cannot track engagement event since Product Analytics is uninitialized.");
        else if (typeof eventName !== "string" || eventName === "") Log.warn("Cannot track engagement event since no eventName has been supplied.");
        else if (typeof contentID !== "string" || contentID === "") Log.warn("Cannot track engagement event since no contentID has been supplied.");
        else {
            Log.notice(eventName);
            this._fireEvent(eventName, {
                eventType: "Engagement",
                contentId: contentID
            }, dimensions, metrics);
        }
    },
    // ------------------------------------------------------------------------------------------------------------------------------
    // CUSTOM EVENT
    // ------------------------------------------------------------------------------------------------------------------------------
    /**
      * Track custom event
      * @param {string} eventName Name of the event to track
      * @param {Object} [dimensions] Dimensions to track
      * @param {Object} [metrics] Metrics to track
      */ trackEvent: function(eventName, dimensions, metrics) {
        if (!this._initialized) Log.warn("Cannot track event since Product Analytics is uninitialized.");
        else if (typeof eventName !== "string" || eventName === "") Log.warn("Event cannot be tracked since no eventName has been supplied.");
        else {
            Log.notice(eventName);
            this._fireEvent(eventName, {
                eventType: "CustomEvent"
            }, dimensions, metrics);
        }
    },
    // ------------------------------------------------------------------------------------------------------------------------------
    // INTERNAL
    // ------------------------------------------------------------------------------------------------------------------------------
    /**
      * Fires an event
      * @param {string} eventName Name of the event to be fired
      * @param {Object} dimensionsInternal Dimensions supplied by user
      * @param {Object} dimensionsUser Specific event dimensions
      * @param {Object} metrics Metrics to track
      * @private
      */ _fireEvent: function(eventName, dimensionsInternal, dimensionsUser, metrics) {
        var dimensions;
        var fired = false;
        // Extract top level dimensions from custom dimensions
        dimensions = this._buildDimensions(dimensionsInternal, dimensionsUser);
        // Track event
        if (this._infinity) {
            this._infinity.fireEvent(eventName, dimensions.custom, metrics, dimensions.top);
            fired = true;
        } else Log.warn("Cannot fire", eventName, "since infinity is unavailable.");
        return fired;
    },
    /**
      * Fires an adapter event (in case it is available)
      * @param {string} eventName Event name
      * @param {Object} dimensionsInternal Dimensions supplied by user
      * @param {Object} dimensionsUser Specific event dimensions
      * @param {Object} metrics Metrics to track
      * @private
      */ _fireAdapterEvent: function(eventName, dimensionsInternal, dimensionsUser, metrics) {
        var dimensions;
        var adapter;
        var fired = false;
        adapter = this._adapterGet();
        if (adapter) {
            dimensions = this._buildDimensions(dimensionsInternal, dimensionsUser);
            adapter.fireEvent(eventName, dimensions.custom, metrics, dimensions.top);
            fired = true;
        } else Log.warn("Cannot fire " + eventName + " event since adapter is unavailable.");
        return fired;
    },
    /**
      * Builds a list of top level and custom dimensions
      * @param {Object} dimensionsInternal Object containing list of internal dimensions
      * @param {Object} dimensionsUser Object containing list of custom dimensions
      * @private
      */ _buildDimensions: function(dimensionsInternal, dimensionsUser) {
        var dimensionsTopLevel;
        var dimensionsCustom;
        var topKeysDelete;
        var topKeys;
        // Build custom event dimensions
        dimensionsCustom = {
            page: this._page
        };
        if (typeof dimensionsInternal !== "undefined") dimensionsCustom = Object.assign(dimensionsCustom, dimensionsInternal);
        if (typeof dimensionsUser !== "undefined") dimensionsCustom = Object.assign(dimensionsCustom, dimensionsUser);
        dimensionsCustom = Object.assign(dimensionsCustom, {
            eventSource: "Product Analytics"
        });
        // List of Top Level Dimension keys
        topKeys = [
            "contentid",
            "contentId",
            "contentID",
            "utmSource",
            "utmMedium",
            "utmCampaign",
            "utmTerm",
            "utmContent"
        ];
        topKeysDelete = [
            "contentid",
            "contentId",
            "contentID"
        ];
        // Create object with top level dimensions
        dimensionsTopLevel = {};
        for(var key in dimensionsCustom)if (Object.prototype.hasOwnProperty.call(dimensionsCustom, key) && topKeys.indexOf(key) !== -1) dimensionsTopLevel[key] = dimensionsCustom[key];
        // Remove top level dimensions from custom dimensions list
        topKeysDelete.forEach(function(key) {
            delete dimensionsCustom[key];
        });
        return {
            custom: dimensionsCustom,
            top: dimensionsTopLevel
        };
    }
});
module.exports = YouboraProductAnalytics;

},{"3ace13a69f5a57a3":"j7KrE","f8cfe275d6f81b3e":"8xsxZ","247513191699224a":"hz3qM","3aadbdd5d6949c6b":"9ZCoO"}],"hz3qM":[function(require,module,exports) {
var Log = require("3167141081cea5db");
var YouboraObject = require("56ad99dedb75f2c0");
var YouboraProductAnalyticsConfig = YouboraObject.extend(/** @lends youbora.ProductAnalyticsConfig.prototype */ {
    /**
     * This class handles Product Analytics configuration.
     *
     * @param {function} fireEvent Fire Event method
     *
     * @constructs youbora.ProductAnalyticsConfig
     * @extends youbora.Object
     * @memberof youbora
     */ constructor: function(fireEvent) {
        this._fireEvent = typeof fireEvent === "function" ? fireEvent : null;
        // Load npawtmConfig object
        if (typeof window === "undefined" || typeof window.npawtmConfig !== "object") // Load directly from AdminAPI?: this.loadTagManager()
        this._npawtmConfig = null;
        else this._npawtmConfig = window.npawtmConfig;
    },
    /**
      * Identifies current page and get events to monitor when available.
      * @param {URL} location URL location
      * @returns {string} Identified page name / null
      */ identify: function(location) {
        var events;
        var page;
        page = null;
        events = [];
        if (!this._npawtmConfig) Log.warn("no config descriptor available");
        else {
            page = this._getPage(location);
            if (page === null) // No page identified: set default page name
            Log.warn("no page found");
            else // Page identified: look for bound events
            events = this._getEvents(page);
        }
        // Bind events
        if (typeof window === "undefined") Log.warn("Product Analytics Config: cannot bind events since DOM is not available");
        else if (events.length > 0) window.addEventListener("load", (function() {
            this._bindElements(events);
        }).bind(this));
        return page;
    },
    /**
      * Looks for a page matching the supplied URL (either directly or by means of a regular expression).
      * @param {URL} url URL to look for.
      * @returns {string|*} Name of the page matching the URL or null if no matches have been found.
      * @private
      */ _getPage: function(url) {
        var urlString;
        var regexInfo;
        var pageInfo;
        var regex;
        var i;
        var page = null;
        if (typeof url === "object" && url !== null && this._npawtmConfig && this._npawtmConfig.urls && this._npawtmConfig.regexes && this._npawtmConfig.domains && this._npawtmConfig.domains.includes(url.hostname.toLowerCase())) {
            // Direct URL lookup
            pageInfo = this._npawtmConfig.urls[url.pathname];
            if (typeof pageInfo !== "undefined" && typeof pageInfo.page !== "undefined") page = pageInfo.page;
            // If URL lookup fails, start regex lookup
            urlString = url.pathname + url.search;
            for(i = 0; i < this._npawtmConfig.regexes.length && page === null; i++){
                regexInfo = this._npawtmConfig.regexes[i];
                regex = new RegExp(regexInfo.regex);
                if (urlString.match(regex)) page = regexInfo.page;
            }
        }
        return page;
    },
    /**
      * Gets events bound to the current page.
      * @param {string} page Page name to look for.
      * @private
      */ _getEvents: function(page) {
        var events = this._npawtmConfig && this._npawtmConfig.events ? this._npawtmConfig.events[page] : null;
        if (typeof events === "undefined" || events === null) events = [];
        return events;
    },
    /**
      * Binding of element events pointed out by npawtmConfig.
      * @param {Array} events List of events to bind
      * @private
      */ _bindElements: function(events) {
        var eventInfo;
        var eventType;
        var element;
        var j;
        var i;
        for(i = 0; i < events.length; i++){
            eventInfo = events[i];
            element = document.querySelector(eventInfo.selector);
            if (element === null) Log.warn("element " + eventInfo.selector + " not found");
            else if (eventInfo.events.length === 0) Log.warn("element " + eventInfo.selector + " has no events to bind");
            else for(j = 0; j < eventInfo.events.length; j++){
                eventType = eventInfo.events[j];
                element.npawEventInfo = eventInfo;
                element.npawEventType = eventType;
                element.addEventListener(eventType, (function(eventData) {
                    var currentEventInfo = eventData.currentTarget.npawEventInfo;
                    var currentEventType = eventData.currentTarget.npawEventType;
                    this._elementEvent(currentEventInfo, currentEventType, eventData);
                }).bind(this));
            }
        }
    },
    /**
      * Tracks an event after a monitored element event has been triggered.
      * @param {Object} eventInfo
      * @param {string} eventType type of the triggered event (click...).
      * @param {Object} eventData additional event data supplied by the event listener.
      * @private
      */ _elementEvent: function(eventInfo, eventType, eventData) {
        var eventName = "[" + eventType + "] " + eventInfo.name;
        if (this._fireEvent) this._fireEvent(eventName, {
            uiElement: eventInfo.name,
            eventName: eventName,
            eventType: eventType
        });
        else Log.warn("Cannot trigger event since no handler has been provided");
    }
});
module.exports = YouboraProductAnalyticsConfig;

},{"3167141081cea5db":"8xsxZ","56ad99dedb75f2c0":"j7KrE"}],"9ZCoO":[function(require,module,exports) {
var Log = require("351519cffb65c2bc");
var YouboraObject = require("eb8ed53c89c58740");
var YouboraProductAnalyticsUserState = YouboraObject.extend(/** @lends youbora.ProductAnalyticsUserState.prototype */ {
    // ------------------------------------------------------------------------------------------------------------------------------
    // INITIALIZATION
    // ------------------------------------------------------------------------------------------------------------------------------
    /**
     * This class handles Product Analytics user state management.
     *
     * @param {number} dimension Custom dimension where to store the user state.
     * @param {number} interval Interval (in ms) to transition from active to passive state.
     * @param {function} fireAdapterEvent Handler for firing adapter events
     * @param {function} pluginOptionsHandler Handler for setting plugin options
     *
     * @constructs youbora.ProductAnalyticsUserState
     * @extends youbora.Object
     * @memberof youbora
     */ constructor: function(dimension, interval, fireAdapterEvent, pluginOptionsHandler) {
        if (typeof fireAdapterEvent !== "function") {
            Log.warn("Fire Adapter Event unset");
            fireAdapterEvent = null;
        }
        if (typeof pluginOptionsHandler !== "function") {
            Log.warn("Plugin Options Handler unset");
            pluginOptionsHandler = null;
        }
        if (typeof dimension !== "number" || dimension < 1 || dimension > 9) dimension = 9;
        if (typeof interval !== "number") interval = 30000;
        this._state = null;
        this._fireAdapterEvent = fireAdapterEvent;
        this._pluginOptionsHandler = pluginOptionsHandler;
        this._dimension = "content.customDimension." + dimension;
        this._timerId = null;
        this._timerInterval = interval;
        this._started = false;
        /*
      We must set state (customDimension) at the very beginning. Otherwise, customDimension will have "unknown" value during the time
      between page load and player first start.
      */ this._storeState(YouboraProductAnalyticsUserState.States.ACTIVE);
    },
    // ------------------------------------------------------------------------------------------------------------------------------
    // STATE MANAGEMENT
    // ------------------------------------------------------------------------------------------------------------------------------
    /**
      * Set active state
      * @param {string} eventName
      * @param {boolean} playerStarted
      */ setActive: function(eventName, playerStarted) {
        var state = YouboraProductAnalyticsUserState.States.ACTIVE;
        if (typeof playerStarted !== "boolean") playerStarted = false;
        if (this._started) {
            // Player already started: fire event + store state on change and always reset timer
            if (this._state !== state) {
                this._fireEvent(state, eventName);
                this._storeState(state);
            }
            this._timerStart();
        } else if (playerStarted) {
            // Player starting NOW: log event and reset timer.
            this._started = true;
            // this._fireEvent(state, eventName)
            this._timerStart();
        }
    },
    /**
      * Fire switch state event
      * @private
      */ _fireEvent: function(state, eventName) {
        var dimensions;
        Log.notice("User changing from state " + this._state + " to " + state);
        dimensions = {
            eventType: "ContentPlayback",
            newState: state,
            triggerEvent: eventName,
            stateFromTo: this._state + " to " + state
        };
        // Fire the event
        if (this._fireAdapterEvent) switch(state){
            case YouboraProductAnalyticsUserState.States.ACTIVE:
                this._fireAdapterEvent("[PLAYBACK STATE] Switch to Active", dimensions);
                break;
            case YouboraProductAnalyticsUserState.States.PASSIVE:
                this._fireAdapterEvent("[PLAYBACK STATE] Switch to Passive", dimensions);
                break;
        }
        else Log.warn("Cannot fire user state event since handler is unavailable");
    },
    /**
      * Store state
      * @param {string} state
      * @private
      */ _storeState: function(state) {
        var options;
        this._state = state;
        options = {};
        options[this._dimension] = this._state;
        if (this._pluginOptionsHandler) this._pluginOptionsHandler(options);
        else Log.warn("Cannot store user state since handler is unavailable");
    },
    // ------------------------------------------------------------------------------------------------------------------------------
    // TIMER MANAGEMENT
    // ------------------------------------------------------------------------------------------------------------------------------
    /**
      * Starts interaction monitor timer
      * @private
      */ _timerStart: function() {
        var state = YouboraProductAnalyticsUserState.States.PASSIVE;
        this._timerStop();
        this._timerId = setTimeout((function() {
            this._fireEvent(state, "timer");
            this._storeState(state);
        }).bind(this), this._timerInterval);
    },
    /**
      * Stops interaction monitor timer
      * @private
      */ _timerStop: function() {
        if (this._timerId) clearTimeout(this._timerId);
    }
}, /** @lends youbora.ProductAnalyticsUserState */ {
    // Static Members //
    /**
     * Interaction state enumeration
     * @enum
     * @event
     */ States: {
        ACTIVE: "active",
        PASSIVE: "passive"
    }
});
module.exports = YouboraProductAnalyticsUserState;

},{"351519cffb65c2bc":"8xsxZ","eb8ed53c89c58740":"j7KrE"}],"7oOQI":[function(require,module,exports) {
/* global PerformanceObserver */ var YouboraObject = require("6ce7820c7b033aa4");
var RUMSpeedIndex = require("7b867e6f97f706f0");
/**
 * This static class provides information about the load times of the page
 *
 * @constructs YouboraObject
 * @extends youbora.YouboraObject
 * @memberof youbora
 *
 */ var BrowserLoadTimes = YouboraObject.extend({
    constructor: function(plugin) {
        this.infinity = plugin.infinity;
        this.timeObject = null;
        this.playerSetup = null;
        this.perfObject = null;
        this.myTimesObject = {};
        if (typeof window !== "undefined" && typeof window.addEventListener === "function") {
            window.addEventListener("load", this._windowLoaded.bind(this));
            if (window.performance && window.performance.timing) {
                try {
                    if (typeof window.performance.getEntriesByType === "function") this.perfObject = window.performance;
                } catch (err) {
                // Nothing
                }
                this.timeObject = window.performance.timing;
            }
        }
        try {
            if (typeof PerformanceObserver === "function") {
                var observer = new PerformanceObserver((function(list, obj) {
                    var entries = list.getEntries();
                    this.myTimesObject.largestContentfulPaint = entries[entries.length - 1].renderTime;
                }).bind(this));
                if (PerformanceObserver.supportedEntryTypes.indexOf("largest-contentful-paint") > -1) observer.observe({
                    entryTypes: [
                        "largest-contentful-paint"
                    ]
                });
            }
        } catch (err) {
        // Cant use PerformanceObserver, entryTypes...
        }
    },
    _windowLoaded: function() {
        this.myTimesObject.onLoad = new Date().getTime();
        this._getEnoughFPS();
        setTimeout(this._fireLoadTimesEvent.bind(this), 1000);
    },
    _fireLoadTimesEvent: function() {
        this._getLastMetrics();
        this.infinity.fireEvent("loadTimes", {}, this._getAllValues());
    },
    _getAllValues: function() {
        var ret = {
            // Time between the navigation starts and the page loadEventEnd
            PageLoadTime: this.getPageLoadTime(),
            // Domain lookup time
            DNSTime: this.getDnsTime(),
            // Connection time
            TCPTime: this.getTcpTime(),
            // Handshake (https) connection time
            HandshakeTime: this.getHandshakeTime(),
            // Time between navigation starts and DOM is ready
            DomReadyTime: this.getDomReadyTime(),
            // Time between navigation start and beginning of the backend response
            BackendTime: this.getBackendTime(),
            // Time between navigation starts and page load event
            FrontendTime: this.getFrontendTime(),
            // The maximum of First Paint / First Contentful Paint and domContentLoadedEventEnd
            VisualReady: this.getTimeToVisuallyReady(),
            // https://developer.mozilla.org/en-US/docs/Glossary/Time_to_interactive
            TimeToInteractive: this.getTimeToInteractive(),
            // Accumulated time to download all the JS files
            JsTime: this.getJSTime(),
            // Accumulated time to download all the CSS files
            CssTime: this.getCSSTime(),
            // Accumulated time to download all the images
            ImageTime: this.getImageTime(),
            // Accumulated time to download all the fonts
            FontTime: this.getFontTime(),
            // Average latency of all the file requests
            AvgReqLatency: this.getAvgReqLatency(),
            // Highest latency of all the file requests
            MaxReqLatency: this.getMaxReqLatency(),
            // https://developer.mozilla.org/en-US/docs/Glossary/First_paint
            FirstPaint: this.getFirstPaint(),
            // https://developer.mozilla.org/en-US/docs/Glossary/First_contentful_paint
            FirstContentfulPaint: this.getFirstContentfulPaint(),
            // https://rockcontent.com/blog/largest-contentful-paint/
            LargestContentfulPaint: this.getLargestContentfulPaint(),
            // https://developer.mozilla.org/en-US/docs/Glossary/Speed_index
            SpeedIndex: this.getSpeedIndex()
        };
        for(var key in ret)if (ret[key] === null || ret[key] === undefined || ret[key] < 0) delete ret[key];
        else ret[key] = Math.round(ret[key]);
        return ret;
    },
    // Getters
    getPageLoadTime: function() {
        var ret = null;
        if (this.timeObject) ret = this.timeObject.loadEventEnd - this.timeObject.navigationStart;
        return ret;
    },
    getPlayerStartupTime: function() {
        var ret = null;
        if (this.timeObject && this.playerSetup) ret = this.playerSetup - this.timeObject.navigationStart;
        return ret;
    },
    getDnsTime: function() {
        var ret = null;
        if (this.timeObject) ret = this.timeObject.domainLookupEnd - this.timeObject.domainLookupStart;
        return ret;
    },
    getTcpTime: function() {
        var ret = null;
        if (this.timeObject) ret = this.timeObject.connectEnd - this.timeObject.connectStart;
        return ret;
    },
    getHandshakeTime: function() {
        var ret = null;
        if (this.timeObject && this.timeObject.secureConnectionStart) ret = this.timeObject.connectEnd - this.timeObject.secureConnectionStart;
        return ret;
    },
    getDomReadyTime: function() {
        var ret = null;
        if (this.timeObject) ret = this.timeObject.domComplete - this.timeObject.navigationStart;
        return ret;
    },
    getBackendTime: function() {
        var ret = null;
        if (this.timeObject) ret = this.timeObject.responseStart - this.timeObject.navigationStart;
        return ret;
    },
    getFrontendTime: function() {
        var ret = null;
        if (this.timeObject) ret = this.myTimesObject.onLoad - this.timeObject.responseStart;
        return ret;
    },
    getTimeToVisuallyReady: function() {
        var ret = this.myTimesObject.firstPaint || 0;
        if (this.timeObject) return Math.max(ret, this.timeObject.domContentLoadedEventEnd - this.timeObject.navigationStart || 0);
        return ret || null;
    },
    getTimeToInteractive: function() {
        if (this.myTimesObject.fps && this.getTimeToVisuallyReady()) return Math.max(this.myTimesObject.fps, this.getTimeToVisuallyReady());
        else setTimeout((function() {
            this.getTimeToInteractive();
        }).bind(this), 500);
    },
    getJSTime: function() {
        return this._getXTime("script");
    },
    getCSSTime: function() {
        return this._getXTime("css");
    },
    getImageTime: function() {
        return this._getXTime("img");
    },
    getFontTime: function() {
        return this._getXTime("css", [
            ".woff",
            ".otf",
            ".ttf"
        ]);
    },
    getAvgReqLatency: function() {
        try {
            if (this.perfObject && typeof this.perfObject.getEntriesByType === "function") {
                var count = 0;
                var latency = 0;
                var scripts = this.perfObject.getEntriesByType("resource");
                for(var i in scripts){
                    if (scripts[i].requestStart && scripts[i].responseStart) latency += scripts[i].responseStart - scripts[i].requestStart;
                    count++;
                }
                return latency / count;
            }
        } catch (err) {
        // Nothing
        }
        return null;
    },
    getFirstPaint: function() {
        return this.myTimesObject ? this.myTimesObject.firstPaint : null;
    },
    getFirstContentfulPaint: function() {
        return this.myTimesObject ? this.myTimesObject.firstContentfulPaint : null;
    },
    getLargestContentfulPaint: function() {
        return this.myTimesObject ? this.myTimesObject.largestContentfulPaint : null;
    },
    getMaxReqLatency: function() {
        try {
            if (this.perfObject && typeof this.perfObject.getEntriesByType === "function") {
                var scripts = this.perfObject.getEntriesByType("resource");
                var latency = 0;
                for(var i in scripts)if (scripts[i].requestStart && scripts[i].responseStart) latency = Math.max(latency, scripts[i].responseStart - scripts[i].requestStart);
                return latency;
            }
        } catch (err) {
        // Nothing
        }
        return null;
    },
    getSpeedIndex: function() {
        var ret = null;
        if (typeof window !== "undefined" && window.performance && typeof window.performance.getEntriesByType === "function") try {
            ret = RUMSpeedIndex();
        } catch (e) {
        // nothing
        }
        return ret;
    },
    _getXTime: function(type, validExtensions) {
        var ret = 0;
        try {
            if (this.perfObject && typeof this.perfObject.getEntriesByType === "function") {
                var scripts = this.perfObject.getEntriesByType("resource");
                for(var i in scripts)if (scripts[i].initiatorType === type) {
                    if (!validExtensions) ret += scripts[i].duration;
                    else {
                        var valid = false;
                        for(var ext in validExtensions)if (scripts[i].name.indexOf(validExtensions[ext] > 0)) valid = true;
                        if (valid) ret += scripts[i].duration;
                    }
                }
            }
        } catch (err) {
        // Nothing
        }
        return Math.round(ret) || null;
    },
    _getLastMetrics: function() {
        var firstPaint = null;
        var contentfulPaint = null;
        try {
            if (this.perfObject && typeof this.perfObject.getEntriesByType === "function") {
                var entries = this.perfObject.getEntriesByType("paint");
                for(var i in entries){
                    if (entries[i].name === "first-paint") firstPaint = entries[i].startTime;
                    else if (entries[i].name === "first-contentful-paint") contentfulPaint = entries[i].startTime;
                }
            }
        } catch (err) {
        // Nothing
        }
        // First paint
        if (!firstPaint && this.timeObject) firstPaint = this.timeObject.msFirstPaint - this.timeObject.navigationStart;
        // TODO first paint for firefox
        this.myTimesObject.firstPaint = firstPaint;
        // First contentful paint
        this.myTimesObject.firstContentfulPaint = contentfulPaint;
        // Others
        this.getTimeToInteractive();
    },
    _getEnoughFPS: function() {
        if (this.timeObject && typeof window !== "undefined") {
            var req = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function() {};
            this.preFPS = new Date().getTime();
            req((function() {
                var now = new Date().getTime();
                if (now < this.preFPS + 50) this.myTimesObject.fps = now - this.timeObject.navigationStart;
                else setTimeout((function() {
                    return this._getEnoughFPS();
                }).bind(this), 50);
            }).bind(this));
        } else return true;
    },
    // Setters
    setPlayerSetupTime: function() {
        this.playerSetup = this.playerSetup || new Date().getTime();
    }
});
module.exports = BrowserLoadTimes;

},{"6ce7820c7b033aa4":"j7KrE","7b867e6f97f706f0":"bZGze"}],"bZGze":[function(require,module,exports) {
/* istanbul ignore next */ /******************************************************************************
Copyright (c) 2014, Google Inc.
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.
    * Neither the name of the <ORGANIZATION> nor the names of its contributors
    may be used to endorse or promote products derived from this software
    without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
******************************************************************************/ /******************************************************************************
*******************************************************************************
  Calculates the Speed Index for a page by:
  - Collecting a list of visible rectangles for elements that loaded
    external resources (images, background images, fonts)
  - Gets the time when the external resource for those elements loaded
    through Resource Timing
  - Calculates the likely time that the background painted
  - Runs the various paint rectangles through the SpeedIndex calculation:
    https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index
  TODO:
  - Improve the start render estimate
  - Handle overlapping rects (though maybe counting the area as multiple paints
    will work out well)
  - Detect elements with Custom fonts and the time that the respective font
    loaded
  - Better error handling for browsers that don't support resource timing
*******************************************************************************
******************************************************************************/ var RUMSpeedIndex = function(win) {
    win = win || window;
    var doc = win.document;
    /****************************************************************************
    Support Routines
  ****************************************************************************/ // Get the rect for the visible portion of the provided DOM element
    var GetElementViewportRect = function(el) {
        var intersect = false;
        if (el.getBoundingClientRect) {
            var elRect = el.getBoundingClientRect();
            intersect = {
                top: Math.max(elRect.top, 0),
                left: Math.max(elRect.left, 0),
                bottom: Math.min(elRect.bottom, win.innerHeight || doc.documentElement.clientHeight),
                right: Math.min(elRect.right, win.innerWidth || doc.documentElement.clientWidth)
            };
            if (intersect.bottom <= intersect.top || intersect.right <= intersect.left) intersect = false;
            else intersect.area = (intersect.bottom - intersect.top) * (intersect.right - intersect.left);
        }
        return intersect;
    };
    // Check a given element to see if it is visible
    var CheckElement = function(el, url) {
        if (url) {
            var rect = GetElementViewportRect(el);
            if (rect) rects.push({
                url: url,
                area: rect.area,
                rect: rect
            });
        }
    };
    // Get the visible rectangles for elements that we care about
    var GetRects = function() {
        // Walk all of the elements in the DOM (try to only do this once)
        var elements = doc.getElementsByTagName("*");
        var re = /url\(.*(http.*)\)/ig;
        for(var i = 0; i < elements.length; i++){
            var el = elements[i];
            var style = win.getComputedStyle(el);
            // check for Images
            if (el.tagName === "IMG") CheckElement(el, el.src);
            // Check for background images
            if (style["background-image"]) {
                re.lastIndex = 0;
                var matches = re.exec(style["background-image"]);
                if (matches && matches.length > 1) CheckElement(el, matches[1].replace('"', ""));
            }
            // recursively walk any iFrames
            if (el.tagName === "IFRAME") try {
                var rect = GetElementViewportRect(el);
                if (rect) {
                    var tm = RUMSpeedIndex(el.contentWindow);
                    if (tm) rects.push({
                        tm: tm,
                        area: rect.area,
                        rect: rect
                    });
                }
            } catch (e) {}
        }
    };
    // Get the time at which each external resource loaded
    var GetRectTimings = function() {
        var timings = {};
        var requests = win.performance.getEntriesByType("resource");
        for(var i = 0; i < requests.length; i++)timings[requests[i].name] = requests[i].responseEnd;
        for(var j = 0; j < rects.length; j++)if (!("tm" in rects[j])) rects[j].tm = timings[rects[j].url] !== undefined ? timings[rects[j].url] : 0;
    };
    // Get the first paint time.
    var GetFirstPaint = function() {
        // If the browser supports a first paint event, just use what the browser reports
        if ("msFirstPaint" in win.performance.timing) firstPaint = win.performance.timing.msFirstPaint - navStart;
        var paintMetrics = win.performance.getEntriesByType("paint");
        for(var k = 0; k < paintMetrics.length; k++)if (paintMetrics[k].name === "first-paint") firstPaint = paintMetrics[k].startTime;
        // For browsers that don't support first-paint or where we get insane values,
        // use the time of the last non-async script or css from the head.
        if (firstPaint === undefined || firstPaint < 0 || firstPaint > 120000) {
            firstPaint = win.performance.timing.responseStart - navStart;
            var headURLs = {};
            var headElements = doc.getElementsByTagName("head")[0].children;
            for(var i = 0; i < headElements.length; i++){
                var el = headElements[i];
                if (el.tagName === "SCRIPT" && el.src && !el.async) headURLs[el.src] = true;
                if (el.tagName === "LINK" && el.rel === "stylesheet" && el.href) headURLs[el.href] = true;
            }
            var requests = win.performance.getEntriesByType("resource");
            var doneCritical = false;
            for(var j = 0; j < requests.length; j++)if (!doneCritical && headURLs[requests[j].name] && (requests[j].initiatorType === "script" || requests[j].initiatorType === "link")) {
                var requestEnd = requests[j].responseEnd;
                if (firstPaint === undefined || requestEnd > firstPaint) firstPaint = requestEnd;
            } else doneCritical = true;
        }
        firstPaint = Math.max(firstPaint, 0);
    };
    // Sort and group all of the paint rects by time and use them to
    // calculate the visual progress
    var CalculateVisualProgress = function() {
        var paints = {
            0: 0
        };
        var total = 0;
        for(var i = 0; i < rects.length; i++){
            var tm = firstPaint;
            if ("tm" in rects[i] && rects[i].tm > firstPaint) tm = rects[i].tm;
            if (paints[tm] === undefined) paints[tm] = 0;
            paints[tm] += rects[i].area;
            total += rects[i].area;
        }
        // Add a paint area for the page background (count 10% of the pixels not
        // covered by existing paint rects.
        var pixels = Math.max(doc.documentElement.clientWidth, win.innerWidth || 0) * Math.max(doc.documentElement.clientHeight, win.innerHeight || 0);
        if (pixels > 0) {
            pixels = Math.max(pixels - total, 0) * pageBackgroundWeight;
            if (paints[firstPaint] === undefined) paints[firstPaint] = 0;
            paints[firstPaint] += pixels;
            total += pixels;
        }
        // Calculate the visual progress
        if (total) {
            for(var time in paints)if (paints.hasOwnProperty(time)) progress.push({
                tm: time,
                area: paints[time]
            });
            progress.sort(function(a, b) {
                return a.tm - b.tm;
            });
            var accumulated = 0;
            for(var j = 0; j < progress.length; j++){
                accumulated += progress[j].area;
                progress[j].progress = accumulated / total;
            }
        }
    };
    // Given the visual progress information, Calculate the speed index.
    var CalculateSpeedIndex = function() {
        if (progress.length) {
            SpeedIndex = 0;
            var lastTime = 0;
            var lastProgress = 0;
            for(var i = 0; i < progress.length; i++){
                var elapsed = progress[i].tm - lastTime;
                if (elapsed > 0 && lastProgress < 1) SpeedIndex += (1 - lastProgress) * elapsed;
                lastTime = progress[i].tm;
                lastProgress = progress[i].progress;
            }
        } else SpeedIndex = firstPaint;
    };
    /****************************************************************************
    Main flow
  ****************************************************************************/ var rects = [];
    var progress = [];
    var firstPaint;
    var SpeedIndex;
    var pageBackgroundWeight = 0.1;
    try {
        var navStart = win.performance.timing.navigationStart;
        GetRects();
        GetRectTimings();
        GetFirstPaint();
        CalculateVisualProgress();
        CalculateSpeedIndex();
    } catch (e) {}
    return SpeedIndex;
};
module.exports = RUMSpeedIndex;

},{}],"eFDAY":[function(require,module,exports) {
var YouboraObject = require("4b8ee482a1fdf81e");
/**
 * This static class provides device detection methods.
 *
 * @class
 * @static
 * @memberof youbora
 */ var BackgroundDetector = YouboraObject.extend({
    constructor: function(plugin) {
        this.plugin = plugin;
        this.isInBackground = false;
        this.listenerReference = this._visibilityListener.bind(this);
        this._reset();
    },
    startDetection: function() {
        if (!this.isBackgroundDetectorStarted && typeof document !== "undefined") {
            this.isBackgroundDetectorStarted = true;
            document.addEventListener("visibilitychange", this.listenerReference);
        }
    },
    stopDetection: function() {
        if (this.isBackgroundDetectorStarted && typeof document !== "undefined") {
            document.removeEventListener("visibilitychange", this.listenerReference);
            this._reset();
        }
    },
    _reset: function() {
        this.isBackgroundDetectorStarted = false;
    },
    _visibilityListener: function(e) {
        if (typeof document !== "undefined") {
            var settings = this._getSettings();
            if (document.visibilityState === "hidden") this._toBackground(settings);
            else if (document.visibilityState === "visible") this._toForeground(settings);
        }
    },
    _toBackground: function(settings) {
        this.isInBackground = true;
        if (this.plugin && this.plugin._adsAdapter) this.plugin._adsAdapter.stopChronoView();
        if (typeof settings === "string") {
            switch(settings){
                case "stop":
                    this._fireStop();
                    break;
                case "pause":
                    this._firePause();
                    break;
            }
            if (this.plugin.infinity.infinityStarted) {
                this.lastBeatTime = new Date().getTime();
                var difftime = this.plugin._beat.chrono.startTime ? this.lastBeatTime - this.plugin._beat.chrono.startTime : 0;
                this.plugin._sendBeat(difftime);
                this.plugin._beat.stop();
            }
        }
    },
    _toForeground: function(settings) {
        this.isInBackground = false;
        // ads
        if (this.plugin && this.plugin._adsAdapter) this.plugin._adsAdapter.startChronoView();
        // nothing for video yet
        if (typeof settings === "string" && settings) {
            if (this.plugin.infinity.infinityStarted) {
                var now = new Date().getTime();
                if (now - this.lastBeatTime < this.plugin.sessionExpire) {
                    this.plugin._sendBeat(now - this.lastBeatTime);
                    this.plugin._beat.start();
                } else this.plugin.infinity.newSession();
            }
        }
    },
    _getSettings: function() {
        if (typeof this.plugin.options["background.settings"] === "string" && this.plugin.options["background.settings"]) return this.plugin.options["background.settings"];
        if (this.plugin.deviceDetector.isSmartTV()) return this.plugin.options["background.settings.tv"];
        if (this.plugin.deviceDetector.isDesktop()) return this.plugin.options["background.settings.desktop"];
        if (this.plugin.deviceDetector.isAndroid()) return this.plugin.options["background.settings.android"];
        if (this.plugin.deviceDetector.isIphone()) return this.plugin.options["background.settings.iOS"];
        if (this.plugin.deviceDetector.isPlayStation()) return this.plugin.options["background.settings.playstation"];
    },
    _firePause: function() {
        this._fireX("firePause");
    },
    _fireStop: function() {
        this._fireX("fireStop");
        this.plugin.fireStop();
    },
    _fireX: function(fireMethod) {
        this.adsAdapter = this.plugin.getAdsAdapter();
        if (this.adsAdapter) this.adsAdapter[fireMethod]();
        this.contentAdapter = this.plugin.getAdapter();
        if (this.contentAdapter) this.contentAdapter[fireMethod]();
    },
    canBlockStartCalls: function() {
        return this.isInBackground && this.plugin.options["background.enabled"] === true && this._getSettings() // it is stop or pause
        ;
    }
});
module.exports = BackgroundDetector;

},{"4b8ee482a1fdf81e":"j7KrE"}],"32dVf":[function(require,module,exports) {
var YouboraObject = require("69bceb4cbfc0baa8");
/**
 * This static class provides device detection methods.
 *
 * @class
 * @static
 * @memberof youbora
 */ var DeviceDetector = YouboraObject.extend({
    constructor: function() {
        if (typeof navigator !== "undefined" && navigator.userAgent) {
            this._isSmartTVDevice = navigator.userAgent.toLowerCase().match(/smarttv/) || navigator.userAgent.toLowerCase().match(/smart-tv/) || navigator.userAgent.toLowerCase().match(/appletv/) || navigator.userAgent.toLowerCase().match(/apple tv/);
            this._isPlaystationDevice = navigator.userAgent.match(/PlayStation/) !== null;
            this._isIphoneDevice = navigator.userAgent.match(/iPhone|iPad|iPod/i) !== null;
            this._isAndroidDevice = navigator.userAgent.match(/Android/) !== null;
            this._isSmartphoneDevice = !this._isSmartTVDevice && !this._isPlaystationDevice && (this._isIphoneDevice || this._isAndroidDevice);
            this._isDesktopDevice = !this._isSmartphoneDevice && !this._isSmartTVDevice && !this._isPlaystationDevice;
        }
    },
    isIphone: function() {
        return this._isIphoneDevice;
    },
    isAndroid: function() {
        return this._isAndroidDevice;
    },
    isSmartphone: function() {
        return this._isSmartphoneDevice;
    },
    isDesktop: function() {
        return this._isDesktopDevice;
    },
    isSmartTV: function() {
        return this._isSmartTVDevice;
    },
    isPlayStation: function() {
        return this._isPlaystationDevice;
    }
});
module.exports = DeviceDetector;

},{"69bceb4cbfc0baa8":"j7KrE"}],"f2Pza":[function(require,module,exports) {
var YouboraObject = require("176fbde50031c057");
/**
 * This static class provides screen scrolling and resizing detection methods.
 *
 * @class
 * @static
 * @memberof youbora
 */ var ResizeScrollDetector = YouboraObject.extend({
    constructor: function(plugin) {
        this.pluginref = plugin;
        this.listenerReference = this._changeListener.bind(this);
        this.loadReference = this._loadListener.bind(this);
        this.isEnabled = false;
        this.pageHeight = 0;
        this.maxHeight = 0;
        this.startDetection();
    },
    startDetection: function() {
        if (!this.isEnabled && typeof window !== "undefined" && typeof window.addEventListener === "function") {
            window.addEventListener("scroll", this.listenerReference);
            window.addEventListener("resize", this.listenerReference);
            window.addEventListener("load", this.loadReference);
            this.isEnabled = true;
        }
    },
    stopDetection: function() {
        if (this.isEnabled && typeof window !== "undefined" && typeof window.removeEventListener === "function") {
            window.removeEventListener("scroll", this.listenerReference);
            window.removeEventListener("resize", this.listenerReference);
            window.removeEventListener("load", this.loadReference);
            this.isEnabled = false;
        }
    },
    getScrollDepth: function() {
        var ret = null;
        if (this.maxHeight && this.pageHeight) ret = Math.min(Math.trunc(this.maxHeight / this.pageHeight * 100), 100);
        return ret;
    },
    _loadListener: function() {
        if (typeof document !== "undefined") {
            var docEl = document.documentElement;
            if (docEl) {
                this.pageHeight = Math.round(docEl.scrollHeight, docEl.clientHeight, docEl.offsetHeight);
                this.maxHeight = window.innerHeight;
                this._updateCompletionRate();
            }
        }
    },
    _changeListener: function() {
        if (this.pageHeight) {
            var prevHeight = this.maxHeight;
            this.maxHeight = Math.max(this.maxHeight, window.pageYOffset + window.innerHeight);
            if (prevHeight !== this.maxHeight) this._updateCompletionRate();
        }
        var adsAdapter = this.pluginref.getAdsAdapter();
        if (adsAdapter && adsAdapter.flags.isStarted) {
            if (!adsAdapter.getIsVisible()) adsAdapter.stopChronoView();
            else adsAdapter.startChronoView();
        }
    },
    _updateCompletionRate: function() {
        setTimeout((function() {
            this.pluginref.storage.setSession("pageScrollDepth", this.getScrollDepth());
        }).bind(this), 3000);
    }
});
module.exports = ResizeScrollDetector;

},{"176fbde50031c057":"j7KrE"}],"7v7Id":[function(require,module,exports) {
var DataExtractor = require("dfa7b0d2bb1ee2ba");
var YouboraObject = require("28ca33f089a42615");
var MD5 = require("29cca21651226ea4");
var HashGenerator = YouboraObject.extend({
    constructor: function(plugin) {
        this.plugin = plugin;
        this.dataExtractor = new DataExtractor();
        this.key = this.getPreviousKey();
    },
    generateHashKey: function() {
        if (!this.key) {
            var data = this.dataExtractor.getAllData();
            this.key = this._hashFunction(data);
            this.plugin.storage.setLocal("youboraDeviceUUID", this.key);
        }
    },
    getKey: function() {
        if (!this.key) this.generateHashKey();
        return this.key;
    },
    _hashFunction: function(inputString) {
        var outputString = inputString;
        if (typeof inputString !== "string") outputString = JSON.stringify(inputString);
        return MD5(outputString);
    },
    _reset: function() {
        this.key = undefined;
    },
    getPreviousKey: function() {
        return this.plugin.storage.getLocal("youboraDeviceUUID");
    }
});
module.exports = HashGenerator;

},{"dfa7b0d2bb1ee2ba":"9yhJM","28ca33f089a42615":"j7KrE","29cca21651226ea4":"75gn4"}],"9yhJM":[function(require,module,exports) {
/* global ActiveXObject */ var YouboraObject = require("26814fc45bdf4a19");
var DataExtractor = YouboraObject.extend({
    constructor: function(plugin) {
        this.plugin = plugin;
    },
    getAllData: function() {
        var returnValue = this.getNonRandomData();
        returnValue.timestamp = this.getTimestamp();
        return returnValue;
    },
    getNonRandomData: function() {
        var returnValue = {};
        returnValue.userAgent = this.getUserAgent();
        returnValue.threads = this.getVirtualCores();
        returnValue.language = this.getLanguage();
        returnValue.langList = this.getAvailableLanguages();
        returnValue.resolution = this.getResolution();
        returnValue.colorDepth = this.getColorDepth();
        returnValue.deviceMemory = this.getMemory();
        returnValue.touchscreen = this.getTouchscreen();
        returnValue.localStorage = this.getLocalStorage();
        returnValue.sessionStorage = this.getSessionStorage();
        returnValue.cookiesAvailable = this.getCookiesAvailable();
        returnValue.flashAvailable = this.getHasFlash();
        returnValue.timeZone = this.getTimeZone();
        returnValue.plugins = this.getPluginList();
        return returnValue;
    },
    // Getters
    getUserAgent: function() {
        return this._getNavigatorValue("userAgent");
    },
    getVirtualCores: function() {
        return this._getNavigatorValue("hardwareConcurrency");
    },
    getLanguage: function() {
        return this._getNavigatorValue("language");
    },
    getAvailableLanguages: function() {
        return this._getNavigatorValue("languages");
    },
    getResolution: function() {
        var ret = null;
        try {
            if (this._getNavigatorValue("screen")) ret = navigator.screen.width.toString() + navigator.screen.height.toString();
        } catch (err) {
        // ret = null
        }
        return ret;
    },
    getColorDepth: function() {
        var ret = null;
        try {
            if (this._getNavigatorValue("screen")) ret = navigator.screen.colorDepth;
        } catch (err) {
        // ret = null
        }
        return ret;
    },
    getMemory: function() {
        return this._getNavigatorValue("deviceMemory");
    },
    getTouchscreen: function() {
        return this._getNavigatorValue("maxTouchPoints") || false;
    },
    getLocalStorage: function() {
        var ret = false;
        try {
            ret = typeof localStorage !== "undefined";
        } catch (err) {
        // ret = false
        }
        return ret;
    },
    getSessionStorage: function() {
        var ret = false;
        try {
            ret = typeof sessionStorage !== "undefined";
        } catch (err) {
        // ret = false
        }
        return ret;
    },
    getCookiesAvailable: function() {
        return this._getNavigatorValue("cookieEnabled") || false;
    },
    getHasFlash: function() {
        var ret = false;
        try {
            var plugins = this._getNavigatorValue("plugins");
            ret = plugins && typeof plugins["Shockwave Flash"] === "object" || typeof window !== "undefined" && window.ActiveXObject && (new ActiveXObject("ShockwaveFlash.ShockwaveFlash"), true);
        } catch (err) {
        // ret = false
        }
        return ret;
    },
    getPluginList: function() {
        var ret = null;
        try {
            var plugins = this._getNavigatorValue("plugins");
            if (plugins && plugins.length !== 0) {
                var pluginlist = "";
                for(var counter = 0; counter < navigator.plugins.length; counter++)pluginlist += navigator.plugins[counter].description + " " + navigator.plugins[counter].filename + " " + navigator.plugins[counter].name + " ";
                ret = pluginlist;
            }
        } catch (err) {
        // return null
        }
        return ret;
    },
    getTimeZone: function() {
        var ret = null;
        try {
            var date = new Date();
            ret = date.getTimezoneOffset().toString();
        } catch (err) {
        // return null
        }
        return ret;
    },
    getTimestamp: function() {
        return new Date().getTime();
    },
    _navigatorCheck: function() {
        return typeof navigator !== "undefined";
    },
    _getNavigatorValue: function(key) {
        var ret = null;
        try {
            if (this._navigatorCheck()) ret = navigator[key];
        } catch (err) {
        // ret = null
        }
        return ret;
    }
});
module.exports = DataExtractor;

},{"26814fc45bdf4a19":"j7KrE"}],"75gn4":[function(require,module,exports) {
/* istanbul ignore next */ var MD5 = function(s) {
    function L(k, d) {
        return k << d | k >>> 32 - d;
    }
    function K(G, k) {
        var I, d, F, H, x;
        F = G & 2147483648;
        H = k & 2147483648;
        I = G & 1073741824;
        d = k & 1073741824;
        x = (G & 1073741823) + (k & 1073741823);
        if (I & d) return x ^ 2147483648 ^ F ^ H;
        if (I | d) {
            if (x & 1073741824) return x ^ 3221225472 ^ F ^ H;
            else return x ^ 1073741824 ^ F ^ H;
        } else return x ^ F ^ H;
    }
    function r(d, F, k) {
        return d & F | ~d & k;
    }
    function q(d, F, k) {
        return d & k | F & ~k;
    }
    function p(d, F, k) {
        return d ^ F ^ k;
    }
    function n(d, F, k) {
        return F ^ (d | ~k);
    }
    function u(G, F, aa, Z, k, H, I) {
        G = K(G, K(K(r(F, aa, Z), k), I));
        return K(L(G, H), F);
    }
    function f(G, F, aa, Z, k, H, I) {
        G = K(G, K(K(q(F, aa, Z), k), I));
        return K(L(G, H), F);
    }
    function D(G, F, aa, Z, k, H, I) {
        G = K(G, K(K(p(F, aa, Z), k), I));
        return K(L(G, H), F);
    }
    function t(G, F, aa, Z, k, H, I) {
        G = K(G, K(K(n(F, aa, Z), k), I));
        return K(L(G, H), F);
    }
    function e(G) {
        var Z;
        var F = G.length;
        var x = F + 8;
        var k = (x - x % 64) / 64;
        var I = (k + 1) * 16;
        var aa = Array(I - 1);
        var d = 0;
        var H = 0;
        while(H < F){
            Z = (H - H % 4) / 4;
            d = H % 4 * 8;
            aa[Z] = aa[Z] | G.charCodeAt(H) << d;
            H++;
        }
        Z = (H - H % 4) / 4;
        d = H % 4 * 8;
        aa[Z] = aa[Z] | 128 << d;
        aa[I - 2] = F << 3;
        aa[I - 1] = F >>> 29;
        return aa;
    }
    function B(x) {
        var k = "", F = "", G, d;
        for(d = 0; d <= 3; d++){
            G = x >>> d * 8 & 255;
            F = "0" + G.toString(16);
            k = k + F.substr(F.length - 2, 2);
        }
        return k;
    }
    function J(k) {
        k = k.replace(/rn/g, "n");
        var d = "";
        for(var F = 0; F < k.length; F++){
            var x = k.charCodeAt(F);
            if (x < 128) d += String.fromCharCode(x);
            else if (x > 127 && x < 2048) {
                d += String.fromCharCode(x >> 6 | 192);
                d += String.fromCharCode(x & 63 | 128);
            } else {
                d += String.fromCharCode(x >> 12 | 224);
                d += String.fromCharCode(x >> 6 & 63 | 128);
                d += String.fromCharCode(x & 63 | 128);
            }
        }
        return d;
    }
    var C = Array();
    var P, h, E, v, g, Y, X, W, V;
    var S = 7, Q = 12, N = 17, M = 22;
    var A = 5, z = 9, y = 14, w = 20;
    var o = 4, m = 11, l = 16, j = 23;
    var U = 6, T = 10, R = 15, O = 21;
    s = J(s);
    C = e(s);
    Y = 1732584193;
    X = 4023233417;
    W = 2562383102;
    V = 271733878;
    for(P = 0; P < C.length; P += 16){
        h = Y;
        E = X;
        v = W;
        g = V;
        Y = u(Y, X, W, V, C[P + 0], S, 3614090360);
        V = u(V, Y, X, W, C[P + 1], Q, 3905402710);
        W = u(W, V, Y, X, C[P + 2], N, 606105819);
        X = u(X, W, V, Y, C[P + 3], M, 3250441966);
        Y = u(Y, X, W, V, C[P + 4], S, 4118548399);
        V = u(V, Y, X, W, C[P + 5], Q, 1200080426);
        W = u(W, V, Y, X, C[P + 6], N, 2821735955);
        X = u(X, W, V, Y, C[P + 7], M, 4249261313);
        Y = u(Y, X, W, V, C[P + 8], S, 1770035416);
        V = u(V, Y, X, W, C[P + 9], Q, 2336552879);
        W = u(W, V, Y, X, C[P + 10], N, 4294925233);
        X = u(X, W, V, Y, C[P + 11], M, 2304563134);
        Y = u(Y, X, W, V, C[P + 12], S, 1804603682);
        V = u(V, Y, X, W, C[P + 13], Q, 4254626195);
        W = u(W, V, Y, X, C[P + 14], N, 2792965006);
        X = u(X, W, V, Y, C[P + 15], M, 1236535329);
        Y = f(Y, X, W, V, C[P + 1], A, 4129170786);
        V = f(V, Y, X, W, C[P + 6], z, 3225465664);
        W = f(W, V, Y, X, C[P + 11], y, 643717713);
        X = f(X, W, V, Y, C[P + 0], w, 3921069994);
        Y = f(Y, X, W, V, C[P + 5], A, 3593408605);
        V = f(V, Y, X, W, C[P + 10], z, 38016083);
        W = f(W, V, Y, X, C[P + 15], y, 3634488961);
        X = f(X, W, V, Y, C[P + 4], w, 3889429448);
        Y = f(Y, X, W, V, C[P + 9], A, 568446438);
        V = f(V, Y, X, W, C[P + 14], z, 3275163606);
        W = f(W, V, Y, X, C[P + 3], y, 4107603335);
        X = f(X, W, V, Y, C[P + 8], w, 1163531501);
        Y = f(Y, X, W, V, C[P + 13], A, 2850285829);
        V = f(V, Y, X, W, C[P + 2], z, 4243563512);
        W = f(W, V, Y, X, C[P + 7], y, 1735328473);
        X = f(X, W, V, Y, C[P + 12], w, 2368359562);
        Y = D(Y, X, W, V, C[P + 5], o, 4294588738);
        V = D(V, Y, X, W, C[P + 8], m, 2272392833);
        W = D(W, V, Y, X, C[P + 11], l, 1839030562);
        X = D(X, W, V, Y, C[P + 14], j, 4259657740);
        Y = D(Y, X, W, V, C[P + 1], o, 2763975236);
        V = D(V, Y, X, W, C[P + 4], m, 1272893353);
        W = D(W, V, Y, X, C[P + 7], l, 4139469664);
        X = D(X, W, V, Y, C[P + 10], j, 3200236656);
        Y = D(Y, X, W, V, C[P + 13], o, 681279174);
        V = D(V, Y, X, W, C[P + 0], m, 3936430074);
        W = D(W, V, Y, X, C[P + 3], l, 3572445317);
        X = D(X, W, V, Y, C[P + 6], j, 76029189);
        Y = D(Y, X, W, V, C[P + 9], o, 3654602809);
        V = D(V, Y, X, W, C[P + 12], m, 3873151461);
        W = D(W, V, Y, X, C[P + 15], l, 530742520);
        X = D(X, W, V, Y, C[P + 2], j, 3299628645);
        Y = t(Y, X, W, V, C[P + 0], U, 4096336452);
        V = t(V, Y, X, W, C[P + 7], T, 1126891415);
        W = t(W, V, Y, X, C[P + 14], R, 2878612391);
        X = t(X, W, V, Y, C[P + 5], O, 4237533241);
        Y = t(Y, X, W, V, C[P + 12], U, 1700485571);
        V = t(V, Y, X, W, C[P + 3], T, 2399980690);
        W = t(W, V, Y, X, C[P + 10], R, 4293915773);
        X = t(X, W, V, Y, C[P + 1], O, 2240044497);
        Y = t(Y, X, W, V, C[P + 8], U, 1873313359);
        V = t(V, Y, X, W, C[P + 15], T, 4264355552);
        W = t(W, V, Y, X, C[P + 6], R, 2734768916);
        X = t(X, W, V, Y, C[P + 13], O, 1309151649);
        Y = t(Y, X, W, V, C[P + 4], U, 4149444226);
        V = t(V, Y, X, W, C[P + 11], T, 3174756917);
        W = t(W, V, Y, X, C[P + 2], R, 718787259);
        X = t(X, W, V, Y, C[P + 9], O, 3951481745);
        Y = K(Y, h);
        X = K(X, E);
        W = K(W, v);
        V = K(V, g);
    }
    var i = B(Y) + B(X) + B(W) + B(V);
    return i.toLowerCase();
};
module.exports = MD5;

},{}],"5HS6h":[function(require,module,exports) {
var Log = require("e70ec7d1ea62900d");
var Constants = require("436eabfeedd9869");
var Util = require("84563377b89eab59");
var Adapter = require("c24ec421e7225abc");
// This file is designed to add extra functionalities to Plugin class
/** @lends youbora.Plugin.prototype */ var PluginContentMixin = {
    /**
   * Sets an adapter for video content.
   *
   * @param {Adapter} adapter
   *
   * @memberof youbora.Plugin.prototype
   */ setAdapter: function(adapter) {
        if (this.browserLoadTimes) this.browserLoadTimes.setPlayerSetupTime();
        if (adapter.plugin) Log.warn("Adapters can only be added to a single plugin");
        else {
            this.removeAdapter();
            this._adapter = adapter;
            adapter.plugin = this;
            adapter.setIsAds(false);
            // Register listeners
            this.contentAdapterListeners = {};
            this.contentAdapterListeners[Adapter.Event.START] = this._startListener.bind(this);
            this.contentAdapterListeners[Adapter.Event.JOIN] = this._joinListener.bind(this);
            this.contentAdapterListeners[Adapter.Event.PAUSE] = this._pauseListener.bind(this);
            this.contentAdapterListeners[Adapter.Event.RESUME] = this._resumeListener.bind(this);
            this.contentAdapterListeners[Adapter.Event.SEEK_BEGIN] = this._seekBufferBeginListener.bind(this);
            this.contentAdapterListeners[Adapter.Event.SEEK_END] = this._seekEndListener.bind(this);
            this.contentAdapterListeners[Adapter.Event.BUFFER_BEGIN] = this._seekBufferBeginListener.bind(this);
            this.contentAdapterListeners[Adapter.Event.BUFFER_END] = this._bufferEndListener.bind(this);
            this.contentAdapterListeners[Adapter.Event.ERROR] = this._errorListener.bind(this);
            this.contentAdapterListeners[Adapter.Event.STOP] = this._stopListener.bind(this);
            this.contentAdapterListeners[Adapter.Event.VIDEO_EVENT] = this._videoEventListener.bind(this);
            for(var key in this.contentAdapterListeners)this._adapter.on(key, this.contentAdapterListeners[key]);
            // We have to trigger an ('adapterSet') event in here so that ProductAnalytics can listen to it and call the appropriate methods
            if (this.productAnalytics) this.productAnalytics.adapterAfterSet();
        }
    },
    /**
   * Returns current adapter or null.
   *
   * @returns {Adapter}
   *
   * @memberof youbora.Plugin.prototype
   */ getAdapter: function() {
        return this._adapter;
    },
    /**
   * Removes the current adapter. Fires stop if needed. Calls adapter.dispose().
   *
   * @memberof youbora.Plugin.prototype
   * */ removeAdapter: function() {
        if (this._adapter) {
            // We have to trigger an ('adapterBeforeRemove') event in here so that ProductAnalytics can listen to it and call the appropriate methods
            if (this.productAnalytics) this.productAnalytics.adapterBeforeRemove();
            this._adapter.dispose();
            this._adapter.plugin = null;
            if (this.contentAdapterListeners) {
                for(var key in this.contentAdapterListeners)this._adapter.off(key, this.contentAdapterListeners[key]);
                delete this.contentAdapterListeners;
            }
            this._adapter = null;
        }
    },
    // ---------------------------------------- LISTENERS -----------------------------------------
    _startListener: function(e) {
        if (!this.isInitiated) {
            this.viewTransform.nextView();
            if (this.options && this.options["session.splitViews"]) e.data.params.viewIndex = this.viewTransform._viewIndex;
            this._initComm();
            this._startPings();
        } else if (this.initChrono.startTime !== 0) this._adapter.chronos.join.startTime = this.initChrono.startTime;
        try {
            // If exists resourceTransform, init with the resource
            if (this._adapter && this.resourceTransform) {
                var resource = this._getResourceForTransform();
                this.resourceTransform.init(resource);
            }
        } catch (e) {}
        var params = e.data.params || {};
        var allParamsReady = this.getResource() && typeof this.getIsLive() === "boolean" && (this.getIsLive() || typeof this.getDuration() === "number" && this.getDuration() > 0) && this.getTitle();
        allParamsReady = this.options.forceInit ? false : allParamsReady && this._isExtraMetadataReady();
        if (allParamsReady && !this.isInitiated) {
            this._send(Constants.WillSendEvent.WILL_SEND_START, Constants.Service.START, params);
            this._adSavedError();
            this._adSavedManifest();
            Log.notice(Constants.Service.START + " " + (params.title || params.mediaResource));
            this.isStarted = true;
        // chrono if had no adapter when inited
        } else if (!this.isInitiated) {
            this.isInitiated = true;
            this._adapter.chronos.join.start();
            this._send(Constants.WillSendEvent.WILL_SEND_INIT, Constants.Service.INIT, params);
            this._adSavedError();
            this._adSavedManifest();
            Log.notice(Constants.Service.INIT + " " + (params.title || params.mediaResource));
        }
    },
    _retryStart: function(e) {
        if (this._isExtraMetadataReady()) {
            this._send(Constants.WillSendEvent.WILL_SEND_START, Constants.Service.START, {});
            this.startDelayed = false;
        }
    },
    _joinListener: function(e) {
        var params = {};
        Util.assign(params, e.data.params || {});
        if (!this._adsAdapter || !this._adsAdapter.flags.isStarted) {
            if (this._adapter) {
                this._adapter.chronos.join.startTime = Math.min(this._adapter.chronos.join.startTime + (this._totalPrerollsTime || 0), new Date().getTime());
                this._totalPrerollsTime = 0;
            }
            if (this.isInitiated && !this.isStarted) {
                if (this._isExtraMetadataReady()) this._send(Constants.WillSendEvent.WILL_SEND_START, Constants.Service.START, params);
                else this.startDelayed = true;
                this._adSavedError();
                this._adSavedManifest();
                Log.notice(Constants.Service.START + " " + (params.title || params.mediaResource));
                this.isStarted = true;
            }
            params = e.data.params || {};
            if (this._adsAdapter && this.isBreakStarted) this._adsAdapter.fireBreakStop();
            this._send(Constants.WillSendEvent.WILL_SEND_JOIN, Constants.Service.JOIN, params);
            Log.notice(Constants.Service.JOIN + " " + params.joinDuration + "ms");
        } else {
            if (this._adapter.monitor) this._adapter.monitor.stop();
            this._adapter.flags.isJoined = false;
            this._adapter.chronos.join.stopTime = 0;
        }
    },
    _pauseListener: function(e) {
        if (this._adapter) {
            if (this._adapter.flags.isBuffering || this._adapter.flags.isSeeking || this._adsAdapter && this._adsAdapter.flags.isStarted) this._adapter.chronos.pause.reset();
        }
        var params = e.data.params || {};
        this._send(Constants.WillSendEvent.WILL_SEND_PAUSE, Constants.Service.PAUSE, params);
        Log.notice(Constants.Service.PAUSE + " at " + params.playhead + "s");
    },
    _resumeListener: function(e) {
        if (this._adsAdapter && this.isBreakStarted && !this._adsAdapter.flags.isStarted) this._adsAdapter.fireBreakStop();
        var params = e.data.params || {};
        this._send(Constants.WillSendEvent.WILL_SEND_RESUME, Constants.Service.RESUME, params);
        Log.notice(Constants.Service.RESUME + " " + params.pauseDuration + "ms");
        this._adapter.chronos.pause.reset();
    },
    _seekBufferBeginListener: function(e) {
        if (this._adapter && this._adapter.flags.isPaused) this._adapter.chronos.pause.reset();
        if (e.type && e.type.includes("buffer")) Log.notice(e.type + ", eventsTriggered: " + this._adapter.fireEventsStruct.buffer);
        else Log.notice(e.type + ", eventsTriggered: " + this._adapter.fireEventsStruct.seek);
    },
    _seekEndListener: function(e) {
        var params = e.data.params || {};
        this._send(Constants.WillSendEvent.WILL_SEND_SEEK, Constants.Service.SEEK, params);
        Log.notice(Constants.Service.SEEK + " to " + params.playhead + " in " + params.seekDuration + "ms" + (params.triggeredEvents ? ", eventsTriggered: " + params.triggeredEvents : ""));
    },
    _bufferEndListener: function(e) {
        var params = e.data.params || {};
        this._send(Constants.WillSendEvent.WILL_SEND_BUFFER, Constants.Service.BUFFER, params);
        Log.notice(Constants.Service.BUFFER + " to " + params.playhead + " in " + params.bufferDuration + "ms" + (params.triggeredEvents ? ", eventsTriggered: " + params.triggeredEvents : ""));
    },
    _errorListener: function(e) {
        if (!this._blockError(e.data.params)) {
            this.fireError(e.data.params || {});
            this._adSavedError();
            this._adSavedManifest();
        }
    },
    _blockError: function(errorParams) {
        var now = Date.now();
        var sameError = this._lastErrorParams ? this._lastErrorParams.errorCode === errorParams.errorCode && this._lastErrorParams.msg === errorParams.msg : false;
        if (sameError && this._lastErrorTime + 5000 > now) {
            this._lastErrorTime = now;
            return true;
        }
        this._lastErrorTime = now;
        this._lastErrorParams = errorParams;
        return false;
    },
    _stopListener: function(e) {
        this.fireStop(e.data.params || {});
    },
    _isStopReady: function(e) {
        var ret = false;
        // this solution is only for the case of:
        if (!this.requestBuilder.lastSent.live && // VOD, live have no postrolls
        this._adsAdapter && // having ads adapter connected
        this._adapter && // playhead close to the end of the content (or 0 because is already restarted)
        (!this._adapter.getPlayhead() || this._adapter.getPlayhead() >= this.requestBuilder.lastSent.mediaDuration - 1)) {
            var expectedPostrolls = 0;
            var pat = this.options["ad.expectedPattern"];
            // We can get the expectedPostrolls from the expected pattern if it has postrolls defined
            if (pat && pat.post && pat.post[0]) expectedPostrolls = pat.post[0];
            else if (this.requestBuilder.lastSent.breaksTime) {
                if (this.requestBuilder.lastSent.position === Constants.AdPosition.Postroll) expectedPostrolls = this.requestBuilder.lastSent.givenAds;
                // Or before playing postrolls, at least, we can check using breaksTime (from adManifest event) if we expect at least 1 postroll
                if (!expectedPostrolls && this.requestBuilder.lastSent.breaksTime) {
                    var breaks = this.requestBuilder.lastSent.breaksTime;
                    if (breaks.length > 0 && this.requestBuilder.lastSent.mediaDuration) {
                        var lastTimePosition = Math.round(breaks[breaks.length - 1]);
                        if (lastTimePosition + 1 >= this.requestBuilder.lastSent.mediaDuration) expectedPostrolls = 1;
                    }
                }
            // If none of the previous solutions found anything, we assume we have no postrolls
            } else ret = true;
            // Finally, if the number of played postrolls is the same (or more) than the expected, we can close the view
            if (expectedPostrolls <= this.playedPostrolls) ret = true;
        } else ret = true;
        return ret;
    },
    _videoEventListener: function(e) {
        this._send(Constants.WillSendEvent.WILL_SEND_VIDEO_EVENT, Constants.Service.VIDEO_EVENT, e.data.params);
    },
    _isExtraMetadataReady: function(e) {
        // If the option is disabled, always is ready
        if (!this.options.waitForMetadata || this.options.pendingMetadata.length < 1) return true;
        // If for existing parameters, one of them is false (no value for it), return false
        var getters = this.requestBuilder.getGetters();
        return this.options.pendingMetadata.map((function(element) {
            if (getters.hasOwnProperty(element)) return !!this[getters[element]]();
        }).bind(this)).indexOf(false) < 0;
    }
};
module.exports = PluginContentMixin;

},{"e70ec7d1ea62900d":"8xsxZ","436eabfeedd9869":"92xpS","84563377b89eab59":"drhpF","c24ec421e7225abc":"7AnqL"}],"7AnqL":[function(require,module,exports) {
var Emitter = require("7fa9f3ce378d6568");
var Log = require("110ebcdc0c317266");
var Util = require("a84074a55c00995d");
var version = require("f63f77ba4db7b17d");
var PlaybackChronos = require("82b9a6e6ef21d1b7");
var PlaybackFlags = require("ab0e66480cf0ee7c");
var PlayheadMonitor = require("a3497aac3c97aa66");
var StateMonitor = require("3763f4144bdf4531");
var AdapterConstants = require("b626be3588d4f1ec");
var Adapter = Emitter.extend(/** @lends youbora.this.prototype */ {
    /**
     * Main Adapter class. All specific player adapters should extend this class specifying a player
     * class.
     *
     * The Adapter works as the 'glue' between the player and YOUBORA acting both as event
     * translator and as proxy for the {@link Plugin} to get info from the player.
     *
     * @constructs Adapter
     * @extends youbora.Emitter
     * @memberof youbora
     *
     * @param {object|string} player Either an instance of the player or a string containing an ID.
     */ constructor: function(player) {
        /** An instance of {@link FlagStatus} */ this.flags = new PlaybackFlags();
        /** An instance of {@link ChronoStatus} */ this.chronos = new PlaybackChronos();
        /** A dictionary to store the events fired */ this.fireEventsStruct = {};
        this.fireEventsStruct.buffer = [];
        this.fireEventsStruct.seek = [];
        /** Reference to {@link PlayheadMonitor}. Helps the plugin detect buffers/seeks. */ this.monitor = null;
        /** Reference to {@link Plugin}. */ this.plugin = null;
        /** Reference to the player tag */ this.player = null;
        /** Defines if the adapter is used as adapter or adsAdapter */ this._isAdsAdapter = null;
        // Register player and event listeners
        this.setPlayer(player);
        /** Reference to the video/object tag, could be the same as the player. */ this.tag = this.player;
        Log.notice("Adapter " + this.getVersion() + " with Lib " + version + " is ready.");
    },
    /**
     * Sets a new player, removes the old listeners if needed.
     *
     * @param {Object} player Player to be registered.
     */ setPlayer: function(player) {
        if (this.player) this.unregisterListeners();
        if (typeof player === "string" && typeof document !== "undefined") this.player = document.getElementById(player);
        else this.player = player;
        this.registerListeners();
    },
    /**
     * Override to create event binders.
     * It's a good practice when implementing a new Adapter to create intermediate methods and call
     * those when player events are detected instead of just calling the `fire*` methods. This
     * will allow future users of the Adapter to customize its behaviour by overriding these
     * methods.
     *
     * @example
     * registerListeners: function () {
     *  this.player.addEventListener('start', this.onStart.bind(this))
     * },
     *
     * onStart: function (e) {
     *  this.emit('start')
     * }
     */ registerListeners: function() {},
    /**
     * Override to create event de-binders.
     *
     * @example
     * registerListeners: function () {
     *  this.player.removeEventListener('start', this.onStart)
     * }
     */ /** Unregister listeners to this.player. */ unregisterListeners: function() {},
    /**
     * This function disposes the currend adapter, removes player listeners and drops references.
     */ dispose: function() {
        // Stop Monitor and Network monitor
        this.stopMonitor();
        this.stopReadyStateMonitor();
        // Fire Stop
        this.fireStop();
        // Unregister listener
        this.unregisterListeners();
        this.player = null;
        this.tag = null;
    },
    /**
     * Creates a new {@link PlayheadMonitor} at this.monitor.
     *
     * @param {bool} monitorBuffers If true, it will monitor buffers.
     * @param {bool} monitorSeeks If true, it will monitor seeks.
     * @param {number} [interval=800] The interval time in ms.
     */ monitorPlayhead: function(monitorBuffers, monitorSeeks, interval) {
        this.stopMonitor();
        var type = 0;
        if (monitorBuffers) type |= PlayheadMonitor.Type.BUFFER;
        if (monitorSeeks) type |= PlayheadMonitor.Type.SEEK;
        if (!this.monitor || !this.monitor._timer.isRunning) this.monitor = new PlayheadMonitor(this, type, interval);
        else this.monitor.skipNextTick();
    },
    stopMonitor: function() {
        if (this.monitor) this.monitor.stop();
    },
    /**
     *
     * @param {number} [intervalMilliseconds=300]
     */ monitorReadyState: function(intervalMilliseconds) {
        this.stopReadyStateMonitor();
        this.stateMonitor = new StateMonitor(this, intervalMilliseconds);
    },
    /**
     * Start ReadyState monitor
     */ startReadyStateMonitor: function() {
        if (this.stateMonitor) this.stateMonitor.start();
    },
    /**
     * Stop ReadyState monitor
     */ stopReadyStateMonitor: function() {
        if (this.stateMonitor) this.stateMonitor.stop();
    },
    /**
     * Check readyState video properties
     * @param readyState
     * @param triggeredEvent
     */ checkReadyState: function(readyState, triggeredEvent) {
        try {
            if (this.plugin && this.plugin.getReadyStateMonitorEnabled()) {
                if (readyState) {
                    if (readyState > 3 && !this.flags.isSeeking) {
                        if (this.flags.isBuffering) this.fireBufferEnd({}, triggeredEvent + "-readyState");
                        else if (!this.flags.isJoined) this.fireJoin({}, triggeredEvent + "-readyState");
                    } else if (readyState < 4 && !this.flags.isBuffering) this.fireBufferBegin({}, false, triggeredEvent + "-readyState", true);
                }
            }
        } catch (e) {
            Log.error("Can't check readyState property correctly");
        }
    },
    // GETTERS //
    /** Override to return current playhead of the video */ getPlayhead: function() {
        return null;
    },
    /** Override to return video duration */ getDuration: function() {
        return null;
    },
    /** Override to return current bitrate */ getBitrate: function() {
        return null;
    },
    /** Override to return total downloaded bytes */ getTotalBytes: function() {
        return null;
    },
    /** Override to return title */ getTitle: function() {
        return null;
    },
    /** Override to return resource URL. */ getResource: function() {
        return null;
    },
    /** Override to return player version */ getPlayerVersion: function() {
        return null;
    },
    /** Override to return player's name */ getPlayerName: function() {
        return null;
    },
    /** Override to return adapter version. */ getVersion: function() {
        return version + "-generic-js";
    },
    /** Override to return video object */ getVideoObject: function() {
        return null;
    },
    // FLOW //
    /**
     * Emits related event and set flags if current status is valid.
     * ie: won't sent init if isStarted is already true.
     *
     * @param {Object} [params] Object of key:value params to add to the request.
     * @param {string} [triggeredEvent]
     */ fireInit: function(params, triggeredEvent) {
        if (this.plugin) this.plugin.fireInit(params, triggeredEvent);
    },
    /**
     * Emits related event and set flags if current status is valid.
     * ie: won't sent start if isStarted is already true.
     *
     * @param {Object} [params] Object of key:value params to add to the request.
     * @param {string} [triggeredEvent]
     */ fireStart: function(params, triggeredEvent) {
        if (this.plugin && this.plugin.backgroundDetector && this.plugin.backgroundDetector.canBlockStartCalls()) return null;
        if (!this.flags.isStarted) {
            this.flags.isStarted = true;
            this.chronos.total.start();
            this.chronos.join.start();
            if (triggeredEvent) {
                params = params || {};
                params.triggeredEvents = [
                    triggeredEvent
                ];
            }
            this.startReadyStateMonitor();
            this.emit(AdapterConstants.Event.START, {
                params: params
            });
        }
    },
    /**
     * Emits related event and set flags if current status is valid.
     * ie: won't sent start if isStarted is already true.
     *
     * @param {Object} [params] Object of key:value params to add to the request.
     * @param {string} [triggeredEvent]
     */ fireJoin: function(params, triggeredEvent) {
        if (!this.flags.isJoined && !this.flags.isStarted && !this._isAds() && this.plugin && this.plugin.isInitiated) this.fireStart({}, triggeredEvent);
        if (this.flags.isStarted && !this.flags.isJoined) {
            this.flags.isStarted = true;
            if (this.monitor) this.monitor.start();
            this.flags.isJoined = true;
            this.chronos.join.stop();
            if (triggeredEvent) {
                params = params || {};
                params.triggeredEvents = [
                    triggeredEvent
                ];
            }
            if (this._shouldSplitView()) params.viewIndex = this.plugin.viewTransform._viewIndex;
            this.emit(AdapterConstants.Event.JOIN, {
                params: params
            });
        }
    },
    /**
     * Emits related event and set flags if current status is valid.
     * ie: won't sent start if isStarted is already true.
     *
     * @param {Object} [params] Object of key:value params to add to the request.
     * @param {string} [triggeredEvent]
     */ firePause: function(params, triggeredEvent) {
        // First, discard false buffers triggered by state changed before pause
        this._discardFalseBuffers();
        if (this.flags.isBuffering) this.fireBufferEnd(null, "firePauseCall");
        if (this.flags.isJoined && !this.flags.isPaused) {
            this.flags.isPaused = true;
            this.chronos.pause.start();
            if (triggeredEvent) {
                params = params || {};
                params.triggeredEvents = [
                    triggeredEvent
                ];
            }
            if (this._shouldSplitView()) params.viewIndex = this.plugin.viewTransform._viewIndex;
            this.emit(AdapterConstants.Event.PAUSE, {
                params: params
            });
        }
    },
    /**
     * Emits related event and set flags if current status is valid.
     * ie: won't sent start if isStarted is already true.
     *
     * @param {Object} [params] Object of key:value params to add to the request.
     * @param {string} [triggeredEvent]
     */ fireResume: function(params, triggeredEvent) {
        // First, discard false buffers triggered by state changed before resume
        this._discardFalseBuffers();
        if (this.flags.isJoined && this.flags.isPaused) {
            this.flags.isPaused = false;
            this.chronos.pause.stop();
            if (this.monitor) this.monitor.skipNextTick();
            if (triggeredEvent) {
                params = params || {};
                params.triggeredEvents = [
                    triggeredEvent
                ];
            }
            if (this._shouldSplitView()) params.viewIndex = this.plugin.viewTransform._viewIndex;
            this.emit(AdapterConstants.Event.RESUME, {
                params: params
            });
        }
    },
    /**
     * Emits related event and set flags if current status is valid.
     * ie: won't sent start if isStarted is already true.
     *
     * @param {Object} [params] Object of key:value params to add to the request.
     * @param {boolean} [convertFromSeek=false] If true, will convert current seek to buffer.
     * @param {string} [triggeredEvent]
     * @param {boolean} [triggeredByStateProperty]
     */ fireBufferBegin: function(params, convertFromSeek, triggeredEvent, triggeredByStateProperty) {
        triggeredByStateProperty = triggeredByStateProperty || false;
        if (this.flags.isJoined && !this.flags.isBuffering) {
            if (this.flags.isSeeking) {
                if (convertFromSeek) {
                    Log.notice("Converting current buffer to seek");
                    this.chronos.buffer = this.chronos.seek.clone();
                    this.chronos.seek.reset();
                    this.flags.isSeeking = false;
                } else return;
            } else this.chronos.buffer.start();
            try {
                // Create new buffer empty structure to add event to detect buffer begins
                this.fireEventsStruct.buffer = [];
                if (triggeredEvent) this.fireEventsStruct.buffer.push(triggeredEvent);
                else this.fireEventsStruct.buffer.push("undefinedEvent");
            } catch (e) {}
            this.flags.isBuffering = true;
            this.flags.isVideoStateBuffering = triggeredByStateProperty;
            if (this._shouldSplitView()) params.viewIndex = this.plugin.viewTransform._viewIndex;
            this.emit(AdapterConstants.Event.BUFFER_BEGIN, {
                params: params
            });
        }
    },
    /**
     * Emits related event and set flags if current status is valid.
     * ie: won't sent start if isStarted is already true.
     *
     * @param {Object} [params] Object of key:value params to add to the request.
     * @param {string} [triggeredEvent]
     */ fireBufferEnd: function(params, triggeredEvent) {
        if (this.flags.isJoined && this.flags.isBuffering) {
            try {
                // Add triggered event to detect buffer ends
                if (triggeredEvent) this.fireEventsStruct.buffer.push(triggeredEvent);
                else this.fireEventsStruct.buffer.push("undefinedEvent");
            } catch (e) {}
            params = params || {};
            params.triggeredEvents = this.fireEventsStruct.buffer;
            if (this._shouldSplitView()) params.viewIndex = this.plugin.viewTransform._viewIndex;
            this.cancelBuffer();
            this.emit(AdapterConstants.Event.BUFFER_END, {
                params: params
            });
        }
    },
    /**
     * Discard false buffer events from state changed
     * @private
     */ _discardFalseBuffers: function() {
        try {
            if (this.flags.isBuffering && this.flags.isVideoStateBuffering && this._getDeltaBufferTime() <= 100) this.cancelBuffer();
        } catch (e) {}
    },
    /**
     *
     * @param {Object} [params] Object of key:value params to add to the request.
     */ cancelBuffer: function(params) {
        if (this.flags.isJoined && this.flags.isBuffering) {
            this.flags.isBuffering = false;
            this.flags.isVideoStateBuffering = false;
            this.chronos.buffer.stop();
            if (this.monitor) this.monitor.skipNextTick();
        }
    },
    /**
     * Get Delta buffer time
     * @returns {number|number|*}
     * @private
     */ _getDeltaBufferTime: function() {
        if (this.chronos && this.chronos.buffer) return this.chronos.buffer.getDeltaTime(false);
        return 0;
    },
    /**
     * Emits related event and set flags if current status is valid.
     * ie: won't sent start if isStarted is already true.
     *
     * @param {Object} [params] Object of key:value params to add to the request.
     * @param {string} [triggeredEvent]
     */ fireStop: function(params, triggeredEvent) {
        if (this._isAds() || this.plugin && this.plugin._isStopReady()) {
            if (this._isAds() && this.flags.isStarted || !this._isAds() && (this.flags.isStarted || this.plugin && this.plugin.isInitiated)) {
                // Stop Monitor and Network monitor
                this.stopMonitor();
                this.stopReadyStateMonitor();
                this.flags.reset();
                this.chronos.total.stop();
                this.chronos.join.reset();
                this.chronos.pause.stop();
                this.chronos.buffer.stop();
                this.chronos.seek.stop();
                if (triggeredEvent) {
                    params = params || {};
                    params.triggeredEvents = [
                        triggeredEvent
                    ];
                }
                if (this._shouldSplitView()) params.viewIndex = this.plugin.viewTransform._viewIndex;
                this.emit(AdapterConstants.Event.STOP, {
                    params: params
                });
                this.chronos.pause.reset();
                this.chronos.buffer.reset();
                this.chronos.seek.reset();
                this.chronos.viewedMax.splice(0, this.chronos.viewedMax.length);
            }
        }
    },
    setIsAds: function(value) {
        this._isAdsAdapter = value;
    },
    _isAds: function() {
        return this._isAdsAdapter;
    },
    /**
     * @param {Object} [params] Object of key:value params to add to the request.
     * @param {string} [triggeredEvent]
     */ fireCasted: function(params, triggeredEvent) {
        if (!params) params = {};
        params.casted = true;
        this.fireStop(params, triggeredEvent);
    },
    /**
     * Emits related event and set flags if current status is valid.
     * ie: won't sent start if isStarted is already true.
     *
     * @param {String|Object} [code] Error Code, if an object is sent, it will be treated as params.
     * @param {String} [msg] Error Message
     * @param {Object} [metadata] Object defining error metadata
     * @param {String} [level] Level of the error. Currently supports 'error' and 'fatal'
     * @param {string} [triggeredEvent]
     */ fireError: function(code, msg, metadata, level, triggeredEvent) {
        var params = Util.buildErrorParams(code, msg, metadata, level);
        if (params.code) delete params.code;
        if (triggeredEvent) {
            params = params || {};
            params.triggeredEvents = [
                triggeredEvent
            ];
        }
        if (this._shouldSplitView()) params.viewIndex = this.plugin.viewTransform._viewIndex;
        var options = this.plugin ? this.plugin.options : {};
        if (typeof params.errorCode !== "undefined" && options["errors.ignore"] && options["errors.ignore"].indexOf(params.errorCode.toString()) > -1) ;
        else {
            this.emit(AdapterConstants.Event.ERROR, {
                params: params
            });
            if (typeof params.errorCode !== "undefined" && options["errors.fatal"] && options["errors.fatal"].indexOf(params.errorCode.toString()) > -1) this.fireStop({}, triggeredEvent);
        }
    },
    /**
     * Emits related event and set flags if current status is valid.
     * ie: won't sent start if isStarted is already true.
     *
     * @param {String|Object} [code] Error Code, if an object is sent, it will be treated as params.
     * @param {String} [msg] Error Message
     * @param {Object} [metadata] Object defining error metadata
     * @param {String} [level] Level of the error. Currently supports 'error' and 'fatal'
     * @param {string} [triggeredEvent]
     */ fireFatalError: function(code, msg, metadata, level, triggeredEvent) {
        var options = this.plugin ? this.plugin.options : {};
        if (typeof code !== "undefined" && options["errors.ignore"] && options["errors.ignore"].indexOf(code.toString()) > -1) ;
        else {
            if (this.monitor) this.monitor.stop();
            this.fireError(code, msg, metadata, level, triggeredEvent);
            if (typeof code !== "undefined" && options["errors.nonFatal"] && options["errors.nonFatal"].indexOf(code.toString()) > -1) ;
            else this.fireStop({}, triggeredEvent);
        }
    },
    _shouldSplitView: function() {
        return this.plugin && this.plugin.options && this.plugin.options["session.splitViews"];
    }
}, {
    /** @lends youbora.Adapter */ // Static Memebers //
    /**
     * List of events that could be fired
     * @enum
     * @event
     */ Event: AdapterConstants.Event
});
Util.assign(Adapter.prototype, require("baad6b1ad1d9e961"));
Util.assign(Adapter.prototype, require("1f6da8de5c3cb860"));
module.exports = Adapter;

},{"7fa9f3ce378d6568":"cuYJd","110ebcdc0c317266":"8xsxZ","a84074a55c00995d":"drhpF","f63f77ba4db7b17d":"bsoIP","82b9a6e6ef21d1b7":"4Zg5t","ab0e66480cf0ee7c":"aWm90","a3497aac3c97aa66":"6a8xK","3763f4144bdf4531":"lvwT1","b626be3588d4f1ec":"4lEQs","baad6b1ad1d9e961":"aTukS","1f6da8de5c3cb860":"2sUe3"}],"4Zg5t":[function(require,module,exports) {
var YouboraObject = require("a32bb16b2b63a2cb");
var Chrono = require("1f162409d00c82e8");
var PlaybackChronos = YouboraObject.extend(/** @lends youbora.PlaybackChronos.prototype */ {
    /**
     * This class contains all the {@link Chrono}s related to view status.
     * Chronos measure time lapses between events.
     * ie: between start and join, between seek-begin and seek-end, etc.
     * Each plugin will have an instance of this class.
     *
     * @constructs PlaybackChronos
     * @extends youbora.YouboraObject
     * @memberof youbora
     */ constructor: function() {
        this.reset();
    },
    /** Reset flag values */ reset: function() {
        /** Chrono between start and joinTime. */ this.join = new Chrono();
        /** Chrono between seek-begin and seek-end. */ this.seek = new Chrono();
        /** Chrono between pause and resume. */ this.pause = new Chrono();
        /** Chrono between buffer-begin and buffer-end. */ this.buffer = new Chrono();
        /** Chrono for the totality of the view. */ this.total = new Chrono();
        // For ads
        /** List of chronos with seen intervals */ this.viewedMax = [];
    }
});
module.exports = PlaybackChronos;

},{"a32bb16b2b63a2cb":"j7KrE","1f162409d00c82e8":"6HP4E"}],"aWm90":[function(require,module,exports) {
var YouboraObject = require("150861ccd32cf05d");
var PlaybackFlags = YouboraObject.extend(/** @lends youbora.PlaybackFlags.prototype */ {
    /**
     * This class contains all the flags related to view status.
     * Each plugin will have an instance of this class.
     *
     * @constructs PlaybackFlags
     * @extends youbora.YouboraObject
     * @memberof youbora
     */ constructor: function() {
        this.reset();
    },
    /** Reset flag values */ reset: function() {
        /** Flag when Start has been sent. */ this.isStarted = false;
        /** Flag when Join has been sent. */ this.isJoined = false;
        /** Flag when Player is paused. */ this.isPaused = false;
        /** Flag when Player is seeking. */ this.isSeeking = false;
        /** Flag when Player is buffering. */ this.isBuffering = false;
        /** Flag when Player is buffering by video state. */ this.isVideoStateBuffering = false;
        /** Flag when Player is ended. */ this.isEnded = false;
        /** Flag when Player view ends and stop is already sent. */ this.isStopped = false;
        /** Flag with last quartile sent. */ this.lastQuartileSent = 0;
    }
});
module.exports = PlaybackFlags;

},{"150861ccd32cf05d":"j7KrE"}],"6a8xK":[function(require,module,exports) {
var YouboraObject = require("f8e1caa48f4d9aa2");
var Timer = require("8ecd0144f1be06eb");
var Chrono = require("35c7ae470e9b2628");
var PlayheadMonitor = YouboraObject.extend(/** @lends youbora.PlayheadMonitor.prototype */ {
    /**
     * This class periodically checks the player's playhead in order to infer buffer and/or seek
     * events.
     *
     * Instances of this class are bounded to an {@link Adapter} and fires its buffer and seek
     * start and end methods.
     *
     * In order to use this feature, {@link Adapter#monitorPlayhead} should be used.
     *
     * @constructs PlayheadMonitor
     * @extends youbora.YouboraObject
     * @memberof youbora
     *
     * @param {Adapter} adapter Adapter to monitor. Must have getPlayhead defined.
     * @param {PlayheadMonitor.Type} [type=NONE]
     * Which metric to monitor seek and/or buffer.
     * Use bitwise operators to join both values (Type.BUFFER | Type.SEEK)
     * @param {int} [interval=800] How many ms will wait between progress. -1 to disable.
     */ constructor: function(adapter, type, interval) {
        this._adapter = adapter;
        this._seekEnabled = type & PlayheadMonitor.Type.SEEK;
        this._bufferEnabled = type & PlayheadMonitor.Type.BUFFER;
        interval = interval || 800;
        this._chrono = new Chrono();
        this._lastPlayhead = 0;
        if (interval > 0) this._timer = new Timer(this.progress.bind(this), interval);
    },
    /**
     * Start interval checks.
     */ start: function() {
        this.stop();
        if (this.canBeUsed()) this._timer.start();
    },
    /**
     * Stop interval checks.
     */ stop: function() {
        this._lastPlayhead = 0;
        if (this._timer) this._timer.stop();
    },
    skipNextTick: function() {
        this._lastPlayhead = 0;
    },
    /**
     * Call this method at every tick of timeupdate/progress.
     * If you defined an interval, do not fire this method manually.
     */ progress: function() {
        // Reset timer
        var deltaTime = this._chrono.stop();
        this._chrono.start();
        // Define thresholds
        var bufferThreshold = deltaTime * PlayheadMonitor.kBUFFER_THRESHOLD_RATIO;
        var seekThreshold = deltaTime * PlayheadMonitor.kSEEK_THRESHOLD_RATIO;
        if (this._adapter.getPlayrate && this._adapter.getPlayrate() && this._adapter.getPlayrate() !== 1) {
            bufferThreshold *= this._adapter.getPlayrate();
            seekThreshold *= this._adapter.getPlayrate();
        }
        // Calculate diff playhead
        var currentPlayhead = this._getPlayhead();
        var diffPlayhead = Math.abs(this._lastPlayhead - currentPlayhead) * 1000;
        // youbora.Log.debug('curr: ' + currentPlayhead + ' last: ' + this._lastPlayhead + ' diff: ' + diffPlayhead)
        if (diffPlayhead < bufferThreshold) // Playhead is stalling > buffer
        {
            if (this._bufferEnabled && this._lastPlayhead > 0 && !this._adapter.flags.isPaused && !this._adapter.flags.isSeeking) this._adapter.fireBufferBegin(null, false, "playheadMonitor");
        } else if (diffPlayhead > seekThreshold) // Playhead has jumped > seek
        {
            if (this._seekEnabled && this._lastPlayhead > 0) this._adapter.fireSeekBegin(null, false, "playheadMonitor");
        } else {
            // Healthy
            if (this._seekEnabled) this._adapter.fireSeekEnd(null, "playheadMonitor");
            if (this._bufferEnabled) this._adapter.fireBufferEnd(null, "playheadMonitor");
        }
        // Update Playhead
        this._lastPlayhead = currentPlayhead;
    },
    /**
     * Returns if the monitor can be used or not.
     * Enabled by default, except the case where the content is live and the option 'content.isLive.noMonitor' is true.
     * @public
     * @returns {boolean} If the monitor can be used or not.
     */ canBeUsed: function() {
        var plugin = this._adapter.plugin;
        if (plugin && plugin.getPlayheadMonitorEnabled() && (this._seekEnabled || this._bufferEnabled)) return plugin.getIsLive() ? !plugin.options["content.isLive.noMonitor"] : true;
        else return false;
    },
    /**
     * Returns adapter's playhead. Override to add a custom playhead getter.
     * @private
     * @returns {double} Playhead in seconds
     */ _getPlayhead: function() {
        return this._adapter.getPlayhead();
    }
}, /** @lends youbora.PlayheadMonitor */ {
    // Static methods
    /**
     * Enum for monitoring type
     * @enum
     */ Type: {
        /** Would not monitor */ NONE: 0,
        /** Sends buffer-begin/end */ BUFFER: 1,
        /** Sends seek-begin/end */ SEEK: 2
    },
    /** Buffer threshold */ kBUFFER_THRESHOLD_RATIO: 0.5,
    /** Seek threshold */ kSEEK_THRESHOLD_RATIO: 2
});
module.exports = PlayheadMonitor;

},{"f8e1caa48f4d9aa2":"j7KrE","8ecd0144f1be06eb":"cqNVd","35c7ae470e9b2628":"6HP4E"}],"lvwT1":[function(require,module,exports) {
var YouboraObject = require("58f69137d5bfb9d2");
var Log = require("b0bad582a08da3dd");
var StateMonitor = YouboraObject.extend(/** @lends youbora.NetworkMonitor.prototype */ {
    /**
     * @constructs StateMonitor
     * @extends youbora.YouboraObject
     * @memberof youbora
     *
     * @param {Adapter} adapter Adapter to monitor. Must have getVideoObject defined.
     * @param {int} [intervalMilliseconds=300] How many ms will wait between progress. -1 to disable.
     */ constructor: function(adapter, intervalMilliseconds) {
        this._adapter = adapter;
        this._videoElement = adapter.getVideoObject();
        this._startedStateCheck = false;
        this._intervalCheckId = null;
        this._intervalMilliseconds = intervalMilliseconds || 300;
    },
    /**
     * Start Network monitor
     */ start: function() {
        var plugin = this._adapter.plugin;
        if (plugin && plugin.getReadyStateMonitorEnabled()) {
            if (this._videoElement && !this._startedStateCheck) {
                this._intervalCheckId = setInterval(this.checkStateProperty.bind(this), this._intervalMilliseconds);
                this._startedStateCheck = true;
            }
        }
    },
    /**
     * Stop Network monitor
     */ stop: function() {
        try {
            if (this._startedStateCheck && this._intervalCheckId) clearInterval(this._intervalCheckId);
            this._intervalCheckId = null;
            this._startedStateCheck = false;
        } catch (e) {
            Log.error("Produced error stopping the network monitor");
        }
    },
    /**
     * Check ReadyState properties values
     * @param e
     */ checkStateProperty: function(e) {
        try {
            if (this._videoElement && this._adapter) {
                if (this._videoElement.readyState) {
                    if (this._videoElement.readyState > 3 && !this._adapter.flags.isSeeking) {
                        if (this._adapter.flags.isBuffering) this.fireBufferEnd({}, "stateMonitor");
                        else if (!this._adapter.flags.isJoined) this.fireJoin({}, "stateMonitor");
                    } else if (this._videoElement.readyState < 4 && !this._adapter.flags.isBuffering) this.fireBufferBegin({}, false, "stateMonitor", true);
                }
            }
        } catch (e) {}
    }
});
module.exports = StateMonitor;

},{"58f69137d5bfb9d2":"j7KrE","b0bad582a08da3dd":"8xsxZ"}],"aTukS":[function(require,module,exports) {
var AdapterConstants = require("7cc430fde11de72b");
var Chrono = require("97d0b4969d5e4a15");
var AdapterAdsMixin = {
    /** Override to return current ad position */ getPosition: function() {
        return null;
    },
    /** Override to return the given ad structure (list with number of pre, mid, and post breaks) */ getGivenBreaks: function() {
        return null;
    },
    /** Override to return the ad structure requested (list with number of pre, mid, and post breaks) */ getExpectedBreaks: function() {
        return null;
    },
    /** Override to return the structure of ads requested */ getExpectedPattern: function() {
        return null;
    },
    /** Override to return a list of playheads of ad breaks begin time */ getBreaksTime: function() {
        return null;
    },
    /** Override to return the number of ads given for the break */ getGivenAds: function() {
        return null;
    },
    /** Override to return the number of ads requested for the break */ getExpectedAds: function() {
        return null;
    },
    /** Override to return if the ad is being shown in the screen or not
   * The standard definition is: more than 50% of the pixels of the ad are on the screen
   */ getIsVisible: function() {
        return true;
    },
    /** Override to return a boolean showing if the audio is enabled when the ad begins */ getAudioEnabled: function() {
        return null;
    },
    /** Override to return if the ad is skippable */ getIsSkippable: function() {
        return null;
    },
    /** Override to return a boolean showing if the player is in fullscreen mode when the ad begins */ getIsFullscreen: function() {
        return null;
    },
    /** Override to return the ad campaign */ getCampaign: function() {
        return null;
    },
    /** Override to return the ad creative id */ getCreativeId: function() {
        return null;
    },
    /** Override to return the ad provider name */ getProvider: function() {
        return null;
    },
    /** Override to return the ad insertion type
   * Use constants:
   * youbora.Constants.AdInsertionType.ClientSide
   * youbora.Constants.AdInsertionType.ServerSide
  */ getAdInsertionType: function() {
        return null;
    },
    /**
 * Emits related event and set flags if current status is valid.
 * ie: won't sent start if isStarted is already true.
 *
 * @param {Object} [params] Object of key:value params to add to the request.
 */ fireClick: function(params) {
        if (typeof params === "string") params = {
            url: params
        };
        this.emit(AdapterConstants.Event.CLICK, {
            params: params
        });
    },
    /**
   * Emits related event and set flags if current status is valid.
   * ie: won't sent start if isStarted is already true.
   *
   * @param {Object} [params] Object of key:value params to add to the request.
   */ fireQuartile: function(quartile) {
        if (this.flags.isStarted && typeof quartile === "number" && quartile > this.flags.lastQuartileSent && quartile < 4) {
            this.flags.lastQuartileSent++;
            this.emit(AdapterConstants.Event.QUARTILE, {
                params: {
                    quartile: quartile
                }
            });
        }
    },
    /**
  * Starts a new chrono for viewedMax and restarts viewedAcum
  */ startChronoView: function() {
        if (this.getIsVisible() && !this.plugin.backgroundDetector.isInBackground) {
            var max = this.chronos.viewedMax;
            if (max.length === 0 || max[max.length - 1].stopTime !== 0) {
                max.push(new Chrono());
                max[max.length - 1].start();
            }
        }
    },
    /**
  * Stops a new chrono for viewedMax and restarts viewedAcum
  */ stopChronoView: function() {
        var max = this.chronos.viewedMax;
        if (max[0] && max.length > 0 && max[max.length - 1].stopTime === 0) max[max.length - 1].stop();
    },
    /**
  * @param {Object} [params] Object of key:value params to add to the request.
  */ fireManifest: function(params, message) {
        var paramsObject = {
            params: params
        };
        if (typeof params === "string") paramsObject = {
            params: {
                errorType: params,
                errorMessage: message
            }
        };
        this.emit(AdapterConstants.Event.MANIFEST, paramsObject);
    },
    /*
  * Emits related event and set flags if current status is valid.
  * ie: won't sent start if isStarted is already true.
  *
  * @param {Object} [params] Object of key:value params to add to the request.
  */ fireSkip: function(params) {
        if (params === undefined) params = {};
        params.skipped = true;
        this.fireStop(params);
    },
    /**
  * Emits related event and set flags if current status is valid.
  * ie: won't sent start if isStarted is already true.
  *
  * @param {Object} [params] Object of key:value params to add to the request.
  */ fireBreakStart: function(params) {
        this.emit(AdapterConstants.Event.PODSTART, {
            params: params
        });
    },
    /**
  * Emits related event and set flags if current status is valid.
  * ie: won't sent start if isStarted is already true.
  *
  * @param {Object} [params] Object of key:value params to add to the request.
  */ fireBreakStop: function(params) {
        this.emit(AdapterConstants.Event.PODSTOP, {
            params: params
        });
    }
};
module.exports = AdapterAdsMixin;

},{"7cc430fde11de72b":"4lEQs","97d0b4969d5e4a15":"6HP4E"}],"2sUe3":[function(require,module,exports) {
var AdapterConstants = require("166847c4390cdb9a");
var Log = require("6b387ae0ee37b81e");
var AdapterContentMixin = {
    /** Override to return current playrate */ getPlayrate: function() {
        return !this.flags.isPaused ? 1 : 0;
    },
    /** Override to return Frames Per Secon (FPS) */ getFramesPerSecond: function() {
        return null;
    },
    /** Override to return dropped frames since start */ getDroppedFrames: function() {
        return null;
    },
    /** Override to return user bandwidth throughput */ getThroughput: function() {
        return null;
    },
    /** Override to return rendition */ getRendition: function() {
        return null;
    },
    /** Override to return title2 */ getTitle2: function() {
        return null;
    },
    /** Override to recurn true if live and false if VOD */ getIsLive: function() {
        return null;
    },
    /** Override to return CDN traffic bytes not using streamroot or peer5. */ getCdnTraffic: function() {
        return null;
    },
    /** Override to return P2P traffic bytes not using streamroot or peer5. */ getP2PTraffic: function() {
        return null;
    },
    /** Override to return P2P traffic sent in bytes, not using streamroot or peer5. */ getUploadTraffic: function() {
        return null;
    },
    /** Override to return if P2P is enabled not using streamroot or peer5. */ getIsP2PEnabled: function() {
        return null;
    },
    /** Override to return video segment duration. */ getSegmentDuration: function() {
        return null;
    },
    /** Override to return household id */ getHouseholdId: function() {
        return null;
    },
    /** Override to return the latency */ getLatency: function() {
        return null;
    },
    /** Override to return the number of packets lost */ getPacketLoss: function() {
        return null;
    },
    /** Override to return the number of packets sent */ getPacketSent: function() {
        return null;
    },
    /** Override to return a json with metrics */ getMetrics: function() {
        return null;
    },
    /** Override to return the audio codec */ getAudioCodec: function() {
        return null;
    },
    /** Override to return the video codec */ getVideoCodec: function() {
        return null;
    },
    /** Override to return a chunk or intermediate manifest url */ getURLToParse: function() {
        return null;
    },
    /**
 * Emits related event and set flags if current status is valid.
 * ie: won't sent start if isStarted is already true.
 *
 * @param {Object} [params] Object of key:value params to add to the request.
 * @param {bool} [convertFromBuffer=true] If false, will convert current buffer to seek.
 * @param {string} [triggeredEvent]
 */ fireSeekBegin: function(params, convertFromBuffer, triggeredEvent) {
        // First, discard false buffers triggered by state changed before seek
        this._discardFalseBuffers();
        if (this.plugin && this.plugin.getIsLive() && this.plugin.options["content.isLive.noSeek"]) return null;
        if (this.flags.isJoined && !this.flags.isSeeking) {
            if (this.flags.isBuffering) {
                if (convertFromBuffer !== false) {
                    Log.notice("Converting current buffer to seek");
                    this.chronos.seek = this.chronos.buffer.clone();
                    this.chronos.buffer.reset();
                    this.flags.isBuffering = false;
                } else return;
            } else this.chronos.seek.start();
            try {
                // Create new seek empty structure to add event to detect seek begins
                this.fireEventsStruct.seek = [];
                if (triggeredEvent) this.fireEventsStruct.seek.push(triggeredEvent);
                else this.fireEventsStruct.seek.push("undefinedEvent");
            } catch (e) {}
            this.flags.isSeeking = true;
            this.emit(AdapterConstants.Event.SEEK_BEGIN, {
                params: params
            });
        }
    },
    /**
   * Emits related event and set flags if current status is valid.
   * ie: won't sent start if isStarted is already true.
   *
   * @param {Object} [params] Object of key:value params to add to the request.
   * @param {string} [triggeredEvent]
   */ fireSeekEnd: function(params, triggeredEvent) {
        if (this.plugin && this.plugin.getIsLive() && this.plugin.options["content.isLive.noSeek"]) return null;
        if (this.flags.isJoined && this.flags.isSeeking) {
            try {
                // Add triggered event to detect buffer ends
                if (triggeredEvent) this.fireEventsStruct.seek.push(triggeredEvent);
                else this.fireEventsStruct.seek.push("undefinedEvent");
            } catch (e) {}
            params = params || {};
            params.triggeredEvents = this.fireEventsStruct.seek;
            if (this._shouldSplitView()) params.viewIndex = this.plugin.viewTransform._viewIndex;
            this.cancelSeek();
            this.emit(AdapterConstants.Event.SEEK_END, {
                params: params
            });
        }
    },
    /**
   *
   * @param {Object} [params] Object of key:value params to add to the request.
   */ cancelSeek: function(params) {
        if (this.flags.isJoined && this.flags.isSeeking) {
            this.flags.isSeeking = false;
            this.chronos.seek.stop();
            if (this.monitor) this.monitor.skipNextTick();
        }
    },
    /**
 * Emits event request.
 *
 * @param {Object} [params] Object of key:value params to add to the request.
 */ fireEvent: function(eventName, dimensions, values, topLevelDimensions) {
        var returnparams = topLevelDimensions || {};
        returnparams.name = eventName || "";
        returnparams.dimensions = dimensions || {};
        returnparams.values = values || {};
        this.emit(AdapterConstants.Event.VIDEO_EVENT, {
            params: returnparams
        });
    }
};
module.exports = AdapterContentMixin;

},{"166847c4390cdb9a":"4lEQs","6b387ae0ee37b81e":"8xsxZ"}],"isPjX":[function(require,module,exports) {
var Util = require("849aaa2c4cf3bfe6");
var version = require("7697a4b3bbb82568");
var RequestMethod = require("26583093c89ffe1");
// This file is designed to add extra functionalities to Plugin class
var PluginGetterMixin = {
    /**
     * Returns service host
     *
     * @memberof youbora.Plugin.prototype
     */ getHost: function() {
        var host = this.options.host;
        if (this.viewTransform && this.viewTransform.response && this.viewTransform.response.host) host = this.viewTransform.response.host;
        return Util.addProtocol(Util.stripProtocol(host), this.options["app.https"]);
    },
    getUserType: function() {
        return this.options["user.type"];
    },
    /**
     * Returns parse Manifest Flag
     *
     * @memberof youbora.Plugin.prototype
     */ isParseManifest: function() {
        return this.options["parse.manifest"];
    },
    /**
     * Returns parse CdnNode Flag
     *
     * @memberof youbora.Plugin.prototype
     */ isParseCdnNode: function() {
        return this.options["parse.cdnNode"];
    },
    /**
     * Returns parse cdn switch Flag
     *
     * @memberof youbora.Plugin.prototype
     */ isCdnSwitch: function() {
        return this.options["parse.cdnSwitchHeader"];
    },
    /**
     * Returns Cdn list
     *
     * @memberof youbora.Plugin.prototype
     */ getParseCdnNodeList: function() {
        return this.options["parse.cdnNode.list"];
    },
    /**
     * Returns Cdn header name
     *
     * @memberof youbora.Plugin.prototype
     */ getParseCdnNodeNameHeader: function() {
        return this.options["parse.cdnNameHeader"];
    },
    /**
   * Returns header node name
   *
   * @memberof youbora.Plugin.prototype
   */ getParseNodeHeader: function() {
        return this.options["parse.cdnNodeHeader"];
    },
    /**
     * Returns obfuscateIp option
     *
     * @memberof youbora.Plugin.prototype
     */ getObfuscateIp: function() {
        return this.options["user.obfuscateIp"];
    },
    /**
   * Returns privacy protocol option
   *
   * @memberof youbora.Plugin.prototype
   */ getPrivacyProtocol: function() {
        var ret = this.options["user.privacyProtocol"];
        if (typeof ret === "string") ret = ret.toLowerCase();
        return ret === "optin" || ret === "optout" ? ret : null;
    },
    /**
   * Returns content's custom dimensions
   *
   * @memberof youbora.Plugin.prototype
   */ getCustomDimensions: function() {
        var dim = this.options["content.customDimensions"];
        return typeof dim === "object" ? dim : null;
    },
    /**
     * Returns content's Extraparam1
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam1: function() {
        return this.options["content.customDimension.1"];
    },
    /**
     * Returns content's Extraparam2
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam2: function() {
        return this.options["content.customDimension.2"];
    },
    /**
     * Returns content's Extraparam3
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam3: function() {
        return this.options["content.customDimension.3"];
    },
    /**
     * Returns content's Extraparam4
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam4: function() {
        return this.options["content.customDimension.4"];
    },
    /**
     * Returns content's Extraparam5
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam5: function() {
        return this.options["content.customDimension.5"];
    },
    /**
     * Returns content's Extraparam6
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam6: function() {
        return this.options["content.customDimension.6"];
    },
    /**
     * Returns content's Extraparam7
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam7: function() {
        return this.options["content.customDimension.7"];
    },
    /**
     * Returns content's Extraparam8
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam8: function() {
        return this.options["content.customDimension.8"];
    },
    /**
     * Returns content's Extraparam9
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam9: function() {
        return this.options["content.customDimension.9"];
    },
    /**
     * Returns content's Extraparam10
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam10: function() {
        return this.options["content.customDimension.10"];
    },
    /**
     * Returns content's Extraparam11
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam11: function() {
        return this.options["content.customDimension.11"];
    },
    /**
     * Returns content's Extraparam12
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam12: function() {
        return this.options["content.customDimension.12"];
    },
    /**
     * Returns content's Extraparam13
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam13: function() {
        return this.options["content.customDimension.13"];
    },
    /**
     * Returns content's Extraparam14
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam14: function() {
        return this.options["content.customDimension.14"];
    },
    /**
     * Returns content's Extraparam15
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam15: function() {
        return this.options["content.customDimension.15"];
    },
    /**
     * Returns content's Extraparam16
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam16: function() {
        return this.options["content.customDimension.16"];
    },
    /**
     * Returns content's Extraparam17
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam17: function() {
        return this.options["content.customDimension.17"];
    },
    /**
     * Returns content's Extraparam18
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam18: function() {
        return this.options["content.customDimension.18"];
    },
    /**
     * Returns content's Extraparam19
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam19: function() {
        return this.options["content.customDimension.19"];
    },
    /**
     * Returns content's Extraparam20
     *
     * @memberof youbora.Plugin.prototype
     */ getExtraparam20: function() {
        return this.options["content.customDimension.20"];
    },
    /**
     * Returns ad's Extraparam1
     *
     * @memberof youbora.Plugin.prototype
     */ getAdExtraparam1: function() {
        return this.options["ad.customDimension.1"];
    },
    /**
     * Returns ad's Extraparam2
     *
     * @memberof youbora.Plugin.prototype
     */ getAdExtraparam2: function() {
        return this.options["ad.customDimension.2"];
    },
    /**
     * Returns ad's Extraparam3
     *
     * @memberof youbora.Plugin.prototype
     */ getAdExtraparam3: function() {
        return this.options["ad.customDimension.3"];
    },
    /**
     * Returns ad's Extraparam4
     *
     * @memberof youbora.Plugin.prototype
     */ getAdExtraparam4: function() {
        return this.options["ad.customDimension.4"];
    },
    /**
     * Returns ad's Extraparam5
     *
     * @memberof youbora.Plugin.prototype
     */ getAdExtraparam5: function() {
        return this.options["ad.customDimension.5"];
    },
    /**
     * Returns ad's Extraparam6
     *
     * @memberof youbora.Plugin.prototype
     */ getAdExtraparam6: function() {
        return this.options["ad.customDimension.6"];
    },
    /**
     * Returns ad's Extraparam7
     *
     * @memberof youbora.Plugin.prototype
     */ getAdExtraparam7: function() {
        return this.options["ad.customDimension.7"];
    },
    /**
     * Returns ad's Extraparam8
     *
     * @memberof youbora.Plugin.prototype
     */ getAdExtraparam8: function() {
        return this.options["ad.customDimension.8"];
    },
    /**
     * Returns ad's Extraparam9
     *
     * @memberof youbora.Plugin.prototype
     */ getAdExtraparam9: function() {
        return this.options["ad.customDimension.9"];
    },
    /**
     * Returns ad's Extraparam10
     *
     * @memberof youbora.Plugin.prototype
     */ getAdExtraparam10: function() {
        return this.options["ad.customDimension.10"];
    },
    /**
     * Returns PluginInfo
     *
     * @memberof youbora.Plugin.prototype
     */ getPluginInfo: function() {
        var ret = {
            lib: version,
            adapter: this.getAdapterVersion(),
            adAdapter: this.getAdAdapterVersion()
        };
        return ret;
    },
    /**
     * Returns Ip
     *
     * @memberof youbora.Plugin.prototype
     */ getIp: function() {
        return this.options["network.ip"];
    },
    /**
     * Returns Isp
     *
     * @memberof youbora.Plugin.prototype
     */ getIsp: function() {
        return this.options["network.isp"];
    },
    /**
     * Returns ConnectionType
     *
     * @memberof youbora.Plugin.prototype
     */ getConnectionType: function() {
        return this.options["network.connectionType"];
    },
    /** Returns deviceInfo json
     *
     * @memberof youbora.Plugin.prototype
     */ getDeviceInfo: function() {
        var info = {};
        if (this.getDeviceCode()) info.deviceCode = this.getDeviceCode();
        if (this.getModel()) info.model = this.getModel();
        if (this.getBrand()) info.brand = this.getBrand();
        if (this.getDeviceType()) info.deviceType = this.getDeviceType();
        if (this.getDeviceName()) info.deviceName = this.getDeviceName();
        if (this.getOsName()) info.osName = this.getOsName();
        if (this.getOsVersion()) info.osVersion = this.getOsVersion();
        if (this.getBrowserName()) info.browserName = this.getBrowserName();
        if (this.getBrowserVersion()) info.browserVersion = this.getBrowserVersion();
        if (this.getBrowserType()) info.browserType = this.getBrowserType();
        if (this.getBrowserEngine()) info.browserEngine = this.getBrowserEngine();
        return info !== {} ? info : null;
    },
    /** Returns EDID object
   *
   * @memberof youbora.Plugin.prototype
   */ getEDID: function() {
        var edid = this.options["device.EDID"];
        return edid ? edid.toString() : null;
    },
    /**
     * Returns DeviceCode
     *
     * @memberof youbora.Plugin.prototype
     */ getDeviceCode: function() {
        return this.options["device.code"];
    },
    /**
     * Returns Device model
     *
     * @memberof youbora.Plugin.prototype
     */ getModel: function() {
        return this.options["device.model"];
    },
    /**
     * Returns Device brand
     *
     * @memberof youbora.Plugin.prototype
     */ getBrand: function() {
        return this.options["device.brand"];
    },
    /**
     * Returns Device type
     *
     * @memberof youbora.Plugin.prototype
     */ getDeviceType: function() {
        return this.options["device.type"];
    },
    /**
     * Returns Device name
     *
     * @memberof youbora.Plugin.prototype
     */ getDeviceName: function() {
        return this.options["device.name"];
    },
    /**
     * Returns Device OS name
     *
     * @memberof youbora.Plugin.prototype
     */ getOsName: function() {
        return this.options["device.osName"];
    },
    /**
     * Returns Device OS Version
     *
     * @memberof youbora.Plugin.prototype
     */ getOsVersion: function() {
        return this.options["device.osVersion"];
    },
    /**
     * Returns Device browser name
     *
     * @memberof youbora.Plugin.prototype
     */ getBrowserName: function() {
        return this.options["device.browserName"];
    },
    /**
     * Returns Device browser version
     *
     * @memberof youbora.Plugin.prototype
     */ getBrowserVersion: function() {
        return this.options["device.browserVersion"];
    },
    /**
     * Returns Device browser type
     *
     * @memberof youbora.Plugin.prototype
     */ getBrowserType: function() {
        return this.options["device.browserType"];
    },
    /**
     * Returns DeviceCode
     *
     * @memberof youbora.Plugin.prototype
     */ getBrowserEngine: function() {
        return this.options["device.browserEngine"];
    },
    /**
     * Returns AccountCode
     *
     * @memberof youbora.Plugin.prototype
     */ getAccountCode: function() {
        return this.options.accountCode;
    },
    /**
     * Returns Username
     *
     * @memberof youbora.Plugin.prototype
     */ getUsername: function() {
        return this.options["user.name"];
    },
    /**
     * Returns AnonymousUser
     *
     * @memberof youbora.Plugin.prototype
     */ getAnonymousUser: function() {
        return this.options["user.anonymousId"];
    },
    /**
     * Returns user email
     *
     * @memberof youbora.Plugin.prototype
     */ getEmail: function() {
        return this.options["user.email"];
    },
    /**
     * Get URL referer.
     *
     * @memberof youbora.Plugin.prototype
     */ getReferer: function() {
        var ret = this.options.referer || "";
        if (!ret && typeof window !== "undefined" && window.location) ret = window.location.href;
        return ret;
    },
    /**
     * Get URL referral.
     * Previous page url.
     * @memberof youbora.Plugin.prototype
     */ getReferral: function() {
        var ret = this.options.referral || "";
        if (!ret && typeof document !== "undefined") ret = document.referrer;
        return ret;
    },
    /**
     * Get Browser language
     *
     * @memberof youbora.Plugin.prototype
     */ getLanguage: function() {
        var ret = null;
        if (typeof navigator !== "undefined") ret = navigator.language;
        return ret;
    },
    /**
   * Get Screen resolution
   *
   * @memberof npaw.Plugin.prototype
   */ getScreenResolution: function() {
        var ret = null;
        try {
            if (window && window.screen) {
                var devicePixelRatio = window.devicePixelRatio || 1;
                ret = window.screen.width * devicePixelRatio + "x" + window.screen.height * devicePixelRatio;
            }
        } catch (e) {}
        return ret;
    },
    /**
     * Returns the nodehost
     *
     * @memberof youbora.Plugin.prototype
     */ getNodeHost: function() {
        return this.options["content.cdnNode"] || this.resourceTransform.getNodeHost();
    },
    /**
     * Returns the node type id
     *
     * @memberof youbora.Plugin.prototype
     */ getNodeType: function() {
        return this.options["content.cdnType"] || this.resourceTransform.getNodeType();
    },
    /**
     * Returns the node type string
     *
     * @memberof youbora.Plugin.prototype
     */ getNodeTypeString: function() {
        return this.resourceTransform.getNodeTypeString();
    },
    /**
     * Returns requestNumber value, to prevent /data calls being cached
     *
     * @memberof youbora.Plugin.prototype
     */ getRequestNumber: function() {
        return Math.random();
    },
    /**
     * Returns a whole offline view and its id.
     *
     * @memberof youbora.Plugin.prototype
     */ getOfflineView: function() {
        var ret = null;
        if (this.offlineStorage) ret = this.offlineStorage.getView();
        return ret;
    },
    getDeviceUUID: function() {
        var id = null;
        if (!this.options["device.isAnonymous"]) id = this.options["device.id"] || this.uuidGenerator.getKey();
        return id;
    },
    getAppName: function() {
        return this.options["app.name"];
    },
    getAppReleaseVersion: function() {
        return this.options["app.releaseVersion"];
    },
    getIsBlocked: function() {
        return this.options["ad.blockerDetected"];
    },
    isMethodPostEnabled: function() {
        return this.options.method && this.options.method.toLowerCase() === RequestMethod.POST;
    },
    getPlayheadMonitorEnabled: function() {
        return this.options["playhead.monitor"];
    },
    getReadyStateMonitorEnabled: function() {
        return this.options["readyState.monitor"];
    }
};
module.exports = PluginGetterMixin;

},{"849aaa2c4cf3bfe6":"drhpF","7697a4b3bbb82568":"bsoIP","26583093c89ffe1":"ldnfs"}],"jhZAm":[function(require,module,exports) {
var Log = require("82548b0d604b0e1d");
var Util = require("88f5f842f2364e37");
var version = require("a20aa7ff18b718e9");
var TransportFormat = require("7fb4fc24db3613ef");
var StreamingProtocol = require("3a8177ec280535b5");
// This file is designed to add extra functionalities to Plugin class
var PluginContentGetterMixin = {
    /**
       * Returns content's playhead
       *
       * @memberof youbora.Plugin.prototype
       */ getPlayhead: function() {
        var ret = this._safeGetterAdapter("getPlayhead");
        return Util.parseNumber(ret, 0);
    },
    /**
       * Returns content's PlayRate
       *
       * @memberof youbora.Plugin.prototype
       */ getPlayrate: function() {
        var ret = 0;
        if (this._adapter && this._adapter.flags && !this._adapter.flags.isPaused) try {
            ret = this._adapter.getPlayrate();
        } catch (err) {
            Log.warn("An error occured while calling getPlayrate", err);
        }
        return ret;
    },
    /**
       * Returns content's FramesPerSecond
       *
       * @memberof youbora.Plugin.prototype
       */ getFramesPerSecond: function() {
        return this._safeGetterAdapter("getFramesPerSecond", "content.fps");
    },
    /**
   * Returns content's segment duration
   *
   * @memberof youbora.Plugin.prototype
   */ getSegmentDuration: function() {
        return this.hybridNetwork.getSegmentDuration() || this._safeGetterAdapter("getSegmentDuration", "content.segmentDuration");
    },
    /**
       * Returns content's DroppedFrames
       *
       * @memberof youbora.Plugin.prototype
       */ getDroppedFrames: function() {
        var ret = this._safeGetterAdapter("getDroppedFrames");
        if (!ret) ret = this.getWebkitDroppedFrames();
        return Util.parseNumber(ret, 0);
    },
    /**
       * Returns dropped frames as per webkitDroppedFrameCount
       *
       * @returns {number}
       *
       * @memberof youbora.Plugin.prototype
       */ getWebkitDroppedFrames: function() {
        if (this._adapter && this._adapter.tag && this._adapter.tag.webkitDroppedFrameCount) return this._adapter.tag.webkitDroppedFrameCount;
        return null;
    },
    /**
       * Returns content's Duration
       *
       * @memberof youbora.Plugin.prototype
       */ getDuration: function() {
        var ret = this._safeGetterAdapter("getDuration", "content.duration") || null;
        return Util.parseNumber(Math.round(ret), null);
    },
    /**
       * Returns content's Bitrate
       *
       * @memberof youbora.Plugin.prototype
       */ getBitrate: function() {
        var ret = this._safeGetterAdapter("getBitrate", "content.bitrate");
        if (!ret || ret === -1) ret = this.getWebkitBitrate();
        return Util.parseNumber(ret, -1);
    },
    /**
       * Returns content's total bytes downloaded
       *
       * @memberof youbora.Plugin.prototype
       */ getTotalBytes: function() {
        return this.options["content.sendTotalBytes"] ? this._safeGetterAdapter("getTotalBytes", "content.totalBytes") : null;
    },
    /**
       * Returns bitrate as per webkitVideoDecodedByteCount
       *
       * @param {Object} tag Video tag DOM reference.
       * @returns {number}
       *
       * @memberof youbora.Plugin.prototype
       */ getWebkitBitrate: function() {
        if (this._adapter && this._adapter.tag && this._adapter.tag.webkitVideoDecodedByteCount) {
            var bitrate = this._adapter.tag.webkitVideoDecodedByteCount;
            if (this._lastWebkitBitrate) {
                var delta = this._adapter.tag.webkitVideoDecodedByteCount - this._lastWebkitBitrate;
                bitrate = Math.round(delta / this.viewTransform.response.pingTime * 8);
            }
            this._lastWebkitBitrate = this._adapter.tag.webkitVideoDecodedByteCount;
            return bitrate !== 0 ? bitrate : -1;
        }
    },
    /**
       * Returns content's Throughput
       *
       * @memberof youbora.Plugin.prototype
       */ getThroughput: function() {
        var ret = this._safeGetterAdapter("getThroughput", "content.throughput");
        return Util.parseNumber(ret, -1);
    },
    /**
       * Returns content's Rendition
       *
       * @memberof youbora.Plugin.prototype
       */ getRendition: function() {
        return this._safeGetterAdapter("getRendition", "content.rendition");
    },
    /**
       * Returns content's Title
       *
       * @memberof youbora.Plugin.prototype
       */ getTitle: function() {
        return this._safeGetterAdapter("getTitle", "content.title");
    },
    /**
       * Returns content's Title2
       *
       * @memberof youbora.Plugin.prototype
       */ getTitle2: function() {
        return this._safeGetterAdapter("getTitle2", "content.program");
    },
    /**
       * Returns content's IsLive
       *
       * @memberof youbora.Plugin.prototype
       */ getIsLive: function() {
        var ret = this.options["content.isLive"];
        if (!ret && ret !== false) ret = this._safeGetterAdapter("getIsLive") || false;
        return ret;
    },
    /**
       * Returns content's Resource after being parsed by the resourceTransform
       *
       * @memberof youbora.Plugin.prototype
       */ getResource: function() {
        return this._safeGetterAdapter("getResource", "content.resource");
    },
    getParsedResource: function() {
        var ret = null;
        if (!this.resourceTransform.isBlocking()) ret = this.resourceTransform.getResource();
        ret = ret || this._safeGetterAdapter("getURLToParse");
        return ret === this.getResource() ? null : ret;
    },
    /**
       * Returns content's TransactionCode
       *
       * @memberof youbora.Plugin.prototype
       */ getTransactionCode: function() {
        return this.options["content.transactionCode"];
    },
    /**
       * Returns content's Metadata
       *
       * @memberof youbora.Plugin.prototype
       */ getMetadata: function() {
        return this.options["content.metadata"];
    },
    /**
       * Returns content's PlayerVersion
       *
       * @memberof youbora.Plugin.prototype
       */ getPlayerVersion: function() {
        return this._safeGetterAdapter("getPlayerVersion") || "";
    },
    /**
       * Returns content's PlayerName
       *
       * @memberof youbora.Plugin.prototype
       */ getPlayerName: function() {
        return this._safeGetterAdapter("getPlayerName") || "";
    },
    /**
       * Returns content's Cdn
       *
       * @memberof youbora.Plugin.prototype
       */ getCdn: function() {
        var ret = null;
        if (!this.resourceTransform.isBlocking()) ret = this.resourceTransform.getCdnName();
        return ret || this.options["content.cdn"];
    },
    /**
       * Returns content's PluginVersion
       *
       * @memberof youbora.Plugin.prototype
       */ getPluginVersion: function() {
        var ret = this.getAdapterVersion();
        if (!ret) ret = version + "-adapterless-js";
        return ret;
    },
    /**
       * Returns content's PluginVersion
       *
       * @memberof youbora.Plugin.prototype
       */ getLibVersion: function() {
        return version;
    },
    /**
       * Returns ads adapter getVersion or null
       *
       * @memberof youbora.Plugin.prototype
       */ getAdapterVersion: function() {
        return this._safeGetterAdapter("getVersion");
    },
    /**
       * Returns cdn traffic received in bytes or null
       *
       * @memberof youbora.Plugin.prototype
       */ getCdnTraffic: function() {
        return this._safeGetterAdapter("getCdnTraffic") || this.hybridNetwork.getCdnTraffic();
    },
    /**
   * Returns multi cdn traffic received in bytes or null
   *
   * @memberof youbora.Plugin.prototype
   */ getMultiCdnInfo: function() {
        return this.hybridNetwork.getMultiCdnInfo();
    },
    /**
   * Returns cdn balancer response id
   *
   * @memberof youbora.Plugin.prototype
   */ getBalancerResponseId: function() {
        var ret = this.hybridNetwork.getBalancerResponseId();
        if (!ret && this.options["cdnbalancer.uuid"]) return this.options["cdnbalancer.uuid"];
        return ret;
    },
    /**
       * Returns p2p traffic received in bytes or null
       *
       * @memberof youbora.Plugin.prototype
       */ getP2PTraffic: function() {
        return this._safeGetterAdapter("getP2PTraffic") || this.hybridNetwork.getP2PTraffic();
    },
    /**
       * Returns p2p traffic sent in bytes or null
       *
       * @memberof youbora.Plugin.prototype
       */ getUploadTraffic: function() {
        return this._safeGetterAdapter("getUploadTraffic") || this.hybridNetwork.getUploadTraffic();
    },
    /**
       * Returns if p2p plugin is enabled or null
       *
       * @memberof youbora.Plugin.prototype
       */ getIsP2PEnabled: function() {
        return this._safeGetterAdapter("getIsP2PEnabled") || this.hybridNetwork.getIsP2PEnabled();
    },
    /** Returns streaming protocol (DASH, HLS, HDS...) */ getStreamingProtocol: function() {
        var ret = this.options["content.streamingProtocol"];
        // if ret is not in the list of possible options, ret = null
        if (ret) for(var i in StreamingProtocol){
            if (StreamingProtocol[i] === ret) return ret;
        }
        return null;
    },
    /** Returns transport format (TS, MP4) */ getTransportFormat: function() {
        var ret = this.options["content.transportFormat"];
        if (!ret && this.options["parse.manifest"] && !this.resourceTransform.isBlocking()) ret = this.resourceTransform.getTransportFormat();
        // if ret is not in the list of possible options, ret = null
        if (ret) for(var i in TransportFormat){
            if (TransportFormat[i] === ret) return ret;
        }
        return null;
    },
    /** Returns household id */ getHouseholdId: function() {
        return this._safeGetterAdapter("getHouseholdId");
    },
    /**
       * Returns latency of a live video, or null
       *
       * @memberof youbora.Plugin.prototype
       */ getLatency: function() {
        return this.getIsLive() ? this._safeGetterAdapter("getLatency") : null;
    },
    /**
       * Returns the amount of packets lost, or null
       *
       * @memberof youbora.Plugin.prototype
       */ getPacketLoss: function() {
        return this._safeGetterAdapter("getPacketLoss");
    },
    /**
       * Returns the amount of packets sent, or null
       *
       * @memberof youbora.Plugin.prototype
       */ getPacketSent: function() {
        return this._safeGetterAdapter("getPacketSent");
    },
    /**
       * Returns a json with the metrics to be reported in pings when changed
       *
       * @memberof youbora.Plugin.prototype
       */ getVideoMetrics: function() {
        return Util.getMetricsFrom(this._adapter ? this._adapter.getMetrics() : null, this.options["content.metrics"]);
    },
    getPlayerStartupTime: function() {
        return this.browserLoadTimes.getPlayerStartupTime();
    },
    // ----------------------------------------- CHRONOS ------------------------------------------
    /**
       * Returns JoinDuration chrono delta time
       *
       * @memberof youbora.Plugin.prototype
       */ getJoinDuration: function() {
        return this._adapter ? this._adapter.chronos.join.getDeltaTime(false) : -1;
    },
    /**
       * Returns BufferDuration chrono delta time
       *
       * @memberof youbora.Plugin.prototype
       */ getBufferDuration: function() {
        return this._adapter ? this._adapter.chronos.buffer.getDeltaTime(false) : -1;
    },
    /**
       * Returns SeekDuration chrono delta time
       *
       * @memberof youbora.Plugin.prototype
       */ getSeekDuration: function() {
        return this._adapter ? this._adapter.chronos.seek.getDeltaTime(false) : -1;
    },
    /**
       * Returns pauseDuration chrono delta time
       *
       * @memberof youbora.Plugin.prototype
       */ getPauseDuration: function() {
        return this._adapter ? this._adapter.chronos.pause.getDeltaTime(false) : 0;
    },
    /**
       * Returns content's package
       *
       * @memberof youbora.Plugin.prototype
       */ getPackage: function() {
        return this.options["content.package"];
    },
    /**
       * Returns content's saga
       *
       * @memberof youbora.Plugin.prototype
       */ getSaga: function() {
        return this.options["content.saga"];
    },
    /**
       * Returns content's tv show
       *
       * @memberof youbora.Plugin.prototype
       */ getTvShow: function() {
        return this.options["content.tvShow"];
    },
    /**
       * Returns content's season
       *
       * @memberof youbora.Plugin.prototype
       */ getSeason: function() {
        return this.options["content.season"];
    },
    /**
       * Returns content's episode title
       *
       * @memberof youbora.Plugin.prototype
       */ getEpisodeTitle: function() {
        return this.options["content.episodeTitle"];
    },
    /**
       * Returns content's channel
       *
       * @memberof youbora.Plugin.prototype
       */ getChannel: function() {
        return this.options["content.channel"];
    },
    /**
       * Returns content's id
       *
       * @memberof youbora.Plugin.prototype
       */ getID: function() {
        return this.options["content.id"];
    },
    /**
       * Returns content's IMDB id
       *
       * @memberof youbora.Plugin.prototype
       */ getImdbId: function() {
        return this.options["content.imdbId"];
    },
    /**
       * Returns content's gracenote id
       *
       * @memberof youbora.Plugin.prototype
       */ getGracenoteID: function() {
        return this.options["content.gracenoteId"];
    },
    /**
       * Returns content's type
       *
       * @memberof youbora.Plugin.prototype
       */ getType: function() {
        return this.options["content.type"];
    },
    /**
       * Returns content's genre
       *
       * @memberof youbora.Plugin.prototype
       */ getGenre: function() {
        return this.options["content.genre"];
    },
    /**
       * Returns content's language
       *
       * @memberof youbora.Plugin.prototype
       */ getVideoLanguage: function() {
        return this.options["content.language"];
    },
    /**
       * Returns content's subtitles
       *
       * @memberof youbora.Plugin.prototype
       */ getSubtitles: function() {
        return this.options["content.subtitles"];
    },
    /**
       * Returns content's contracted resolution
       *
       * @memberof youbora.Plugin.prototype
       */ getContractedResolution: function() {
        return this.options["content.contractedResolution"];
    },
    /**
       * Returns content's cost
       *
       * @memberof youbora.Plugin.prototype
       */ getCost: function() {
        return this.options["content.cost"];
    },
    /**
       * Returns content's price
       *
       * @memberof youbora.Plugin.prototype
       */ getPrice: function() {
        return this.options["content.price"];
    },
    /**
       * Returns content's playback type
       *
       * @memberof youbora.Plugin.prototype
       */ getPlaybackType: function() {
        var ret = this.options["content.playbackType"];
        if (!ret) {
            var isLive = this.options["content.isLive"];
            if (typeof isLive !== "boolean") isLive = this._safeGetterAdapter("getIsLive");
            if (typeof isLive === "boolean") ret = isLive ? "Live" : "VoD";
        }
        return ret;
    },
    /**
       * Returns content's DRM
       *
       * @memberof youbora.Plugin.prototype
       */ getDRM: function() {
        return this.options["content.drm"];
    },
    /**
       * Returns content's video codec
       *
       * @memberof youbora.Plugin.prototype
       */ getVideoCodec: function() {
        return this._safeGetterAdapter("getVideoCodec", "content.encoding.videoCodec");
    },
    /**
       * Returns content's audio codec
       *
       * @memberof youbora.Plugin.prototype
       */ getAudioCodec: function() {
        return this._safeGetterAdapter("getAudioCodec", "content.encoding.audioCodec");
    },
    /**
       * Returns content's codec settings
       *
       * @memberof youbora.Plugin.prototype
       */ getCodecSettings: function() {
        return this.options["content.encoding.codecSettings"];
    },
    /**
       * Returns content's codec profile
       *
       * @memberof youbora.Plugin.prototype
       */ getCodecProfile: function() {
        return this.options["content.encoding.codecProfile"];
    },
    /**
       * Returns content's container format
       *
       * @memberof youbora.Plugin.prototype
       */ getContainerFormat: function() {
        return this.options["content.encoding.containerFormat"];
    },
    /**
     * Returns linked view id string
     *
     * @memberof youbora.Plugin.prototype
     */ getLinkedViewId: function() {
        return this.options.linkedViewId;
    },
    _safeGetterAdapter: function(functionName, optionName) {
        var ret = null;
        if (optionName && this.options[optionName]) ret = this.options[optionName];
        else try {
            if (this._adapter && typeof this._adapter[functionName] === "function") ret = this._adapter[functionName]();
        } catch (err) {
            Log.warn("An error occured while calling " + functionName, err);
        }
        return ret;
    }
};
module.exports = PluginContentGetterMixin;

},{"82548b0d604b0e1d":"8xsxZ","88f5f842f2364e37":"drhpF","a20aa7ff18b718e9":"bsoIP","7fb4fc24db3613ef":"czE3D","3a8177ec280535b5":"iIpwU"}],"eOAEJ":[function(require,module,exports) {
var Log = require("8c5f47398b02696a");
var Constants = require("cec0f28456a526cf");
var Adapter = require("dff476ef52f794f3");
var Util = require("5a4f7f858e4fe8a4");
// This file is designed to add extra functionalities to Plugin class
var PluginAdsMixin = {
    /**
     * Returns current adapter or null.
     *
     * @returns {Adapter}
     *
     * @memberof youbora.Plugin.prototype
     */ getAdsAdapter: function() {
        return this._adsAdapter;
    },
    /**
     * Sets an adapter for ads.
     *
     * @param {Adapter} adsAdapter
     *
     * @memberof youbora.Plugin.prototype
     */ setAdsAdapter: function(adsAdapter) {
        if (adsAdapter.plugin) Log.warn("Adapters can only be added to a single plugin");
        else {
            this.removeAdsAdapter();
            adsAdapter.plugin = this;
            this._adsAdapter = adsAdapter;
            adsAdapter.setIsAds(true);
            this.adsAdapterListeners = {};
            this.adsAdapterListeners[Adapter.Event.START] = this._adStartListener.bind(this);
            this.adsAdapterListeners[Adapter.Event.JOIN] = this._adJoinListener.bind(this);
            this.adsAdapterListeners[Adapter.Event.PAUSE] = this._adPauseListener.bind(this);
            this.adsAdapterListeners[Adapter.Event.RESUME] = this._adResumeListener.bind(this);
            this.adsAdapterListeners[Adapter.Event.BUFFER_BEGIN] = this._adBufferBeginListener.bind(this);
            this.adsAdapterListeners[Adapter.Event.BUFFER_END] = this._adBufferEndListener.bind(this);
            this.adsAdapterListeners[Adapter.Event.STOP] = this._adStopListener.bind(this);
            this.adsAdapterListeners[Adapter.Event.ERROR] = this._adErrorListener.bind(this);
            this.adsAdapterListeners[Adapter.Event.CLICK] = this._adClickListener.bind(this);
            this.adsAdapterListeners[Adapter.Event.MANIFEST] = this._adManifestListener.bind(this);
            this.adsAdapterListeners[Adapter.Event.PODSTART] = this._adBreakStartListener.bind(this);
            this.adsAdapterListeners[Adapter.Event.PODSTOP] = this._adBreakStopListener.bind(this);
            this.adsAdapterListeners[Adapter.Event.QUARTILE] = this._adQuartileListener.bind(this);
            for(var key in this.adsAdapterListeners)this._adsAdapter.on(key, this.adsAdapterListeners[key]);
        }
    },
    /**
     * Removes the current adapter. Fires stop if needed. Calls adapter.dispose()
     *
     * @memberof youbora.Plugin.prototype
     */ removeAdsAdapter: function() {
        if (this._adsAdapter) {
            this._adsAdapter.dispose();
            this._adsAdapter.plugin = null;
            if (this.adsAdapterListeners) {
                for(var key in this.adsAdapterListeners)this._adsAdapter.off(key, this.adsAdapterListeners[key]);
                delete this.adsAdapterListeners;
            }
            this.resizeScrollDetector.stopDetection();
            this._adsAdapter = null;
        }
    },
    // ---------------------------------------- LISTENERS -----------------------------------------
    _adStartListener: function(e) {
        if (this._adapter) {
            this._adapter.fireBufferEnd(null, "adStartListener");
            this._adapter.fireSeekEnd(null, "adStartListener");
            if (!this.isInitiated && !this._adapter.flags.isStarted) this._adapter.fireStart();
            if (this._adapter.flags.isPaused) this._adapter.chronos.pause.reset();
        } else this.fireInit();
        if (this._adsAdapter) this._adsAdapter.chronos.viewedMax = [];
        var params = e.data.params || {};
        params.adNumber = this.requestBuilder.getNewAdNumber();
        var allParamsReady = (this.getAdResource() || this.getAdTitle()) && typeof this.getAdDuration() === "number";
        if (allParamsReady) {
            this.adStartSent = true;
            this._adsAdapter.fireManifest();
            this._adsAdapter.fireBreakStart();
            params.adNumberInBreak = this.requestBuilder.getNewAdNumberInBreak();
            this._sendAdEventIfAllowed(Constants.WillSendEvent.WILL_SEND_AD_START, Constants.Service.AD_START, params);
        } else {
            this.adInitSent = true;
            params.adNumberInBreak = this.requestBuilder.getNewAdNumberInBreak();
            this._sendAdEventIfAllowed(Constants.WillSendEvent.WILL_SEND_AD_INIT, Constants.Service.AD_INIT, params);
        }
    },
    _adJoinListener: function(e) {
        var params = {};
        Util.assign(params, e.data.params || {});
        if (this.adInitSent && !this.adStartSent) {
            this._adsAdapter.fireManifest();
            this._adsAdapter.fireBreakStart();
            this._sendAdEventIfAllowed(Constants.WillSendEvent.WILL_SEND_AD_START, Constants.Service.AD_START, params);
        }
        this._adsAdapter.startChronoView();
        if (this.adConnected) {
            this._adsAdapter.chronos.join.startTime = this.adConnectedTime;
            this._adsAdapter.chronos.total.startTime = this.adConnectedTime;
            this.adConnectedTime = 0;
            this.adConnected = false;
        }
        params = e.data.params || {};
        this._sendAdEventIfAllowed(Constants.WillSendEvent.WILL_SEND_AD_JOIN, Constants.Service.AD_JOIN, params);
        this.adInitSent = false;
        this.adStartSent = false;
    },
    _adPauseListener: function(e) {
        var params = e.data.params || {};
        this._adsAdapter.stopChronoView();
        this._sendAdEventIfAllowed(Constants.WillSendEvent.WILL_SEND_AD_PAUSE, Constants.Service.AD_PAUSE, params);
    },
    _adResumeListener: function(e) {
        var params = e.data.params || {};
        this._adsAdapter.startChronoView();
        this._sendAdEventIfAllowed(Constants.WillSendEvent.WILL_SEND_AD_RESUME, Constants.Service.AD_RESUME, params);
    },
    _adBufferBeginListener: function(e) {
        Log.notice("Ad Buffer Begin");
        this._adsAdapter.stopChronoView();
        if (this._adsAdapter && this._adsAdapter.flags.isPaused) this._adsAdapter.chronos.pause.reset();
    },
    _adBufferEndListener: function(e) {
        var params = e.data.params || {};
        this._adsAdapter.startChronoView();
        this._sendAdEventIfAllowed(Constants.WillSendEvent.WILL_SEND_AD_BUFFER, Constants.Service.AD_BUFFER, params);
    },
    _adStopListener: function(e) {
        this._adsAdapter.stopChronoView();
        this._adsAdapter.flags.reset();
        this._totalPrerollsTime = (this._totalPrerollsTime || 0) + this._adsAdapter.chronos.total.getDeltaTime();
        var params = e.data.params || {};
        params.position = this.requestBuilder.lastSent.position;
        this._sendAdEventIfAllowed(Constants.WillSendEvent.WILL_SEND_AD_STOP, Constants.Service.AD_STOP, params);
        // If its a stop for a postroll we check if we can detect if its the last one to call view stop
        if (this.requestBuilder.lastSent.position === Constants.AdPosition.Postroll) {
            var pat = this.options["ad.expectedPattern"];
            this.playedPostrolls++;
            // If we know the amount of postrolls and this was the last one
            if (this.requestBuilder.lastSent.givenAds && this.requestBuilder.lastSent.givenAds <= this.playedPostrolls || // Or if we have expected (and not given!) and this was the last expected one
            !this.requestBuilder.lastSent.givenAds && pat && pat.post && pat.post[0] && pat.post[0] <= this.playedPostrolls) this.fireStop();
        }
        this.adConnected = true;
        this.adConnectedTime = new Date().getTime();
    },
    _adErrorListener: function(e) {
        var params = e.data.params || {};
        if (this._adapter && !this._adapter.flags.isStarted && !this.isInitiated) {
            this._savedAdError = e;
            return null // Ignore ad errors before content
            ;
        }
        if (this._blockAdError(e.data.params)) return null;
        if (this._adsAdapter) {
            this._adsAdapter.fireManifest();
            this._adsAdapter.fireBreakStart();
        }
        if (!this._adsAdapter || !this._adsAdapter.flags.isStarted) {
            params.adNumber = this.requestBuilder.getNewAdNumber();
            params.adNumberInBreak = this.requestBuilder.getNewAdNumberInBreak();
        }
        if (!this.isBreakStarted) params.breakNumber = this.requestBuilder.getNewBreakNumber();
        this._sendAdEventIfAllowed(Constants.WillSendEvent.WILL_SEND_AD_ERROR, Constants.Service.AD_ERROR, params);
    },
    _adSavedError: function() {
        if (this._savedAdError) {
            this._adErrorListener(this._savedAdError);
            this._savedAdError = null;
        }
    },
    _adSavedManifest: function() {
        if (this._savedAdManifest) {
            this._adManifestListener(this._savedAdManifest);
            this._savedAdManifest = null;
        }
    },
    _blockAdError: function(errorParams) {
        var now = Date.now();
        var sameError = this._lastAdErrorParams && this._lastAdErrorParams.errorCode === errorParams.errorCode && this._lastAdErrorParams.msg === errorParams.msg && this._lastAdErrorParams.adCreativeId === this.getAdCreativeId();
        if (sameError && this._lastAdErrorTime + 5000 > now) {
            this._lastAdErrorTime = now;
            return true;
        }
        this._lastAdErrorTime = now;
        this._lastAdErrorParams = errorParams;
        return false;
    },
    _adClickListener: function(e) {
        var params = e.data.params || {};
        this._adsAdapter.stopChronoView();
        this._sendAdEventIfAllowed(Constants.WillSendEvent.WILL_SEND_AD_CLICK, Constants.Service.AD_CLICK, params);
    },
    _adManifestListener: function(e) {
        if (!this.isAdsManifestSent) {
            if (this._adapter && !this._adapter.flags.isStarted && !this.isInitiated) {
                this._savedAdManifest = e;
                return null // Ignore ad manifest before content
                ;
            }
            var params = e.data.params || {};
            this.isAdsManifestSent = true;
            this._sendAdEventIfAllowed(Constants.WillSendEvent.WILL_SEND_AD_MANIFEST, Constants.Service.AD_MANIFEST, params);
        }
    },
    _adBreakStartListener: function(e) {
        if (!this.isBreakStarted) {
            this.isBreakStarted = true;
            if (this._adapter) this._adapter.firePause();
            var params = e.data.params || {};
            params.breakNumber = this.requestBuilder.getNewBreakNumber();
            this._sendAdEventIfAllowed(Constants.WillSendEvent.WILL_SEND_AD_POD_START, Constants.Service.AD_POD_START, params);
            this.adConnected = false;
        }
    },
    _adBreakStopListener: function(e) {
        if (this.isBreakStarted) {
            this.isBreakStarted = false;
            var params = e.data.params || {};
            params.position = this.requestBuilder.lastSent.position;
            this._sendAdEventIfAllowed(Constants.WillSendEvent.WILL_SEND_AD_POD_STOP, Constants.Service.AD_POD_STOP, params);
            this.adConnected = false;
            if (this._adapter) this._adapter.fireResume();
        }
    },
    _adQuartileListener: function(e) {
        var params = e.data.params || {};
        if (params.quartile) this._sendAdEventIfAllowed(Constants.WillSendEvent.WILL_SEND_AD_QUARTILE, Constants.Service.AD_QUARTILE, params);
    },
    _sendAdEventIfAllowed: function(willSend, service, params) {
        if (!this.options["ad.ignore"]) this._send(willSend, service, params);
        Log.notice(service);
    }
};
module.exports = PluginAdsMixin;

},{"8c5f47398b02696a":"8xsxZ","cec0f28456a526cf":"92xpS","dff476ef52f794f3":"7AnqL","5a4f7f858e4fe8a4":"drhpF"}],"aAyw0":[function(require,module,exports) {
var Log = require("d5300527c166e0ab");
var Util = require("7a62a60ec300393f");
var Constants = require("f2eba69fbc18fbcf");
// This file is designed to add extra functionalities to Plugin class
var PluginAdsGettersMixin = {
    /**
   * Returns ads's PlayerVersion
   *
   * @memberof youbora.Plugin.prototype
   */ getAdPlayerVersion: function() {
        return this._safeGetterAdsAdapter("getPlayerVersion") || "";
    },
    /**
   * Returns ad's position
   *
   * @memberof youbora.Plugin.prototype
   */ getAdPosition: function() {
        var ret = Constants.AdPosition.Preroll;
        if (this._adsAdapter) try {
            var temporalRet = this._adsAdapter.getPosition();
            if (Constants.AdPosition.Preroll === temporalRet || Constants.AdPosition.Midroll === temporalRet || Constants.AdPosition.Postroll === temporalRet) ret = temporalRet;
        } catch (err) {
            Log.warn("An error occured while calling getAdPosition", err);
        }
        if (!ret && this._adapter) ret = this._adapter.flags.isJoined ? Constants.AdPosition.Midroll : Constants.AdPosition.Preroll;
        return ret;
    },
    getAdNumber: function() {
        return this.requestBuilder.lastSent.adNumber || 0;
    },
    getAdNumberInBreak: function() {
        return this.requestBuilder.lastSent.adNumberInBreak || 0;
    },
    getBreakNumber: function() {
        return this.requestBuilder.lastSent.breakNumber || 0;
    },
    /**
   * Returns ad's AdPlayhead
   *
   * @memberof youbora.Plugin.prototype
   */ getAdPlayhead: function() {
        var ret = this._safeGetterAdsAdapter("getPlayhead");
        return Util.parseNumber(ret, 0);
    },
    /**
   * Returns ad's AdDuration
   *
   * @memberof youbora.Plugin.prototype
   */ getAdDuration: function() {
        var ret = this._safeGetterAdsAdapter("getDuration", "ad.duration");
        return Util.parseNumber(ret, 0);
    },
    /**
   * Returns ad's AdBitrate
   *
   * @memberof youbora.Plugin.prototype
   */ getAdBitrate: function() {
        var ret = this._safeGetterAdsAdapter("getBitrate");
        if (!ret || ret === -1) ret = this.getWebkitAdBitrate();
        return Util.parseNumber(ret, -1);
    },
    /**
   * Returns bitrate as per webkitVideoDecodedByteCount
   *
   * @param {Object} tag Video tag DOM reference.
   * @returns {number}
   *
   * @memberof youbora.Plugin.prototype
   */ getWebkitAdBitrate: function() {
        if (this._adsAdapter && this._adsAdapter.tag && this._adsAdapter.tag.webkitVideoDecodedByteCount) {
            var bitrate = this._adsAdapter.tag.webkitVideoDecodedByteCount;
            if (this._lastWebkitAdBitrate) {
                var delta = this._adsAdapter.tag.webkitVideoDecodedByteCount - this._lastWebkitAdBitrate;
                bitrate = Math.round(delta / this.viewTransform.response.pingTime * 8);
            }
            this._lastWebkitAdBitrate = this._adsAdapter.tag.webkitVideoDecodedByteCount;
            return bitrate !== 0 ? bitrate : -1;
        }
    },
    /**
   * Returns ad's AdTitle
   *
   * @memberof youbora.Plugin.prototype
   */ getAdTitle: function() {
        return this._safeGetterAdsAdapter("getTitle", "ad.title");
    },
    /**
   * Returns ad's AdResource
   *
   * @memberof youbora.Plugin.prototype
   */ getAdResource: function() {
        return this._safeGetterAdsAdapter("getResource", "ad.resource");
    },
    /**
   * Returns ad's campaign
   *
   * @memberof youbora.Plugin.prototype
   */ getAdCampaign: function() {
        return this._safeGetterAdsAdapter("getCampaign", "ad.campaign");
    },
    /**
  * Returns ad's campaign
  *
  * @memberof youbora.Plugin.prototype
  */ getAdCreativeId: function() {
        return this._safeGetterAdsAdapter("getCreativeId", "ad.creativeId");
    },
    /**
  * Returns ad's provider
  *
  * @memberof youbora.Plugin.prototype
  */ getAdProvider: function() {
        return this._safeGetterAdsAdapter("getProvider", "ad.provider");
    },
    /**
   * Returns ads adapter getVersion or null
   *
   * @memberof youbora.Plugin.prototype
   */ getAdAdapterVersion: function() {
        return this._safeGetterAdsAdapter("getVersion");
    },
    /**
   * Returns ad's AdMetadata
   *
   * @memberof youbora.Plugin.prototype
   */ getAdMetadata: function() {
        return this.options["ad.metadata"];
    },
    /**
   * Returns the type of ad insertion (clientside, serverside)
   * @returns {string} ad insertion type
   */ getAdInsertionType: function() {
        return this._safeGetterAdsAdapter("getAdInsertionType");
    },
    getGivenBreaks: function() {
        return this._safeGetterAdsAdapter("getGivenBreaks", "ad.givenBreaks");
    },
    getExpectedBreaks: function() {
        var ret = null;
        var expBreaks = this.options["ad.expectedBreaks"];
        var expPattern = this.options["ad.expectedPattern"];
        if (expBreaks) ret = expBreaks;
        else if (expPattern) {
            ret = 0;
            ret = expPattern.pre ? expPattern.pre.length : 0;
            ret += expPattern.mid ? expPattern.mid.length : 0;
            ret += expPattern.post ? expPattern.post.length : 0;
        } else if (this._adsAdapter) try {
            ret = this._adsAdapter.getExpectedBreaks();
        } catch (err) {
            Log.warn("An error occured while calling expectedBreaks", err);
        }
        return ret;
    },
    getExpectedPattern: function() {
        return this._safeGetterAdsAdapter("getExpectedPattern", "ad.expectedPattern");
    },
    getBreaksTime: function() {
        return this._safeGetterAdsAdapter("getBreaksTime", "ad.breaksTime");
    },
    getGivenAds: function() {
        return this._safeGetterAdsAdapter("getGivenAds", "ad.givenAds");
    },
    getExpectedAds: function() {
        var ret = null;
        try {
            if (this._adsAdapter) {
                var pattern = this.options["ad.expectedPattern"];
                if (pattern && this.getAdPosition()) {
                    var list = [];
                    if (pattern.pre) list = list.concat(pattern.pre);
                    if (pattern.mid) list = list.concat(pattern.mid);
                    if (pattern.post) list = list.concat(pattern.post);
                    if (list.length > 0) {
                        var position = this.requestBuilder.lastSent.breakNumber;
                        if (position > list.length) position = list.length;
                        ret = list[position - 1];
                    }
                } else ret = this._adsAdapter.getExpectedAds();
            }
        } catch (err) {
            Log.warn("An error occured while calling expectedAds", err);
        }
        return ret;
    },
    getAdsExpected: function() {
        var ret = null;
        try {
            ret = this.getExpectedPattern() || this.getGivenAds() || false;
        } catch (err) {
            Log.warn("An error occured while calling givenAds or expectedPattern", err);
        }
        return ret;
    },
    // ----------------------------------------- CHRONOS ------------------------------------------
    /**
   * Returns AdJoinDuration chrono delta time
   *
   * @memberof youbora.Plugin.prototype
   */ getAdJoinDuration: function() {
        return this._adsAdapter ? this._adsAdapter.chronos.join.getDeltaTime(false) : -1;
    },
    /**
   * Returns AdBufferDuration chrono delta time
   *
   * @memberof youbora.Plugin.prototype
   */ getAdBufferDuration: function() {
        return this._adsAdapter ? this._adsAdapter.chronos.buffer.getDeltaTime(false) : -1;
    },
    /**
   * Returns AdPauseDuration chrono delta time
   *
   * @memberof youbora.Plugin.prototype
   */ getAdPauseDuration: function() {
        return this._adsAdapter ? this._adsAdapter.chronos.pause.getDeltaTime(false) : 0;
    },
    /**
   * Returns total totalAdDuration chrono delta time
   *
   * @memberof youbora.Plugin.prototype
   */ getAdTotalDuration: function() {
        return this._adsAdapter ? this._adsAdapter.chronos.total.getDeltaTime(false) : -1;
    },
    getAdViewedDuration: function() {
        return this._getTimeMaxOrAcum(true);
    },
    getAdViewability: function() {
        return this._getTimeMaxOrAcum();
    },
    _getTimeMaxOrAcum: function(acum) {
        var maxTime = 0;
        if (this._adsAdapter) this._adsAdapter.chronos.viewedMax.forEach(function(chrono) {
            if (acum) maxTime += chrono.getDeltaTime(false);
            else maxTime = Math.max(chrono.getDeltaTime(false), maxTime);
        });
        return maxTime;
    },
    getAudioEnabled: function() {
        return this._safeGetterAdsAdapter("getAudioEnabled");
    },
    getIsSkippable: function() {
        return this._safeGetterAdsAdapter("getIsSkippable");
    },
    getIsFullscreen: function() {
        return this._safeGetterAdsAdapter("getIsFullscreen");
    },
    _safeGetterAdsAdapter: function(func, option) {
        var ret = null;
        if (option && this.options[option]) ret = this.options[option];
        else try {
            if (this._adsAdapter && typeof this._adsAdapter[func] === "function") ret = this._adsAdapter[func]();
        } catch (err) {
            Log.warn("An error occured while calling " + func, err);
        }
        return ret;
    }
};
module.exports = PluginAdsGettersMixin;

},{"d5300527c166e0ab":"8xsxZ","7a62a60ec300393f":"drhpF","f2eba69fbc18fbcf":"92xpS"}],"68M1M":[function(require,module,exports) {
var Log = require("e9d8f3c0e1afb767");
var Constants = require("289473d295d7e150");
// This file is designed to add extra functionalities to Plugin class
var PluginPingMixin = {
    /**
   * Starts sending pings.
   *
   * @private
   * @memberof youbora.Plugin.prototype
   */ _startPings: function() {
        if (!this._ping.isRunning) this._ping.start();
    },
    /**
   * Stops sending pings.
   *
   * @private
   * @memberof youbora.Plugin.prototype
   */ _stopPings: function() {
        this._ping.stop();
    },
    /**
   * Sends ping request
   *
   * @param {number} diffTime Time since the last ping
   *
   * @private
   * @memberof youbora.Plugin.prototype
   */ _sendPing: function(diffTime) {
        var params = {
            diffTime: diffTime,
            entities: this.requestBuilder.getChangedEntities()
        };
        if (this._adapter) {
            if (this._adapter.flags.isPaused) params = this.requestBuilder.fetchParams(params, [
                "pauseDuration"
            ]);
            else params = this.requestBuilder.fetchParams(params, [
                "bitrate",
                "throughput",
                "fps"
            ]);
            if (this._adapter.flags.isJoined) params = this.requestBuilder.fetchParams(params, [
                "playhead"
            ]);
            if (this._adapter.flags.isBuffering) params = this.requestBuilder.fetchParams(params, [
                "bufferDuration"
            ]);
            if (this._adapter.flags.isSeeking) params = this.requestBuilder.fetchParams(params, [
                "seekDuration"
            ]);
        }
        if (this._adsAdapter && !this.options["ad.ignore"]) {
            if (this._adsAdapter.flags.isStarted) {
                params = this.requestBuilder.fetchParams(params, [
                    "adPlayhead",
                    "adViewedDuration",
                    "adViewability"
                ]);
                if (this._adsAdapter.flags.isPaused) params = this.requestBuilder.fetchParams(params, [
                    "adPauseDuration"
                ]);
                else params = this.requestBuilder.fetchParams(params, [
                    "adBitrate"
                ]);
            }
            if (this._adsAdapter.flags.isBuffering) params = this.requestBuilder.fetchParams(params, [
                "adBufferDuration"
            ]);
        }
        this._send(Constants.WillSendEvent.WILL_SEND_PING, Constants.Service.PING, params);
        if (this.startDelayed) this._retryStart();
        Log.verbose(Constants.Service.PING);
    }
};
module.exports = PluginPingMixin;

},{"e9d8f3c0e1afb767":"8xsxZ","289473d295d7e150":"92xpS"}],"4mj8g":[function(require,module,exports) {
var Log = require("985545563ae79be4");
var Util = require("bcf688232a5a4297");
var Constants = require("bc0cf63099e9c356");
var Transform = require("1de2d4b3537f6afc");
// This file is designed to add extra functionalities to Plugin class
/** @lends youbora.Plugin.prototype */ var PluginFireMixin = {
    /**
   * Sends /init. Should be called once the user has requested the content. Does not need
   * a working adapter or player to work. it won't sent start if isInitiated is true.
   *
   * @param {Object} [params] Object of key:value params.
   * @param {string} [triggeredEvent]
   *
   * @memberof youbora.Plugin.prototype
   */ fireInit: function(params, triggeredEvent) {
        if (!this.isInitiated) {
            if (!this.getAdapter() || this.getAdapter() && !this.getAdapter().flags.isStarted) {
                this.viewTransform.nextView();
                this._initComm();
                this._startPings();
                this.initChrono.start();
                this.isInitiated = true;
                params = params || {};
                if (triggeredEvent) params.triggeredEvents = [
                    triggeredEvent
                ];
                if (this.options && this.options["session.splitViews"]) params.viewIndex = this.plugin.viewTransform._viewIndex;
                this._send(Constants.WillSendEvent.WILL_SEND_INIT, Constants.Service.INIT, params);
                this._adSavedError();
                this._adSavedManifest();
                Log.notice(Constants.Service.INIT + " " + (params.title || params.mediaResource));
            }
        }
    },
    /**
   * Sends /error. Should be used when the error is related to out-of-player errors: like async
   * resource load or player loading errors.
   *
   * @param {String|Object} [code] Error Code, if an object is sent, it will be treated as params.
   * @param {String} [msg] Error Message
   * @param {Object} [metadata] Object defining error metadata
   * @param {String} [level] Level of the error. Currently supports 'error' and 'fatal'
   *
   * @memberof youbora.Plugin.prototype
   */ fireError: function(object, msg, metadata, level) {
        this.fireInit();
        var params = Util.buildErrorParams(object, msg, metadata, level);
        if (params.code) delete params.code;
        this._send(Constants.WillSendEvent.WILL_SEND_ERROR, Constants.Service.ERROR, params);
        this._adSavedError();
        this._adSavedManifest();
        Log.notice(Constants.Service.ERROR + " " + params.errorLevel + " " + params.errorCode);
        if (params.errorLevel === "fatal") this.fireStop();
    },
    /**
   * Calls fireErrors and then stops pings.
   *
   * @param {String|Object} [code] Error Code, if an object is sent, it will be treated as params.
   * @param {String} [msg] Error Message
   * @param {Object} [metadata] Object defining error metadata
   *
   * @memberof youbora.Plugin.prototype
   */ fireFatalError: function(object, msg, metadata, level) {
        this.fireError(object, msg, metadata, level);
        this.fireStop();
    },
    /**
   * Fires /stop. Should be used to terminate sessions once the player is gone or if
   * plugin.fireError() is called.
   *
   * @param {Object} [params] Object of key:value params.
   *
   * @memberof youbora.Plugin.prototype
   */ fireStop: function(params) {
        if (this.isInitiated || this.isStarted) {
            if (this._adapter) {
                this._adapter.flags.isStopped = true;
                if (this._adapter.monitor) this._adapter.monitor.stop();
            }
            if (this._adsAdapter && this.isBreakStarted) {
                this._adsAdapter.fireStop();
                this._adsAdapter.fireBreakStop();
            }
            params = params || {};
            this._send(Constants.WillSendEvent.WILL_SEND_STOP, Constants.Service.STOP, params);
            var chronos = this._adapter ? this._adapter.chronos : null;
            if (chronos) {
                chronos.total.stop();
                chronos.join.reset();
                chronos.pause.reset();
                chronos.buffer.reset();
                chronos.seek.reset();
            }
            Log.notice(Constants.Service.STOP + " at " + params.playhead + "s");
            this._reset();
        }
    },
    /**
   * Fires /offlineEvents. If offline is disabled, will try to send all the views stored.
   *
   * @param {Object} [params] Object of key:value params.
   *
   * @memberof youbora.Plugin.prototype
   */ fireOfflineEvents: function(params) {
        if (this.options && !this.options.offline) {
            if (!this.isInitiated && (!this._adapter || !this._adapter.flags.isStarted) && (!this._adsAdapter || !this._adsAdapter.flags.isStarted)) {
                this._offlineParams = params;
                if (this.viewTransform.response.code && this.viewTransform.response.host) this._generateAndSendOffline();
                else {
                    this.offlineReference = this._generateAndSendOffline.bind(this);
                    this.viewTransform.on(Transform.Event.DONE, this.offlineReference);
                }
            } else Log.error("Adapters have to be stopped");
        } else Log.error("To send offline events, offline option must be disabled");
    },
    _generateAndSendOffline: function() {
        if (this.options.disableStorage) return null;
        var params = this._offlineParams;
        this._initComm();
        while(true){
            var bodyAndId = this.requestBuilder.buildBody(Constants.Service.OFFLINE_EVENTS).viewJson;
            if (bodyAndId[0] === null) break;
            var newViewCode = this.viewTransform.nextView();
            var body = bodyAndId[0].replace(/CODE_PLACEHOLDER/g, newViewCode.toString()).replace(/,"sessionId":"SESSION_PLACEHOLDER"/g, "") // this.viewTransform.getSession()
            .replace(/,"sessionRoot":"ROOT_PLACEHOLDER"/g, "") // this.viewTransform.getSession()
            ;
            // modify to support offline+infinity
            this._send(Constants.WillSendEvent.WILL_SEND_OFFLINE_EVENTS, Constants.Service.OFFLINE_EVENTS, params, body, "POST", (function(a, callbackParams) {
                this.offlineStorage.removeView(callbackParams.offlineId);
            }).bind(this), {
                offlineId: bodyAndId[1]
            });
        }
        this.offlineStorage.sent();
        this._offlineParams = null;
    }
};
module.exports = PluginFireMixin;

},{"985545563ae79be4":"8xsxZ","bcf688232a5a4297":"drhpF","bc0cf63099e9c356":"92xpS","1de2d4b3537f6afc":"8oBJA"}],"kYvTu":[function(require,module,exports) {
var Constants = require("f0c9ef35b7bbe0ac");
var Log = require("2764206c439c722c");
var YBRequest = require("cae63f66ee08eff6");
var Util = require("832bd489d2f6c3dc");
var YouboraInfinity = require("82c8e019079ec1cf");
// This file is designed to add extra functionalities to Plugin class
var PluginInfinityMixin = {
    _initInfinity: function() {
        this.infinity.on(YouboraInfinity.Event.NAV, this._navListener.bind(this));
        this.infinity.on(YouboraInfinity.Event.SESSION_START, this._sessionStartListener.bind(this));
        this.infinity.on(YouboraInfinity.Event.SESSION_STOP, this._sessionStopListener.bind(this));
        this.infinity.on(YouboraInfinity.Event.EVENT, this._eventListener.bind(this));
    },
    _sendInfinity: function(willSendEvent, service, params) {
        params = this.requestBuilder.buildParams(params, service);
        var data = {
            params: params,
            plugin: this,
            adapter: this.getAdapter(),
            adsAdapter: this.getAdsAdapter()
        };
        this.emit(willSendEvent, data);
        if (this.infinity._comm && params !== null && this.options.enabled) {
            this.lastServeiceSent = service;
            var request = new YBRequest(null, service, params);
            if (this.isMethodPostEnabled()) request.setPostRequest(true);
            this.infinity._comm.sendRequest(request);
        }
    },
    // ---------------------------------------- LISTENERS -----------------------------------------
    _navListener: function(e) {
        var params = e.data.params || {};
        this._sendInfinity(Constants.WillSendEvent.WILL_SEND_NAV, Constants.Service.NAV, params);
        // start beats
        if (!this._beat.isRunning) this._beat.start();
        Log.notice(Constants.Service.NAV + " " + params.route);
    },
    _sessionStartListener: function(e) {
        var params = e.data.params || {};
        this._sendInfinity(Constants.WillSendEvent.WILL_SEND_SESSION_START, Constants.Service.SESSION_START, params);
        // start beats
        if (!this._beat.isRunning) this._beat.start();
        Log.notice(Constants.Service.SESSION_START + " " + params.route);
    },
    _sessionStopListener: function(e) {
        var params = e.data.params || {};
        this._sendInfinity(Constants.WillSendEvent.WILL_SEND_SESSION_STOP, Constants.Service.SESSION_STOP, params);
        // stop beats
        if (this._beat.isRunning) this._beat.stop();
        Log.notice(Constants.Service.SESSION_STOP + " " + params.route);
    },
    _eventListener: function(e) {
        var params = e.data.params || {};
        this._sendInfinity(Constants.WillSendEvent.WILL_SEND_EVENT, Constants.Service.EVENT, params);
        Log.notice(Constants.Service.EVENT + " " + params.name);
    },
    /**
   * Sends beat request
   *
   * @param {number} diffTime Time since the last ping
   *
   * @private
   * @memberof youbora.Plugin.prototype
   */ _sendBeat: function(diffTime) {
        var params = {
            diffTime: diffTime
        };
        this._sendInfinity(Constants.WillSendEvent.WILL_SEND_BEAT, Constants.Service.BEAT, params);
        if (this.infinity) this.infinity._setLastActive();
        Log.verbose(Constants.Service.BEAT);
    },
    // ---------------------------------------- GETTERS -----------------------------------------
    /**
* Returns a json with the metrics to be reported in beats when changed
*
* @memberof youbora.Plugin.prototype
*/ getSessionMetrics: function() {
        return Util.getMetricsFrom(this.options["session.metrics"]);
    }
};
module.exports = PluginInfinityMixin;

},{"f0c9ef35b7bbe0ac":"92xpS","2764206c439c722c":"8xsxZ","cae63f66ee08eff6":"6hKtj","832bd489d2f6c3dc":"drhpF","82c8e019079ec1cf":"7fbyw"}],"ezfuK":[function(require,module,exports) {
// This file is designed to add extra functionalities to Plugin class
var Util = require("5aea264df660f37c");
var PluginInfinityGettersMixin = {
    getContext: function() {
        return "Default";
    },
    getScrollDepth: function() {
        var ret = this.storage.getSession("pageScrollDepth");
        this.storage.removeSession("pageScrollDepth");
        return ret;
    },
    getSession: function() {
        var ret = this.storage.getStorages("session");
        // Some tvs set the value as 'undefined' as string when deleting the value
        if (ret === "undefined") ret = undefined;
        if (!ret) {
            var data = this.getStoredData();
            if (data) try {
                ret = JSON.parse(data).q.c;
            } catch (err) {
            // nothing
            }
        }
        return ret;
    },
    getStorageHost: function() {
        var ret = null;
        var data = this.getStoredData();
        if (data) try {
            ret = JSON.parse(data).q.h;
        } catch (err) {
        // nothing
        }
        return ret ? Util.addProtocol(ret, this.options["app.https"]) : ret;
    },
    getStoredData: function() {
        return this.storage.getStorages("data");
    },
    getDataTime: function() {
        return this.storage.getStorages("dataTime");
    },
    getLastActive: function() {
        return this.storage.getStorages("lastactive");
    },
    setStoredData: function(data) {
        this.storage.setStorages("data", data);
    },
    setSession: function(session) {
        this.storage.setStorages("session", session);
    },
    setDataTime: function(time) {
        this.storage.setStorages("dataTime", time);
    },
    setLastActive: function(last) {
        this.storage.setStorages("lastactive", last);
    },
    getPageName: function() {
        if (typeof document !== "undefined" && document.title) return document.title;
    },
    getPageLoadTime: function() {
        return this.browserLoadTimes.getPageLoadTime();
    },
    getIsSessionExpired: function() {
        var now = new Date().getTime();
        return !this.getSession() || this.infinity.getFirstActive() < now - this.sessionExpire;
    },
    getIsDataExpired: function() {
        var now = new Date().getTime();
        return !this.storage.isEnabled() || !this.getStoredData() || this.infinity.getFirstActive() < now - this.sessionExpire;
    }
};
module.exports = PluginInfinityGettersMixin;

},{"5aea264df660f37c":"drhpF"}],"6TsZp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "customAAMPAdapter", ()=>customAAMPAdapter);
var _youboralib = require("youboralib");
var _youboralibDefault = parcelHelpers.interopDefault(_youboralib);
var _messengers = require("../helpers/Messengers");
var _utils = require("../helpers/utils");
var _nineStore = require("../helpers/nine-store");
const customAAMPAdapter = (0, _youboralibDefault.default).Adapter.extend({
    currentBitrate: -1,
    currentTime: -1,
    listeners: [],
    /** Override to return current plugin version. */ getVersion () {
        return `accedo-mle-${(0, _nineStore.Store).appVersion}-js`;
    },
    /** Override to return current playhead of the video. */ getPlayhead () {
        return this.currentTime;
    },
    /** Override to return current playrate. */ getPlayrate () {
        // Fast-forward and rewind is done by seeking on an interval.
        return 1;
    },
    /** Override to return current bitrate. */ getBitrate () {
        return this.currentBitrate;
    },
    /** Override to return rendition. */ getRendition () {
        // API for video dimensions is unavailable on AAMP media player.
        return (0, _youboralibDefault.default).Util.buildRenditionString(this.getBitrate());
    },
    /** Override to return true if live and false if VOD. */ getIsLive () {
        return this.isLive;
    },
    /** Override to return latency. */ getLatency () {
        // API for latency is unavailable on AAMP media player.
        return 0;
    },
    /** Override to return resource URL. */ getResource () {
        return (0, _nineStore.Store).currentStreamUrl;
    },
    /** Override to return player version. */ getPlayerVersion () {
        return (0, _nineStore.Store).aampVersion;
    },
    /** Override to return player's name. */ getPlayerName () {
        return "AAMP";
    },
    /** Register listeners to this.player. */ registerListeners () {
        // need to bind this so we can reference the base NPAW class's methods
        this.listeners = [
            ...this.listeners,
            (0, _messengers.Messengers).streamReady$.addReceiver(this.playListener.bind(this)),
            (0, _messengers.Messengers).timeUpdate$.addReceiver(this.progressListener.bind(this)),
            (0, _messengers.Messengers).bitrateChange$.addReceiver(this.onBitrateChange.bind(this)),
            (0, _messengers.Messengers).playerState$.addReceiver(this.onPlayerStateChange.bind(this))
        ];
    },
    /** Unregister listeners to this.player. */ unregisterListeners () {
        // Disable playhead monitoring.
        if (this.monitor) this.monitor.stop();
        this.listeners.forEach((receiver)=>receiver.unlisten());
        this.listeners = [];
    },
    /** Whether the playback is for live content is set outside of the adapter. */ setIsLive (isLive) {
        this.isLive = isLive;
    },
    onBitrateChange (bitrate) {
        this.currentBitrate = bitrate;
    },
    progressListener (time) {
        this.currentTime = time;
        if (this.getPlayhead() <= 0) // hearbeat may start before player loads and plays video
        return;
        if (!this.flags.isStarted) {
            if (this.startedOnce || !this.plugin.getIsLive()) {
                this.fireStart({}, "progressListener");
                this.fireJoin({}, "progressListener");
            }
        } else if (!this.flags.isJoined && this.plugin.getIsLive()) this.fireJoin({}, "progressListener");
    },
    /** Listener for 'play' event, we do this on init immediately */ playListener () {
        this.fireStart({}, "playListener");
        this.startedOnce = true;
    },
    onPlayerStateChange (playerState) {
        if (playerState === (0, _utils.PlayerStates).Playing) this.playingListener();
        else if (playerState === (0, _utils.PlayerStates).Seeking) this.seekingListener();
        else if (playerState === (0, _utils.PlayerStates).Paused) this.pauseListener();
        else if (playerState === (0, _utils.PlayerStates).Buffering) this.bufferingListener();
    },
    /** Listener for 'pause' event. */ pauseListener () {
        if (!this.flags.isBuffering) this.firePause({}, "pauseListener");
    },
    /** Listener for 'playing' event. */ playingListener () {
        this.fireJoin({}, "playingListener");
        this.fireBufferEnd({}, "playingListener");
        this.fireSeekEnd({}, "playingListener");
        this.fireResume({}, "playingListener");
    },
    seekingListener () {
        this.fireSeekBegin({}, false, "seekingListener");
    },
    bufferingListener () {
        this.fireBufferBegin({}, false, "bufferingListener");
    },
    /** Listener for 'ended' event. Never gets called by us */ endedListener () {
        this.fireStop({}, "endedListener");
    }
});

},{"youboralib":"k8N3l","../helpers/Messengers":"48YTm","../helpers/utils":"lhCx6","../helpers/nine-store":"d7nPH","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}],"cxKPT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getActiveListing", ()=>getActiveListing);
var _nineApi = require("./nine-api");
var _messengers = require("../helpers/Messengers");
var _nineStore = require("../helpers/nine-store");
let programCheckTimeout = null;
let currentChannelData = null;
const DEFAULT_PROGRAM_POLL_MS = 60000;
const getActiveListing = (channel)=>{
    var _channel_listings;
    const nowMs = Date.now();
    return channel === null || channel === void 0 ? void 0 : (_channel_listings = channel.listings) === null || _channel_listings === void 0 ? void 0 : _channel_listings.find((listing)=>new Date(listing.endTime).getTime() > nowMs && new Date(listing.startTime).getTime() < nowMs);
};
const getTimeTillProgramEnd = (channel)=>{
    const activeListing = getActiveListing(channel);
    if (!activeListing) {
        console.log("[acc] no matching listing found in program time check");
        return -1;
    }
    const msTillEnd = new Date(activeListing.endTime).getTime() - Date.now();
    return msTillEnd > 0 ? msTillEnd : -1;
};
const checkProgramChangedAfterMs = (timeMs)=>{
    const checkTimeoutLengthMs = timeMs > 0 ? timeMs : DEFAULT_PROGRAM_POLL_MS;
    console.log(`[acc] Will check for program change in ${checkTimeoutLengthMs / 1000} seconds`);
    if (programCheckTimeout) clearTimeout(programCheckTimeout);
    programCheckTimeout = window.setTimeout(async ()=>{
        try {
            const mostRecentLiveChannelResponse = await (0, _nineApi.get9NowLiveChannel)((0, _nineStore.Store).channelSlug, (0, _nineStore.Store).region);
            const activeListing = getActiveListing(mostRecentLiveChannelResponse);
            const hasProgramChanged = (currentChannelData === null || currentChannelData === void 0 ? void 0 : currentChannelData.listings[0].id) !== (activeListing === null || activeListing === void 0 ? void 0 : activeListing.id);
            if (mostRecentLiveChannelResponse && hasProgramChanged) {
                currentChannelData = mostRecentLiveChannelResponse;
                (0, _messengers.Messengers).programChange$.send(currentChannelData);
                checkProgramChangedAfterMs(getTimeTillProgramEnd(currentChannelData));
            } else checkProgramChangedAfterMs(DEFAULT_PROGRAM_POLL_MS);
        } catch (err) {
            console.warn("[acc] Error polling program change", err);
            checkProgramChangedAfterMs(DEFAULT_PROGRAM_POLL_MS);
        }
    }, checkTimeoutLengthMs);
};
const onStreamReady = (channel)=>{
    if (!channel) return;
    currentChannelData = channel;
    const timeTillEndMs = getTimeTillProgramEnd(channel);
    checkProgramChangedAfterMs(timeTillEndMs);
};
(0, _messengers.Messengers).streamReady$.addReceiver(onStreamReady);
(0, _messengers.Messengers).appTeardown$.addReceiver(()=>{
    if (programCheckTimeout) clearTimeout(programCheckTimeout);
});

},{"./nine-api":"90vPW","../helpers/Messengers":"48YTm","../helpers/nine-store":"d7nPH","@parcel/transformer-js/src/esmodule-helpers.js":"840Gs"}]},["fnLED"], null, "parcelRequire0a42")

//# sourceMappingURL=index.js.map
